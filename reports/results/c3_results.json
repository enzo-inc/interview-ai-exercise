{
  "config": "c3",
  "timestamp": "2025-12-10T21:39:03.683743",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.9240506329113924,
      "mrr": 0.7824894514767932,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.3214285714285716,
      "abstention_accuracy": 0.4
    }
  },
  "results_by_category": {
    "auth": {
      "count": 7,
      "avg_accuracy": 4.0,
      "retrieval_hit_rate": 0.8571428571428571
    },
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.2222222222222223,
      "retrieval_hit_rate": 0.6666666666666666
    },
    "factual": {
      "count": 21,
      "avg_accuracy": 3.0476190476190474,
      "retrieval_hit_rate": 1.0
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 4.0,
      "retrieval_hit_rate": 0.0
    },
    "endpoint": {
      "count": 21,
      "avg_accuracy": 3.8095238095238093,
      "retrieval_hit_rate": 0.9047619047619048
    },
    "schema": {
      "count": 21,
      "avg_accuracy": 3.1904761904761907,
      "retrieval_hit_rate": 1.0
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The default value of the `expires_in` field is **3600**, and this duration is expressed in **seconds**.",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_paths_post_connect_sessions_authenticate_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `GET /requests/platform-logs`, the sort order is controlled **not via `filter`**, but via the top\u2011level query parameters:\n\n- `order_by` (string): which field to sort on  \n- `order_direction` (string): which direction to sort in\n\nThe spec you provided does **not** list any specific filter properties that control sort order; it only defines:\n\n- `filter` (object): \u201cFilter parameters that allow greater customisation of the list response\u201d (no sub\u2011fields documented)\n- `order_by`: \u201cThe field to order the results by.\u201d\n- `order_direction`: \u201cThe direction to order the results by.\u201d\n\nBecause no concrete `filter.*` keys are documented as affecting sorting, the only properties you can use to control sort order are:\n\n1. `order_by`  \n   - Allowed values: not explicitly enumerated in the spec. Commonly these would be sortable fields from `PlatformLog`, e.g. `event_datetime`, `start_time`, `end_time`, `status`, `duration`, etc., but the documentation here does not formally define the allowed list.\n\n2. `order_direction`  \n   - Allowed values: also not explicitly enumerated. By convention for this kind of API, expected values are typically:\n     - `\"asc\"` \u2013 ascending order  \n     - `\"desc\"` \u2013 descending order  \n\nSo, based strictly on the provided context:\n\n- **Filter properties**: none are documented as controlling sort order.  \n- **Sort-related properties**: `order_by` (field name) and `order_direction` (likely `\"asc\"`/`\"desc\"`).",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_components_platformlogspaginated",
        "stackone_components_platformlog"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You must use the `x-account-id` HTTP header to pass the target provider account identifier.  \n\nIf you omit this header, you can provide the same value as a query parameter named `x-account-id` in the request URL.",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_mcp",
        "stackone_paths_post_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the **`GET /requests/logs`** endpoint (`stackone_list_logs`) to retrieve a paginated list of unified request logs.\n\nTo achieve what you described:\n\n- **Endpoint:** `GET /requests/logs`\n- **Pagination & ordering query parameters:**\n  - `order_by` \u2013 field to order by\n  - `order_direction` \u2013 direction to order (e.g., asc/desc)\n  - `page_size` \u2013 number of results per page (default 25)\n  - `next` \u2013 unified cursor for pagination\n\n- **Filtering by HTTP method and provider:**\n  - Use the `filter` query parameter (object) to pass filter conditions such as:\n    - `filter[method]=GET` (or POST, etc.)\n    - `filter[provider]=some_provider_name`\n  \n  (Exact field names under `filter` depend on your implementation, but they are passed via the `filter` object.)\n\n- **Including step logs in the response:**\n  - Use the `include` query parameter to request extra data:\n    - e.g. `include=steps` or `include=step_logs` (depending on how your API defines includes)\n\nSo, a typical call might look like:\n\n`GET /requests/logs?order_by=created_at&order_direction=desc&page_size=25&filter[method]=GET&filter[provider]=my_provider&include=steps`",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyrequestbody"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the `GET /requests/logs` endpoint (operation ID: `stackone_list_logs`) to retrieve a **paginated list of request logs**.\n\n**Endpoint:**\n- `GET /requests/logs`\n\n**Pagination-related query parameters:**\n- `page_size` (number, optional): Number of results per page (default 25)\n- `next` (string, optional): Unified cursor for fetching the next page\n\n**Filtering and sorting query parameters:**\n- `order_by` (string, optional): Field to order the results by\n- `order_direction` (string, optional): Direction to order the results by (e.g., `asc`, `desc`)\n- `filter` (object, optional): Used to filter logs, including by:\n  - **Account IDs**\n  - **HTTP methods**\n  - **Providers**\n  - **Success status**\n\n(The exact shape of the `filter` object isn\u2019t detailed in the snippet, but those fields are supported via this `filter` parameter.)",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_paths_post_actions_rpc"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Use the `GET /actions` endpoint (operation ID: `stackone_list_actions_meta`) to list all actions metadata.\n\nAvailable query parameters for filtering and pagination:\n\n- `page_size` (string, optional): Number of results per page (default: 25).\n- `next` (string, optional): Unified cursor for fetching the next page (pagination).\n- `group_by` (string, optional): Relation to group the results by.\n- `filter` (object, optional): Filters to apply to the actions metadata.\n- `include` (array, optional): Additional related data to include in the response.",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_components_actionsmeta",
        "stackone_components_actionsmetapaginated",
        "stackone_paths_post_actions_rpc",
        "stackone_paths_get_requests_logs"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "- **Type:** `string`  \n- **Description:** \u201cThe method of the request\u201d  \n- **Allowed values:** Not restricted by the schema (any string is allowed; typical usage would be HTTP methods such as `GET`, `POST`, `PUT`, `DELETE`, etc., but this is not enforced by the schema).  \n- **Default value:** None specified  \n- **Nullable:** No (the schema does not indicate that it can be null)",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_jsonrpcmessagedto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The StackOne documentation you\u2019ve provided defines `method` in `ProxyRequestBody` only as:\n\n> - method (string): The method of the request\n\nIt does **not** list a constrained set of allowed values or specify any default.\n\nFrom standard HTTP semantics and typical proxy APIs, the intended allowed values are the standard HTTP methods (e.g., `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS`), but this is **not explicitly stated** in the given context. Likewise, there is **no documented default** if `method` is omitted.\n\nSo, based solely on the provided context:\n\n- Allowed values: **Not explicitly specified**; only described as a string.\n- Default if omitted: **Not defined** in the documentation (no default is documented).",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_proxyresponseapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `POST /connect_sessions` (creating a connect session) using the `ConnectSessionCreate` schema:\n\n**Required fields in the request body:**\n- `origin_owner_id` (string) \u2013 the origin owner identifier  \n- `origin_owner_name` (string) \u2013 the origin owner name  \n\nAll other fields (`categories`, `provider`, `provider_version`, `origin_username`, `account_id`, `expires_in`, `metadata`, `multiple`) are optional.\n\n**Allowed values for its `type` property:**\nThe `ConnectSessionCreate` schema, as provided, does **not** define a `type` property at all, so there are no allowed values for `type` on this request body. The `type` field only appears on the `ConnectSession` / `ConnectSessionTokenAuthLink` response schemas, and its allowed values are not specified in the given context.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsession",
        "stackone_components_connectsessiontokenauthlink"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the `/mcp` endpoints, the supported authentication and relevant headers are:\n\n**Supported authentication scheme**\n- **HTTP Basic Authentication** is required for all three MCP endpoints:\n  - `POST /mcp` (send JSON\u2011RPC message)\n  - `GET /mcp` (open SSE stream)\n  - `DELETE /mcp` (close session)\n\nNo other auth schemes (e.g., bearer tokens, API keys) are mentioned for these endpoints.\n\n**Headers related to authentication and account context**\n\n1. **Account context: `x-account-id`**\n   - Can be provided either as:\n     - `x-account-id` **header** (optional), or\n     - `x-account-id` **query parameter** (alternative to header)\n   - Present on all `/mcp` endpoints:\n     - `POST /mcp`\n     - `GET /mcp`\n     - `DELETE /mcp`\n   - Use one form or the other to identify the **target provider account**; both are optional but at least one is typically needed when you want to target a specific account.\n\n2. **Session identifier: `mcp-session-id`**\n   - **Header** only (no query variant).\n   - Behavior by endpoint:\n     - `POST /mcp`:\n       - `mcp-session-id` header is **optional**.\n       - **Omit** it when **initializing** a new MCP session (first JSON\u2011RPC call).\n       - **Include** it for all **subsequent** JSON\u2011RPC calls in the same session.\n     - `GET /mcp`:\n       - `mcp-session-id` header is **required** to open a dedicated SSE stream for that session.\n     - `DELETE /mcp`:\n       - `mcp-session-id` header is **required** to identify which session to close.\n\n3. **Content negotiation / stream type: `Accept` (for SSE)**\n   - `GET /mcp` only:\n     - `Accept` header is **required** and must be:\n       - `Accept: text/event-stream`\n     - This is not an auth header but is mandatory when opening the SSE stream.\n\n**Summary per operation**\n\n- **POST `/mcp`** (send JSON\u2011RPC)\n  - Auth: HTTP Basic (required)\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (optional; omit for first call, include thereafter)\n\n- **GET `/mcp`** (open SSE stream)\n  - Auth: HTTP Basic (required)\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (**required**)\n    - `Accept: text/event-stream` (**required**)\n\n- **DELETE `/mcp`** (close session)\n  - Auth: HTTP Basic (required)\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (**required**)",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_components_authenticationmetaitem",
        "stackone_paths_post_connect_sessions_authenticate_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "There is no filter field on `GET /unified/hris/time_off_policies` that lets you restrict results by a policy type such as \"vacation\" or \"sick\", and therefore there is no corresponding enum schema defined for such a filter in the provided context.",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_components_timeoffbalanceresult_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_components_hriscreatetimeoffrequestdto_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You can use the `filter[type]` query parameter to filter the employee\u2019s time off policies by type.\n\nThree valid values for this `type` filter are:\n1. `VACATION`  \n2. `SICK`  \n3. `PERSONAL`",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "No default status is applied. If the `status` field is omitted in the `UpdateTaskRequestDto` payload, the API does not specify any default value; the task\u2019s status will remain unchanged unless explicitly provided.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_patch_unified_hris_employees_id_tasks_subresourceid",
        "hris_components_updatetaskrequestdto",
        "hris_components_task_part0",
        "hris_paths_get_unified_hris_employees_id_tasks_subresourceid_part1",
        "hris_components_taskstatusenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **\u201cList Assigned Time Off Policies\u201d** endpoint:\n\n**Endpoint:**  \n`GET /unified/hris/employees/{id}/time_off_policies`\n\n**Required parameters:**\n\n1. **Path parameter**\n   - `id` (string): The identifier of the employee whose assigned time off policies you want to list.\n\n2. **Header**\n   - `x-account-id` (string): The account identifier.\n\nNo request body is required.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the `GET /time_off` endpoint with operation ID **`hris_list_employee_time_off_requests`** to list all employee time off requests.\n\nTo filter by a specific time off policy ID, use the **`filter`** query parameter (HRIS Time Off filters) and include the desired time off policy ID within that filter object.",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_part1",
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_components_timeoffbalanceresult_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **Create Employee Time Off Request** endpoint:\n\n- **Endpoint:**  \n  `POST /unified/hris/employees/{id}/time_off`\n\n- **HTTP Method:**  \n  `POST`\n\n- **Required header parameter:**  \n  - `x-account-id` (string): The account identifier\n\n- **Required path parameter:**  \n  - `id` (string): The employee\u2019s ID\n\n- **Required JSON request body fields (at minimum, per the spec):**  \n  - `approver_id` (string): The approver ID  \n  - `status` (unknown type): Status of the time off request  \n  - `type` (unknown type): Type of time off (e.g., vacation, sick)  \n  - `start_date` (string): Start date/time in ISO8601 without timezone  \n  - `end_date` (string): Inclusive end date/time in ISO8601 without timezone  \n  - `start_half_day` (unknown): Whether it starts halfway through the first day  \n  - `end_half_day` (unknown): Whether it ends halfway through the last day  \n  - `time_off_policy_id` (string): Associated time off policy ID  \n\nAdditional optional fields mentioned include `duration`, `remote_time_off_policy_id`, and others depending on your integration.",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_components_timeoff_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_components_timeoffresult_part1",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Here\u2019s what can appear in a single `Employment` object (one element of an employee\u2019s `employments` array) in the HRIS API, based on the provided context, and how those fields relate to enums / deprecations.\n\n---\n\n## 1. Top\u2011level properties of `Employment`\n\nA single `Employment` object can have the following top\u2011level fields:\n\n1. **`id`** (`string`)  \n   - Description: Unique identifier (StackOne\u2019s own ID for the employment record).\n\n2. **`remote_id`** (`string`)  \n   - Description: Provider's unique identifier for the employment record.\n\n3. **`unified_custom_fields`** (`object`)  \n   - Description: Custom Unified Fields configured in your StackOne project.  \n   - Notes: Generic object map, not a dedicated schema.\n\n4. **`job_title`** (`string`)  \n   - Description: The job title of the employee.\n\n5. **`pay_rate`** (`string`)  \n   - Description: The amount of compensation for the employee (raw rate value; not strongly typed to a numeric here).\n\n6. **`pay_period`** (`unknown`)  \n   - Description: The time period over which the pay rate is calculated (e.g., hourly, daily, monthly, annual).  \n   - Notes: Likely an enum in the underlying model, but in this excerpt it is represented as `unknown` and not explicitly tied to an enum wrapper schema.\n\n7. **`pay_frequency`** (`unknown`)  \n   - Description: How often the employee is paid (e.g., weekly, bi\u2011weekly, monthly).  \n   - Notes: Also represented as `unknown` here; same situation as `pay_period`.\n\n8. **`pay_currency`** (`string`)  \n   - Description: The currency used for pay (e.g., `\"USD\"`, `\"EUR\"`).\n\n9. **`effective_date`** (`string`)  \n   - Description: The effective date of the employment contract.\n\n10. **`end_date`** (`string`)  \n    - Description: The end date of employment.\n\n11. **`grade`** (`unknown`)  \n    - Description (from context):  \n      > Represents the employee\u2019s position within the organizational hierarchy.  \n    - Notes:\n      - The description block you provided under `EmploymentTypeEnum` is actually describing `grade` and then listing a set of related employment fields (see next section).  \n      - In the excerpt, `grade` is typed as `unknown` at the `Employment` level, but the same description appears under `EmploymentTypeEnum`, suggesting a shared conceptual model or that `grade`/employment type metadata may be wrapped in an enum/structured object in some providers.\n\n12. **`employment_type`** (`unknown`)  \n    - Description:  \n      > The type of employment (e.g., contractor, permanent)\n\n13. **`employment_contract_type`** (`unknown`)  \n    - Description:  \n      > The employment work schedule type (e.g., full-time, part-time)\n\n14. **`raw`** (`array of object`)  \n    - Description: Provider\u2011specific raw payloads.  \n    - Notes: An array of objects; each object corresponds to raw data from a source system.\n\n> The fragment in your prompt repeats/embeds this part of the schema and mentions:\n>\n> - `grade` (unknown): Represents the employee\u2019s position within the organizational hierarchy.  \n> - `employment_type` (unknown): The type of employment (e.g., contractor, permanent)  \n> - `employment_contract_type` (unknown): The employment work schedule type (e.g., full-time, part-time)  \n> - `type` (unknown): The type of employment  \n> - `contract_type` (unknown): The employment work schedule type  \n> - `... and 15 more fields`\n\nThis indicates that internally there is a block of related fields around employment grading and type information, but only some are explicitly named in the provided excerpt.\n\n---\n\n## 2. Fields that use enum wrapper schemas\n\nFrom the context, the API defines separate enum wrapper schemas:\n\n### `EmploymentTypeEnum` (Schema)\n\n- **Type**: `object`\n- **Description**: Schema for `EmploymentTypeEnum`\n- **Properties**:\n  - `value` (`string`)\n  - `source_value` (`unknown`)\n  - `raw` (`array of object`)\n- Description text under this schema includes:\n  - `employment_type`: The type of employment (e.g., contractor, permanent)\n  - `employment_contract_type`: The employment work schedule type (e.g., full-time, part-time)\n  - `type`: The type of employment\n  - `contract_type`: The employment work schedule type\n  - `grade`: Represents the employee\u2019s position within the organizational hierarchy.\n  - `... and 15 more fields`\n\nThis indicates:\n\n- There is a *wrapper* enum/object type used for employment type\u2013related properties.\n- The wrapper follows the pattern:\n  - A normalized `value`\n  - The original provider `source_value`\n  - `raw` provider objects\n- The description associates the following logical fields with this \u201cemployment type\u201d group:\n  - `employment_type`\n  - `employment_contract_type`\n  - `type`\n  - `contract_type`\n  - and around 15 additional related fields, including `grade`.\n\nHowever, in the `Employment` schema excerpt you provided, these are still typed as `unknown` rather than explicitly as `EmploymentTypeEnum`. So:\n\n- **Conceptually**: `employment_type`, `employment_contract_type`, possibly `type` and `contract_type`, and perhaps `grade` can be or are backed by the `EmploymentTypeEnum` wrapper.\n- **In the snippet**: They are not explicitly declared as `EmploymentTypeEnum` type; they are just shown as `unknown`.\n\n### `EmploymentScheduleTypeEnum` (Schema)\n\n- **Type**: `object`\n- **Description**: Schema for `EmploymentScheduleTypeEnum`\n- **Properties**:\n  - `value` (`string`)\n  - `source_value` (`unknown`)\n\nThis is another enum-wrapper style object, similar pattern to `EmploymentTypeEnum` (but without `raw` explicitly listed here). Given the naming and descriptions:\n\n- It almost certainly corresponds to fields like:\n  - `employment_contract_type`\n  - `contract_type`\n- In the excerpt, those fields are still `unknown`, but the existence of `EmploymentScheduleTypeEnum` indicates that in the underlying model, they may use this enum wrapper.\n\n---\n\n## 3. Nested or related structures within `Employment`\n\nWithin a single `Employment` object, the explicit nested/structured parts in the given context are:\n\n- **`unified_custom_fields`**: An `object` containing custom fields (not strongly typed to a specific schema).\n- **`raw`**: An array of `object`, where each object is provider-specific.\n- **Enum wrappers (conceptual)**:\n  - Although not shown as strong types in the `Employment` definition snippet, the following employment attributes are described under enum wrapper schemas (`EmploymentTypeEnum` / `EmploymentScheduleTypeEnum`):\n    - `employment_type`\n    - `employment_contract_type`\n    - `type`\n    - `contract_type`\n    - some or all of the `grade`-related metadata and \u201c15 more fields\u201d.\n\nSo, they are *logically* nested/structured via enum wrappers, even if the current excerpt types them as `unknown`.\n\n---\n\n## 4. Deprecated properties\n\nBased solely on the provided context:\n\n- **No property is explicitly marked as deprecated** in the text you included.\n- Some fields (`type`, `contract_type`) look like older or alternate names for `employment_type` and `employment_contract_type`, which often signals deprecation or aliasing in real APIs, but:\n  - The snippet does **not** mark them with a \u201cdeprecated\u201d flag or wording.\n  - Therefore, they cannot be definitively classified as deprecated from this context alone.\n\n---\n\n### Summary\n\n- A single `Employment` object can contain:  \n  `id`, `remote_id`, `unified_custom_fields`, `job_title`, `pay_rate`, `pay_period`, `pay_frequency`, `pay_currency`, `effective_date`, `end_date`, `grade`, `employment_type`, `employment_contract_type`, and `raw`.\n- `unified_custom_fields` and `raw` are nested structures (object, and array of objects).\n- There are enum wrapper schemas:\n  - `EmploymentTypeEnum` for employment type / grade\u2013related attributes.\n  - `EmploymentScheduleTypeEnum` for schedule/contract\u2011type attributes.\n- The fields most clearly associated with these enums are:\n  - `employment_type`, `employment_contract_type`, `type`, `contract_type`, and `grade` plus \u201c15 more\u201d related fields.\n- The provided context does not explicitly label any of these fields as deprecated.",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employmenttypeenum",
        "hris_paths_get_unified_hris_employments_id_part3",
        "hris_components_employment_part0",
        "hris_components_employmentresult_part1",
        "hris_components_employmentscheduletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `EmployeesPaginated` response schema:\n\n**Required fields**\n- `data` (array of object) \u2013 **required**  \n  - Contains the actual list/collection of employee objects returned for this page.\n\n**Other properties**\n\n1. `next_page`\n   - **Type:** string  \n   - **Purpose:** Holds a token, cursor, or page identifier representing the *next page* of employee results. It\u2019s typically used as an input to another request to fetch the subsequent page.\n\n2. `next`\n   - **Type:** string  \n   - **Purpose:** Usually a fully-formed URL or path that can be called directly to retrieve the next page of results. While `next_page` is often just an opaque token, `next` is often a convenience link.\n\n3. `raw`\n   - **Type:** array of object  \n   - **Purpose:** Contains the unprocessed or original employee data as returned from the underlying HR system or source, before any normalization or transformation into the main `data` structure.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employeespaginated",
        "hris_components_createhrisbenefit",
        "hris_components_hrisjobspaginated",
        "hris_components_shiftbreak",
        "hris_components_employmentspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In `HrisCreateEmployeeRequestDto`, the following fields are used:\n\n- **Gender**:  \n  - **Field**: `gender`  \n  - **Enum schema type**: `HrisEmployeeGenderEnum` (or equivalent employee-gender enum schema in the HRIS API)\n\n- **Preferred language**:  \n  - **Field**: `preferred_language`  \n  - **Enum schema type**: `HrisEmployeePreferredLanguageEnum` (or equivalent preferred-language enum schema)\n\n- **Ethnicity**:  \n  - **Field**: `ethnicity`  \n  - **Enum schema type**: `HrisEmployeeEthnicityEnum` (or equivalent employee-ethnicity enum schema)\n\nThese enum types define the allowed values for each respective field.",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hriscreateemploymentrequestdto_part0",
        "hris_components_hrisupdateemploymentrequestdto_part0",
        "hris_components_createemployeeemploymentapimodel_part0",
        "hris_components_employment_part0",
        "hris_components_hriscreateemployeerequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You must use **Bearer token authentication** and include the following HTTP header:\n\n```http\nAuthorization: Bearer <YOUR_ACCESS_TOKEN>\n```",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_id_part0",
        "hris_components_downloadheadersapimodel",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_components_iso3166_2subdivisionenum",
        "hris_paths_get_unified_hris_time_off_types_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The GET `/unified/ats/job_postings` endpoint uses the `updated_after` query parameter to filter job postings by creation/update time, and its value must be provided as a string (typically an ISO 8601 timestamp).",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_job_postings_id_part1",
        "ats_paths_get_unified_ats_job_postings_id_part0",
        "ats_components_jobpostingstatusenum",
        "ats_paths_get_unified_ats_jobs_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The `x-speakeasy-pagination` metadata for the ATS **List Offers** endpoint specifies:\n\n- **Pagination type:** `cursor`\n- **Cursor input query parameter name:** `next`",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_offerspaginated",
        "ats_paths_get_unified_ats_lists_part0",
        "ats_paths_get_unified_ats_offers_part0",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_paths_get_unified_ats_interviews_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The supported `filter.change_type` enum values for `GET /unified/ats/applications/{id}/changes` are:\n\n- `status_changed`  \n- `interview_scheduled`  \n- `interview_rescheduled`  \n- `interview_cancelled`  \n- `offer_created`  \n- `offer_updated`  \n- `offer_withdrawn`  \n- `hired`  \n- `rejected`",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_applicationchanges",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_paths_get_unified_ats_applications_part0",
        "ats_components_applicationchangetypeenum",
        "ats_paths_get_unified_ats_applications_id_changes_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use an HTTP **GET** request to the job postings list endpoint, and control pagination, field selection, and date filtering via query parameters.\n\n**HTTP method:**  \n`GET`\n\n**Path (example):**  \n`/job-postings`  \n(or the exact job postings list path defined by the API, e.g. `/ats/job-postings`)\n\n**Key query parameters:**\n\n- `page` (optional): Page number of results to fetch  \n  - Example: `page=1`\n- `page_size` (optional): Number of results per page  \n  - Example: `page_size=50`\n- `updated_after` (optional): Only return postings updated (or created, depending on API semantics) after a given date  \n  - Example (ISO 8601 string): `updated_after=2024-01-01T00:00:00Z`\n- `include` (optional): Comma\u2011separated list of fields to include in the response  \n  - Example: `include=id,title,status`\n- `next` (optional): Unified cursor for cursor-based pagination (use the value returned in the previous response\u2019s `next` when continuing)\n\n**Example request URL:**\n\n```http\nGET /job-postings?page=1&page_size=25&include=id,title,status&updated_after=2024-01-01T00:00:00Z HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer <token>\n```\n\nTo fetch the next page using cursor-based pagination:\n\n```http\nGET /job-postings?next=<next_cursor_value>&include=id,title,status HTTP/1.1\n```",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "ats_paths_get_unified_ats_applications_part1",
        "ats_paths_get_unified_ats_job_postings_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1",
        "ats_paths_get_unified_ats_background_checks_packages_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS endpoint:\n\n`GET /unified/ats/applications/{id}/notes/{subResourceId}`\n\nYou must include the **`id`** path parameter in the URL, which is the identifier of the specific application whose notes you want to retrieve.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part0",
        "ats_paths_get_unified_ats_applications_part1",
        "ats_paths_get_unified_ats_candidates_id_notes_subresourceid_part0",
        "ats_components_interviewpart_part0",
        "ats_paths_get_unified_ats_applications_id_changes_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the **`/applications/{id}/documents/upload`** endpoint (operation ID: `ats_upload_application_document`) to upload a base64\u2011encoded resume for an **existing application**.\n\nIt requires a JSON request body that follows the **`AtsDocumentsUploadRequestDto`** schema, with these fields:\n\n- `name` (string): Filename of the file to upload  \n- `file_format` (unknown): File format of the file (e.g., pdf, docx \u2013 provider-specific)  \n- `content` (string): **Base64\u2011encoded** content of the file  \n- `category_id` (string): Category ID of the document (if applicable)  \n- `path` (string): Path where the file should be uploaded  \n- `confidential` (unknown): Confidentiality level of the file  \n- `category` (unknown): Category object/name to associate with the file (ID takes precedence over name)\n\nYou must also provide:\n- `x-account-id` header  \n- `id` path parameter: the identifier of the existing application you\u2019re attaching the resume to.",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atsdocumentsuploadrequestdto",
        "ats_components_atscreateapplicationrequestdto",
        "ats_components_atscreatecandidaterequestdto",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part1",
        "ats_components_atsupdatecandidaterequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema has the following fields:\n\n1. **statusCode**  \n   - **Type:** number  \n   - **Required:** yes  \n   - **Purpose:** The HTTP status code associated with the bad request (e.g., 400). It tells the client what kind of error occurred at the HTTP level.\n\n2. **message**  \n   - **Type:** string  \n   - **Required:** yes  \n   - **Purpose:** A human-readable error message describing what went wrong with the request.\n\n3. **timestamp**  \n   - **Type:** string  \n   - **Required:** yes  \n   - **Purpose:** The time at which the error occurred, allowing clients to track when the bad request happened (useful for logging and debugging).\n\n4. **data**  \n   - **Type:** unknown  \n   - **Required:** no  \n   - **Purpose:** Additional error details. This can hold any extra structured information about the error that doesn\u2019t fit into the basic fields.\n\n5. **provider_errors**  \n   - **Type:** array of object  \n   - **Required:** no  \n   - **Purpose:** A list of provider-specific error objects, giving more granular information returned by underlying providers or external systems involved in processing the request.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "ats_components_badrequestresponse",
        "ats_paths_get_unified_ats_applications_id_part1",
        "ats_components_unauthorizedresponse",
        "ats_paths_get_unified_ats_jobs_id_part1",
        "ats_components_badgatewayresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `AtsUpdateCandidateRequestDto` schema (for updating a candidate) is defined as an **object** with the following fields and types:\n\n- **passthrough**: `object`  \n  Value to pass through to the provider.\n\n- **unified_custom_fields**: `object`  \n  Custom Unified Fields configured in your StackOne project.\n\n- **name**: `string`  \n  Candidate name.\n\n- **first_name**: `string`  \n  Candidate first name.\n\n- **last_name**: `string`  \n  Candidate last name.\n\n- **email**: `string`  \n  Candidate email.\n\n- **emails**: `array of object`  \n  List of candidate emails.\n\n- **social_links**: `array of object`  \n  List of candidate social links.\n\n- **phone**: `string`  \n  Candidate phone number.\n\n- **phone_numbers**: `array of object`  \n  List of candidate phone numbers including the type of the number when available.\n\n- **company**: `string`  \n  Candidate company.\n\n- **title**: `string`  \n  Candidate title.\n\n- **application_ids**: `array of string`  \n  List of candidate application IDs.\n\n- **hired_at**: `string`  \n  Candidate hired date.\n\n- **country**: `string`  \n  Candidate country.\n\nThe provided context does **not** indicate that any of these properties are **deprecated** or **nullable**. No deprecation flags or explicit `nullable: true` annotations are shown for any field in `AtsUpdateCandidateRequestDto` in the given schema excerpt.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atscreateapplicationrequestdto",
        "ats_components_atsupdatecandidaterequestdto_part0",
        "ats_components_fileformatenum",
        "ats_components_atsupdatecandidatesassessmentsresultsrequestdto",
        "ats_components_atscreatecandidaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The `AttachmentContentType.value` field is an enum with these possible values:\n\n- `txt`  \n- `csv`  \n- `tsv`  \n- `doc`  \n- `docx`  \n- `odt`  \n- `pdf`  \n- `ppt`  \n- `pptx`  \n- `xls`  \n- `xlsx`  \n- `xml`  \n- `rtf`  \n- `png`  \n- `jpg`  \n- `jpeg`  \n- `gif`  \n- `tiff`  \n- `webp`  \n- `mp3`  \n- `m4a`  \n- `ogg`  \n- `wav`  \n- `webm`  \n- `avi`  \n- `mp4`  \n- `mpeg`  \n- `zip`  \n- `tar`  \n- `gz`  \n- `rar`  \n- `7z`  \n- `other`\n\nThe provider\u2019s original content type value is exposed via the `AttachmentContentType.source_value` property.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "ats_components_attachmentcontenttype",
        "ats_components_field",
        "ats_components_atsupdatebackgroundcheckresultrequestdto",
        "ats_components_attachment",
        "ats_components_atsdocumenttypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id: <your account identifier>`",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_patch_unified_ats_background_checks_orders_id_result_part0",
        "ats_paths_post_unified_ats_background_checks_orders",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part0",
        "ats_paths_get_unified_ats_background_checks_packages_id_part0",
        "ats_paths_get_unified_ats_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory request body field is **`learning_object_id`**, and it represents **the identifier of the learning object (e.g., course, module, or content item) to which the user is being assigned**.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_id_part1",
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory field is **`learning_object_external_reference`**. It represents **the external reference (main identifier) of the learning object that the assignment links the user to** and is the key identifier used when creating the assignment.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_id_part1",
        "lms_components_assignment_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is **`learning_object_external_reference`**, described as *\u201cthe main identifier for creating assignments.\u201d*",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_components_assignment_part0",
        "lms_components_assignment_part1",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You should call the **`GET /unified/lms/users/{id}/assignments`** endpoint (operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment\u2011type learning records for a specific user**.\n\nTo **filter those assignments by `status` and `updated_after`**, you use the **`filter` query parameter** (an object) and include the desired fields inside it, for example:\n\n- `filter[status]` \u2013 to filter by assignment status (e.g., `pending`, `in_progress`, `completed`)\n- `filter[updated_after]` \u2013 to return only assignments updated after a given timestamp\n\nYou can also use:\n\n- `page` \u2013 to select which page of results to fetch  \n- `page_size` \u2013 if supported in your implementation for page size (not explicitly listed for the user-assignments endpoint in the snippet, but commonly paired with `page`)",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_assignments_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **`GET /unified/lms/users/{id}/assignments`** endpoint (`lms_list_user_assignments`) to retrieve a paginated list of assignment learning records for a specific user.\n\nTo filter those assignments by status (e.g. `completed`), use the **`filter`** query parameter (the *LMS Assignment Filter*), which supports filtering by assignment status.",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_users_id_completions_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **`GET /unified/lms/users/{id}/completions`** endpoint (operation ID: `lms_list_user_completions`) to retrieve all completed learning records for a specific user.\n\n**Required parameters:**\n1. **Path parameter**\n   - `id` \u2013 the identifier of the user whose completions you want to retrieve\n\n2. **Header**\n   - `x-account-id` \u2013 the account identifier",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_completions_part0",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_get_unified_lms_completions_id_part1",
        "lms_paths_post_unified_lms_users_id_completions_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is:\n\n- **learning_object_external_reference** (string) \u2013 This is the external reference of the learning object associated with the completion and is the main identifier used when creating a completion.\n\nTwo optional fields you can include to capture completion details are, for example:\n\n- **completed_at** (string) \u2013 The date the content was completed.  \n- **time_spent** (string) \u2013 The time spent completing the learning object, in ISO 8601 duration format.",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_components_completion_part1",
        "lms_components_completion_part0",
        "lms_components_completionresult_part1",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In the `LmsCreateAssignmentRequestDto` request body, the **only explicitly required field** is:\n\n- `learning_object_external_reference` (string)\n\n**Purpose of this required field:**\n`learning_object_external_reference` is the **main identifier for the learning object** when creating assignments. It links the new assignment record to the specific learning object (course, module, etc.) it refers to, and is the primary identifier used by the system to create the assignment.",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required fields in `LmsCreateAssignmentRequestDto` when calling  \n`POST /unified/lms/users/{id}/assignments` are:\n\n- `external_reference` \u2013 **required** (this is the assignment\u2019s own external reference)\n- `assigned_at` \u2013 **required**\n- `due_date` \u2013 **required**\n\n`learning_object_id` is only required if a specific integration demands it; otherwise it is optional. `progress`, `status`, and `passthrough` are also optional.\n\n**Purpose of `learning_object_external_reference`:**  \n`learning_object_external_reference` is the external identifier of the learning object that the assignment links the user to. It is the **main identifier used to specify which learning object the assignment is for**, and is therefore the key reference used when creating assignments to tie them to the correct course/learning object in the underlying LMS.",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part3",
        "lms_paths_get_unified_lms_assignments_id_part3",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must include:\n\n1. **Authentication:** HTTP Basic Auth  \n2. **Required header:** `x-account-id` (string) \u2013 the account identifier\n\nBoth of these are specified in the OpenAPI description under the **\u201cAuthentication: HTTP Basic\u201d** section and the **\u201cParameters\u201d** list, where `x-account-id` is defined as a **required header parameter**.",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part0",
        "lms_paths_put_unified_lms_content_part0",
        "lms_paths_post_unified_lms_users_id_completions_part0",
        "lms_paths_post_unified_lms_content_batch",
        "lms_paths_get_unified_lms_courses_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `page` query parameter is deprecated for pagination.  \nYou should use the newer cursor-based `next` query parameter instead.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_get_unified_iam_policies_id_part1",
        "iam_paths_get_unified_iam_policies_id_part0",
        "iam_components_fileformatenum",
        "iam_components_iampoliciespaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `fields` query parameter, and include the related objects you want as a comma\u2011separated list. For example:\n\n`GET /unified/iam/users?fields=roles,groups`\n\nThis tells the API to return the full `roles` and `groups` objects in the user response instead of just their identifiers.",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_components_iamuserresult_part0",
        "iam_components_iamuser"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `raw` query parameter, and its default value is `false` (meaning only the mapped result is returned unless you set `raw=true`).",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_id_part0",
        "iam_paths_get_unified_iam_policies_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the `GET /unified/iam/groups` endpoint, and you must include the `x-account-id` header in the request.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_groups_part0",
        "iam_components_iamuser",
        "iam_paths_get_unified_iam_groups_id_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_iamgroupspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the **IAM endpoint**:\n\n**`PATCH /unified/iam/users/{id}`**\n\n### Mandatory parameters\n\n1. **Path parameter**\n   - `id` (string, required): The unique identifier of the user to update.\n\n2. **Header parameter**\n   - `x-account-id` (string, required): The account identifier.\n\n3. **Authentication**\n   - HTTP Basic auth is required.\n\n### Mandatory request body schema\n\nThe request body must be a JSON object following **`IamUpdateUserRequestDto`**.  \nTo update the primary email address, include at least:\n\n```json\n{\n  \"primary_email_address\": \"new.email@company.com\"\n}\n```\n\nOther updatable fields in the same schema (all optional unless your own business logic requires them) are:\n\n- `first_name` (string)\n- `last_name` (string)\n- `name` (string)\n- `username` (string)\n- `is_bot_user` (unknown): Indicates if the user is a bot or service user\n- `status` (unknown)\n- `passthrough` (object): Value to pass through to the provider",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iamupdateuserrequestdto",
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamuser",
        "iam_components_iamuserresult_part0",
        "iam_paths_get_unified_iam_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the following IAM endpoint:\n\n**Endpoint:** `GET /unified/iam/policies`  \n**Operation ID:** `iam_list_policies`  \n\nThis endpoint returns an `IamPoliciesPaginated` object, which includes:\n- `data`: the list of policy objects\n- `next_page` / `next`: cursors or tokens for fetching subsequent pages\n- `raw`: optional raw provider responses (when enabled)\n\n### Query parameters for pagination and filtering\n\nYou can use these query parameters to control pagination and filtering of the results:\n\n- **Pagination:**\n  - `page` (string, optional): The page number of the results to fetch.\n  - `page_size` (string, optional): The number of results per page (default is `25`).\n  - `next` (string, optional): A cursor/token for fetching the next page of results (as returned in the previous response).\n\n- **Filtering and field selection:**\n  - `filter` (object, optional): Filter parameters that allow more customized list responses.  \n  - `fields` (string, optional): A comma-separated list of fields to include in the response. If empty, all fields are returned.\n\n- **Other controls:**\n  - `raw` (boolean, optional): If `true`, returns the raw provider result in addition to the mapped result (default is `false`).\n  - `proxy` (object, optional): Pass-through query parameters to the underlying provider by nesting them under the `proxy` key.",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_components_iamuser",
        "iam_components_iampoliciespaginated",
        "iam_components_iamupdateuserrequestdto",
        "iam_paths_get_unified_iam_policies_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `DeleteResult` response schema for `DELETE /unified/iam/users/{id}` contains these fields:\n\n- `statusCode` (number) \u2013 **required**\n- `message` (string) \u2013 **required**\n- `timestamp` (string) \u2013 **required**",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_delete_unified_iam_users_id",
        "iam_components_iamuserresult_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_iamuser",
        "iam_components_deleteresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "When a user is successfully deleted via `DELETE /unified/iam/users/{id}`, the IAM API returns a `DeleteResult` object with the following properties:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required  \n\nAll three fields in `DeleteResult` are required.",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iamuserresult_part0",
        "iam_components_iamuser",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API:\n\n- The `value` field of `IamPermissionTypeEnum` is a normalized string describing the permission type, with examples including:  \n  - `\"read\"`  \n  - `\"read_write\"`  \n  - `\"delete\"`  \n  (and potentially similar action types as supported by the system).\n\n- The underlying raw provider-specific permission type is stored separately in the `source_value` field.  \n  - `source_value` holds whatever value the upstream IAM provider actually returned (e.g., a vendor-specific action name or code), without normalization.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iampermission",
        "iam_components_iampermissiontypeenum",
        "iam_components_iamresourcetypeenum",
        "iam_components_iammfatypeenum",
        "iam_components_roletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints (e.g., `GET /unified/iam/users` and `GET /unified/iam/roles`) use **HTTP Basic Authentication**, and you must include the required header:\n\n- `x-account-id`: the account identifier\n\nWithout HTTP Basic auth credentials and the `x-account-id` header, the request will not be authorized.",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_iamuser",
        "iam_paths_get_unified_iam_users_id_part0",
        "iam_paths_get_unified_iam_roles_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` backoff strategy is explicitly configured to trigger on HTTP status code **408** only.",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and its data format is a **string representing a date**.",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies that HTTP **408**, **429**, **5XX**, and **ETIMEDOUT** responses are retried using the **backoff** strategy.",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You should call the **`GET /unified/crm/contacts`** endpoint.\n\nFor your requirements:\n\n- **Update filter (only contacts updated after a specific timestamp):**  \n  - Use the **`updated_after`** query parameter (string date).\n\n- **Cursor-based pagination:**  \n  - Use the **`next`** query parameter (the unified cursor returned from the previous response).  \n  - You can also use **`page_size`** to control how many results are returned per page.",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_accounts_part1",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint:** `GET /crm/contacts/{id}`  \n- **Operation ID:** `crm_get_contact`\n\nInclude this required header with the account identifier:\n\n- **Header:** `x-account-id: {your_account_id}`",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part2",
        "crm_paths_post_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_id_part1",
        "stackone_paths_get_accounts_id",
        "crm_components_contact_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the `GET /unified/crm/custom_field_definitions/contacts` endpoint to retrieve all custom field definitions for contacts.\n\nThe query parameter that enables cursor-based pagination is `next`.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0",
        "crm_components_customfieldoption",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The `CrmCreateContactRequestDto` request body for the **Create Contact** endpoint can include these fields:\n\n- `first_name` (string): The contact\u2019s first name  \n- `last_name` (string): The contact\u2019s last name  \n- `company_name` (string): The contact\u2019s company name  \n- `emails` (array of string): List of the contact\u2019s email addresses  \n- `phone_numbers` (array of string): List of the contact\u2019s phone numbers  \n- `deal_ids` (array of string): List of associated deal IDs  \n- `account_ids` (array of string): List of associated account IDs  \n- `custom_fields` (array of object): Custom fields specific to this contact  \n- `passthrough` (object): A free-form object whose contents are passed through directly to the underlying provider. It\u2019s used to send provider-specific or non-standard fields/parameters that are not part of the unified schema.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part1",
        "crm_components_crmcreatecontactrequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_patch_unified_crm_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The `GET /unified/crm/contacts` endpoint returns a `200` response with a body of type **`ContactsPaginated`**. Its structure is:\n\n```json\n{\n  \"next_page\": \"string or null\",\n  \"next\": \"string or null\",\n  \"data\": [\n    { /* contact object */ },\n    { /* contact object */ }\n  ],\n  \"raw\": [\n    { /* raw provider response for corresponding contacts, if requested */ }\n  ]\n}\n```\n\nField details:\n\n- **`data`** (array of object, required)  \n  - The list of **mapped contact objects** in the unified CRM schema.\n  - Each element is a contact record as normalized by the unified API.\n\n- **`next_page`** (string)  \n  - A **page-based pagination token** (e.g., next page number or identifier).\n  - Used when paginating by page/page_size.\n\n- **`next`** (string)  \n  - A **cursor-based pagination token**.\n  - Returned when cursor-based pagination is supported and can be passed as the `next` query parameter on the next call to continue listing.\n\n- **`raw`** (array of object)  \n  - Present when `raw=true` is passed in the query.\n  - Contains the **raw provider-specific payloads** corresponding to the contacts in `data`, exposing fields exactly as returned by the underlying CRM provider.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the CRM API, when creating or updating a contact with `CrmCreateContactRequestDto`, the relevant request body properties are:\n\n### `custom_fields`\n\n- **Type:** `array` of `object`\n- **Item schema:** follows the `CustomFields` schema\n- **Structure of each custom field object:**\n  - `id` (string, optional): Unique identifier of the custom field.\n  - `remote_id` (string, optional): Provider\u2019s unique identifier of the custom field.\n  - `name` (string, optional): Name of the custom field.\n  - `value` (unknown type, optional): Value of the custom field.  \n    - Can be any JSON type: string, number, boolean, object, array, or null.\n  - `value_id` (string, optional): Unique identifier for the value of the custom field (e.g., for picklists/options).\n  - `remote_value_id` (string, optional): Provider\u2019s unique identifier for the value.\n\nIn practice, `custom_fields` is an array like:\n```json\n\"custom_fields\": [\n  {\n    \"id\": \"cf_123\",\n    \"name\": \"Customer Tier\",\n    \"value\": \"Gold\",\n    \"value_id\": \"opt_1\"\n  },\n  {\n    \"remote_id\": \"provider_cf_456\",\n    \"name\": \"Is Beta User\",\n    \"value\": true\n  }\n]\n```\n\n### `passthrough`\n\n- **Type:** `object`\n- **Description:** Arbitrary key\u2013value payload to send through to the underlying provider.\n- **Allowed data types:** Any valid JSON types for property values:\n  - string, number, boolean, object, array, or null.\n\nExample:\n```json\n\"passthrough\": {\n  \"provider_specific\": {\n    \"lead_source\": \"web_form\",\n    \"tags\": [\"important\", \"newsletter\"]\n  },\n  \"trace_id\": \"abc123\"\n}\n```\n\nSo:\n- `custom_fields` is an array of structured objects matching the `CustomFields` schema, with `value` being any JSON type.\n- `passthrough` is a free-form JSON object with no fixed schema, allowing any JSON-serializable data.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_components_contact_part0",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_components_customfieldoption",
        "crm_components_customfields"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id`: the account identifier (e.g., `x-account-id: your_account_id_here`)",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_accounts_id_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_post_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Described purpose:** It is *\u201cThe account identifier\u201d* that must be included on every request.",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_content_blocks_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The `x-speakeasy-pagination` configuration treats the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_email_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and it is specified to be a **string containing a date** (i.e., \u201cUse a string with a date to only select results updated after that given date\u201d).",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part1",
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_components_campaignresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **`PATCH /unified/marketing/templates/push/{id}`** endpoint.\n\n**Endpoint:**\n- `PATCH /unified/marketing/templates/push/{id}`  \n- Operation ID: `marketing_update_push_template`\n\n**Required parameters:**\n- `x-account-id` (header, string): The account identifier  \n- `id` (path, string): The identifier of the push template you want to update  \n\n**Required request body (JSON):**\n```json\n{\n  \"name\": \"string\",\n  \"tags\": [\"string\"],\n  \"messages\": [ { /* object */ } ],\n  \"passthrough\": { /* object, value passed through to provider */ }\n}\n```\n\nFields in the body:\n- `name` (string)\n- `tags` (array of string)\n- `messages` (array of object)\n- `passthrough` (object): Value to pass through to the provider",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_paths_get_unified_marketing_templates_push_id_part1",
        "marketing_components_pushtemplate",
        "marketing_components_pushtemplateresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **`PATCH /unified/marketing/templates/push/{id}`** endpoint.\n\n- **HTTP method:** `PATCH`  \n- **Required header parameter:**  \n  - `x-account-id` (string) \u2013 The account identifier  \n- **Required path parameter:**  \n  - `id` (string) \u2013 The identifier of the push template to update",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_paths_get_unified_marketing_templates_push_id_part0",
        "marketing_paths_patch_unified_marketing_templates_sms_id",
        "marketing_paths_patch_unified_marketing_templates_email_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to retrieve a paginated list of SMS templates.  \n\nYou must include the `x-account-id` header to identify the account.",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_post_unified_marketing_templates_sms",
        "marketing_paths_patch_unified_marketing_templates_sms_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You can include the following fields in the request body when creating a new content block with `MarketingCreateContentBlocksRequestDto`:\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (enum / unknown): Stackone enum identifying the type of content block\n- `passthrough` (object)\n\nPurpose of the special fields:\n\n- `type`: Indicates the kind of content block you are creating (e.g., different structural or channel-specific types). It uses a Stackone-defined enum so the system knows how to treat/render this block.\n\n- `passthrough`: A free-form object used to send provider-specific or custom data that Stackone will forward unchanged to the underlying marketing provider, without interpreting or modifying it.",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_components_marketingcreatetemplaterequestdto",
        "marketing_components_marketingcreateinapptemplaterequestdto",
        "marketing_components_marketingcreateemailtemplaterequestdto",
        "marketing_components_marketingcreatepushtemplaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `POST /unified/marketing/content_blocks`, the JSON request body can include the following fields (as per `MarketingCreateContentBlocksRequestDto`):\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (unknown / enum) \u2013 Stackone enum identifying the type of content block\n- `passthrough` (object) \u2013 arbitrary value to pass through to the provider\n\nRegarding the allowed value set for the `type` field:  \nThe documentation only states that `type` is a \u201cStackone enum identifying the type of content block\u201d and does not list the specific possible values. Therefore, based on the provided context, the exact allowed enum values for `ContentBlock.type` cannot be determined.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_paths_patch_unified_marketing_content_blocks_id",
        "marketing_paths_get_unified_marketing_content_blocks_part0",
        "marketing_components_contentblock"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For the `PushTemplatesPaginated` response from `GET /unified/marketing/templates/push`, the **only required field** is:\n\n- **`data`** (required)  \n  - **Type:** `array`  \n  - **Items type:** `object`  \n  - **Schema reference:** each item corresponds to a **`PushTemplate`** object (i.e., uses the `PushTemplate` schema).",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_pushtemplatespaginated",
        "marketing_components_pushtemplate",
        "marketing_paths_get_unified_marketing_templates_push_part0",
        "marketing_components_pushtemplateresult",
        "marketing_components_marketingcreatepushtemplaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You must use **HTTP Basic** authentication, and you must include the required header:\n\n- `x-account-id`: the account identifier for the account context.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The APIs in this sample that support listing resources with a `filter.updated_after` parameter are:\n\n1. **HRIS \u2013 ShiftBreak (Schema: ShiftBreak)**  \n   - **Parameter**: `filter.updated_after`  \n   - **Type**: string (query parameter)  \n   - **Format**: A date as a string, used to select only results updated after that date.\n\n2. **The API returning \u201cthe list of application custom field definitions\u201d**  \n   - **Parameter**: `filter.updated_after`  \n   - **Type**: string (query parameter)  \n   - **Format**: A date as a string, used to select only results updated after that date.\n\n3. **The API related to `completion` (learning object completions)**  \n   - **Parameter**: `filter.updated_after`  \n   - **Type**: string (query parameter)  \n   - **Format**: A date as a string, used to select only results updated after that date.\n\n4. **The API returning \u201cthe list of application document categories\u201d**  \n   - **Parameter**: `filter.updated_after`  \n   - **Type**: string (query parameter)  \n   - **Format**: A date as a string, used to select only results updated after that date.\n\nIn all of these APIs, `filter.updated_after` is a **string** query parameter, representing a **date string** used to return only resources updated after the specified date.",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part2",
        "hris_components_shiftbreak",
        "ats_paths_get_unified_ats_custom_field_definitions_applications_part1",
        "lms_components_completion_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "For both APIs, pagination is controlled in the same way on the **request**, and cursor-based pagination is represented in the same way in the **response**.\n\n### Request-side pagination\n\n**IAM \u2013 List Users (`GET /unified/iam/users`)**\n\nPagination-related query parameters:\n- `page` (optional, string): The page number of the results to fetch.\n- `page_size` (optional, string): Number of results per page (default 25).\n- `next` (optional, string): The unified cursor (used for cursor-based pagination).\n\n**CRM \u2013 List Contacts (`GET /unified/crm/contacts`)**\n\nPagination-related query parameters:\n- `page` (optional, string): The page number of the results to fetch.\n- `page_size` (optional, string): Number of results per page (default 25).\n- `next` (optional, string): The unified cursor (used for cursor-based pagination).\n\nSo, both APIs expose the same three query parameters to control pagination: `page`, `page_size`, and `next`.\n\n### Response-side cursor-based pagination\n\n**IAM \u2013 Response schema: `IamUsersPaginated`**\n\nProperties:\n- `next_page` (string): Indicates the next page number (for page-based pagination).\n- `next` (string): Cursor token for unified/cursor-based pagination.\n- `data` (array, required): The current page of user records.\n- `raw` (array): Raw provider data, if requested.\n\n**CRM \u2013 Response schema: `ContactsPaginated`**\n\nProperties:\n- `next_page` (string): Indicates the next page number (for page-based pagination).\n- `next` (string): Cursor token for unified/cursor-based pagination.\n- `data` (array, required): The current page of contact records.\n- `raw` (array): Raw provider data, if requested.\n\nThus, in both IAM and CRM:\n- **Request pagination**: controlled by `page`, `page_size`, and `next`.\n- **Cursor-based pagination**: the cursor is passed via `next` in the request, and the next cursor is returned in the `next` field of the paginated response (`IamUsersPaginated` or `ContactsPaginated`).",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "iam_paths_get_unified_iam_users_part0",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_part1",
        "iam_components_iamuserspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "- **HRIS employee document download (GET /unified/hris/employees/{id}/documents/{subResourceId}/download)**  \n  - **Response media type:** Binary file content (the response body is described as \u201cThe file data in binary format\u201d). In practice this will be served with a file-oriented `Content-Type` (e.g., `application/pdf`, `application/octet-stream`, etc.), communicated via the response **headers** object.  \n  - **Response schema:**  \n    ```json\n    {\n      \"headers\": { /* unknown, download-related headers */ },\n      \"data\": \"string (binary)\"\n    }\n    ```  \n    - `headers`: contains HTTP headers relevant to the download (e.g., `Content-Type`, `Content-Length`, `Content-Disposition`), but is typed as `unknown`.  \n    - `data`: a binary string representing the file content.\n\n- **IAM schema that provides file metadata (`remote_url`, `file_format`, etc.)**  \n  From the sampled specs, the schema that clearly exposes `remote_url` and `file_format` as part of file metadata is the **HRIS \"File\" schema** (and equivalently the HRIS document schemas such as `HrisDocumentApiModel` / `HrisDocumentResult.data`). For IAM-side correlation, the relevant structure is:\n\n  **Schema: File**\n  ```json\n  {\n    \"id\": \"string\",\n    \"remote_id\": \"string\",\n    \"name\": \"string\",\n    \"category\": \"unknown\",\n    \"contents\": [ {} ],              // deprecated\n    \"category_id\": \"string\",\n    \"created_at\": \"string\",\n    \"updated_at\": \"string\",\n    \"remote_url\": \"string\",          // URL where file content is located\n    \"file_format\": \"unknown\"         // file format of the file\n  }\n  ```\n\n  The same key metadata fields also appear in:\n  - `HrisDocumentApiModel`\n  - `HrisDocumentResult.data`\n\n  These contain:\n  - `id`, `remote_id`\n  - `name`, `category`, `category_id`\n  - `remote_url`\n  - `file_format`\n  - `created_at`, `updated_at`\n  - `type`, `unified_custom_fields`, etc.\n\n- **How to combine the two APIs\u2019 responses for auditing**\n\n  1. **Capture the download event from the HRIS download endpoint**  \n     - Log:\n       - Employee identifier: path parameter `id`\n       - Document identifier: path parameter `subResourceId`\n       - Any query parameters affecting the download: `format`, `export_format`\n       - Response headers: especially `Content-Type`, `Content-Length`, and any filename information (e.g., `Content-Disposition`).\n       - A hash of `data` (binary) such as SHA-256, rather than the raw file, for integrity auditing.\n\n  2. **Fetch / correlate file metadata from the IAM/HRIS file metadata schema**  \n     - Use `subResourceId` (document/file `id`) and, if needed, `remote_id` to query the IAM/HRIS metadata resource that exposes the **File / HrisDocumentApiModel** structure.\n     - From that schema, record:\n       - `id`, `remote_id`\n       - `name`\n       - `category`, `category_id`\n       - `remote_url`\n       - `file_format`\n       - `type` (content type classification)\n       - `created_at`, `updated_at`\n       - Any `unified_custom_fields` relevant for compliance (e.g., retention class, confidentiality).\n\n  3. **Construct a unified audit record by joining on the document/file ID**  \n     - Key join fields:\n       - `id` (HRIS document ID == `subResourceId`)\n       - Optionally `remote_id` if you also log provider-level events.\n     - For each download, the audit entry can include:\n       - Who/what: employee `id`, calling system/user (from auth context, not specified in spec but available at runtime).\n       - What: document metadata from **File / HrisDocumentApiModel** (`name`, `category`, `remote_url`, `file_format`, `type`).\n       - How it was delivered: values derived from the download response (`headers.Content-Type`, `headers.Content-Length`, requested `format`/`export_format`).\n       - Integrity: hash of the binary `data` payload to prove which exact version was downloaded.\n       - When: timestamps derived both from request time and metadata (`created_at`, `updated_at`).\n\n  4. **Use cases for auditing**\n     - Verify that the binary content downloaded (`data` + hash + `Content-Type`) matches what is expected from the metadata (`file_format`, `remote_url`).\n     - Track which confidential categories or paths (`category`, `category_id`, and any confidentiality in `unified_custom_fields`) were accessed and how often.\n     - Reconstruct a history of access and file state (version via `updated_at`) at each download time.\n\nIn summary:  \n- The **download endpoint** returns binary file data plus generic headers (`{ headers, data }`).  \n- The **File/HrisDocument* schemas** provide file metadata (`remote_url`, `file_format`, etc.).  \n- Your monitoring tool should log download events from the first, enrich them with metadata from the second (joined by document `id` / `remote_id`), and store that merged view as the audit record.",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hrisdocumentresult",
        "hris_components_hrisdocumentapimodel",
        "hris_paths_post_unified_hris_employees_id_documents_upload_part1",
        "hris_components_file",
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_download"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "From the context provided:\n\n- **Unified APIs that require the `x-account-id` header (in addition to HTTP Basic auth):**\n  - **HRIS** \u2013 e.g. `hris_update_employee_employment`  \n    - Endpoint pattern: includes `x-account-id` (header, required, string): The account identifier\n  - **LMS** \u2013 the external content provider endpoint snippet shown  \n    - Also explicitly lists `x-account-id` (header, required, string): The account identifier\n\n- **StackOne endpoints that use only HTTP Basic auth and do *not* require `x-account-id`:**\n  - **Connect Sessions API** \u2013 e.g. `POST /connect_sessions/authenticate` (`stackone_authenticate_connect_session`)  \n    - Uses HTTP Basic authentication with a request body containing `token`, but no `x-account-id` header.\n\nThe context does not show concrete examples for ATS, IAM, CRM, or MARKETING endpoints, so only HRIS and LMS are explicitly confirmed as requiring the `x-account-id` header, while the Connect Sessions endpoint uses just basic auth without it.",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_patch_unified_hris_employees_id_employments_subresourceid_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_paths_post_connect_sessions_part1",
        "lms_paths_put_unified_lms_content_part1",
        "stackone_components_connectsessioncreate_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "Cursor-based pagination for these endpoints is implemented in a largely shared, cross-vertical way, with only minor differences.\n\n**1. Shared pagination query parameters**\n\nAll three endpoints support the same core pagination parameters:\n\n- `page` (query, optional, string): The page number of the results to fetch  \n- `page_size` (query, optional, string): The number of results per page (default 25)  \n- `next` (query, optional, string): The unified cursor  \n\nSo, cursor-based pagination is driven by the **`next`** query parameter across:\n\n- HRIS \u2013 `GET /unified/hris/jobs`\n- ATS \u2013 `GET /unified/ats/job_postings` (you asked about \u201cATS list lists\u201d but the ATS example provided is Job Postings)\n- CRM \u2013 `GET /unified/crm/contacts`\n\nAlthough the context truncates the descriptions for `next` on HRIS and CRM, they follow the same \u201cunified cursor\u201d pattern explicitly described in the ATS endpoints.\n\n**2. Shared non-pagination parameters (relevant to pagination behavior)**\n\nAll three also share:\n\n- `x-account-id` (header): required, identifies the account.\n- `raw` (query, boolean): whether to return the raw provider result as well.\n- `proxy` (query, object): pass-through parameters to the underlying provider.\n- `fields` (query, string): to limit fields returned.\n- `filter` (query, object): to constrain which records are listed, which indirectly affects pagination results.\n\nThese are not cursor parameters per se, but they influence which records appear on a given page.\n\n**3. Differences in pagination-related parameters**\n\n- **ATS vs HRIS/CRM:**  \n  - ATS job endpoints (e.g., `GET /unified/ats/jobs`, `GET /unified/ats/job_postings`) add an **`updated_after`** query parameter to support incremental sync. HRIS `jobs` and CRM `contacts` in the provided context do **not** define `updated_after`.\n  - ATS explicitly documents `next` as \u201cThe unified cursor\u201d in the snippet; HRIS and CRM appear to follow the same convention but their descriptions are truncated in the context.\n\n- **Filter description specificity:**  \n  - HRIS and CRM describe `filter` generically (\u201cFilter parameters that allow greater customisation of the list response\u201d).\n  - ATS uses specialized filter descriptions (e.g., \u201cATS Jobs filters\u201d, \u201cATS Job Postings Filter\u201d), but this is conceptual rather than a structural difference in pagination.\n\n**4. Response fields**\n\nThe context you provided lists **request parameters only**, not explicit response schemas. However, since they all expose a `next` cursor parameter, they are expected to share a corresponding **`next` (cursor) field in the response body** that you pass back into the `next` query parameter for subsequent pages. The \u201cunified cursor\u201d wording for ATS strongly implies the same unified pattern is used across HRIS and CRM.\n\n**Summary**\n\n- **Shared pagination mechanics:** `page`, `page_size`, and `next` query parameters; a `next` cursor field in the response.\n- **Main difference:** ATS endpoints add an `updated_after` parameter for incremental pagination; HRIS `jobs` and CRM `contacts` do not expose that in this context. Otherwise, cursor-based pagination is implemented consistently.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "ats_paths_get_unified_ats_jobs_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "ats_paths_get_unified_ats_job_postings_part0",
        "crm_paths_get_unified_crm_lists_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "To build that audit feature for a single business customer, you\u2019d combine:\n\n1. **StackOne \u201cmeta\u201d layer** \u2013 to get high\u2011level account + connector configuration  \n   Use the **STACKONE ConnectSession / ConnectSessionTokenAuthLink schemas** via the StackOne Connect Sessions endpoints (the context gives schemas, not explicit routes, but the relevant responses are:  \n   - `ConnectSession`  \n   - `ConnectSessionTokenAuthLink`  \n\n   These provide:\n   - `id`\n   - `organization_id`\n   - `project_id`\n   - `categories`\n   - `provider`\n   - `origin_owner_id`\n   - `origin_owner_name`\n   - `origin_username`\n   - `account_id`\n   - `label`\n   - `created_at`\n   - `metadata` (arbitrary key/values, e.g. pricing plan)\n   - `external_trigger_token`\n   - `type` (connect session account type)\n   - `integration_id` (UUID for the integration)\n   - \u2026and the extra 2 fields referenced in the schema\n\n   This is the **high\u2011level business/customer + connector view**.  \n   You\u2019d typically identify the *business customer* by one of:\n   - `account_id`\n   - or a tag in `metadata`\n   - or `origin_owner_id` / `origin_owner_name`\n\n2. **LMS unified API** \u2013 to list users for that same account and filter by email or external reference  \n   Use **LMS: GET `/unified/lms/users`** (`lms_list_users`).\n\n   Key bits:\n   - **Auth & account scoping**\n     - HTTP Basic auth\n     - `x-account-id` (header, required): must be the same account identifier that corresponds to the StackOne ConnectSession\u2019s `account_id` (or however your StackOne project maps business customers to LMS accounts).\n   - **Filtering**\n     - `filter` (query, object): \u201cLMS Users Filter\u201d \u2013 this is where you\u2019d specify:\n       - email-based filter (e.g. `filter[email]=...` depending on filter schema)\n       - external reference filter (e.g. `filter[external_reference]=...`)\n     - You can also use:\n       - `page`, `page_size`, `next` for pagination\n       - `updated_after` to only get recent changes\n   - **Shaping the response**\n     - `fields` (query, string): comma-separated list of user fields to return; if omitted, all mapped fields are returned.\n     - `raw` (query, boolean): if `true`, StackOne returns both the unified/mapped user objects and the underlying provider\u2019s raw payload.\n\n---\n\n### How the filtering & response structures differ\n\n#### 1. StackOne meta (ConnectSession / ConnectSessionTokenAuthLink)\n\n- **Purpose:** configuration + linkage, not domain data.\n- **Filtering (practical usage):**\n  - You typically query by:\n    - connect session ID\n    - `account_id`\n    - or project/organization filters (depending on the exact endpoint you use).\n  - It\u2019s about *which customer* and *which connector*; no per\u2011user filters here.\n- **Response structure:**\n  - A **single object** or list of objects with:\n    - IDs and ownership: `id`, `organization_id`, `project_id`, `origin_owner_id`, `origin_owner_name`, `origin_username`\n    - Connector meta: `provider`, `categories`, `integration_id`, `type`\n    - Account binding: `account_id`, `label`, `metadata`, `external_trigger_token`\n    - Audit\u2011style info: `created_at`\n  - No pagination or user\u2011level fields; it\u2019s a relatively flat configuration object.\n\nThis gives you the \u201cwho is this business customer in StackOne, what connector are they using, and how is their account configured?\u201d view.\n\n#### 2. LMS: GET `/unified/lms/users` (list users)\n\n- **Purpose:** domain data \u2013 the LMS users for that account.\n- **Filtering:**\n  - Scoped by **account** via `x-account-id`.\n  - Per\u2011user filter via `filter`:\n    - Email filter (e.g. `filter[email]=user@example.com`).\n    - External reference filter (e.g. `filter[external_reference]=12345`).\n  - Optional pagination & sync filters:\n    - `page`, `page_size`, `next`, `updated_after`.\n- **Response structure:**\n  - A **paged list** of unified LMS user objects:\n    - Each user has LMS\u2011specific fields (id, email, name, external_reference, etc., depending on provider mapping).\n  - Optional inclusion of provider\u2019s raw payload when `raw=true`.\n  - `fields` lets you trim the unified user fields you get back.\n\nThis gives you the \u201call users in the LMS for this account, optionally narrowed down to a specific email/external_reference\u201d view.\n\n---\n\n### How to combine them for the audit feature\n\n1. **Resolve / look up the business customer via StackOne meta:**\n   - Retrieve the relevant `ConnectSession` or `ConnectSessionTokenAuthLink` object.\n   - From this, read:\n     - `account_id` (to use as `x-account-id` for LMS)\n     - `provider`, `integration_id`, `metadata`, `origin_owner_name`, `created_at`, etc.\n   - Present these fields as the **account + connector audit metadata**.\n\n2. **List users for that same account via LMS:**\n   - Call `GET /unified/lms/users` with:\n     - `x-account-id` = the `account_id` from the ConnectSession.\n     - `filter` including:\n       - email: `filter[email]=...`\n       - or external reference: `filter[external_reference]=...`\n     - Optional: `fields` to control which user attributes to show; `page` / `page_size` for pagination.\n\n3. **UI / report output:**\n   - **Top section**: render `ConnectSession`/`ConnectSessionTokenAuthLink` data (connector type, provider, metadata tags such as pricing plan, created_at, integration_id).\n   - **Bottom section**: render the paged list of LMS users that match the filter, clearly indicating:\n     - Number of users returned\n     - Key user identifiers (id, email, external_reference, etc.).\n\nIn summary:  \n- Use **StackOne ConnectSession/ConnectSessionTokenAuthLink** for high\u2011level customer + connector metadata.  \n- Use **LMS GET `/unified/lms/users`** for all LMS users for that same `x-account-id`, filtered by `email` or `external_reference`.  \n- Meta endpoints return flat configuration objects (no pagination, no per\u2011user filters), while `/unified/lms/users` returns a paginated list of unified user records with rich filter and field-selection options.",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessiontokenauthlink",
        "lms_paths_get_unified_lms_users_part0",
        "stackone_components_connectsession",
        "lms_paths_put_unified_lms_content_part1",
        "lms_paths_put_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following StackOne unified APIs support cursor-based pagination using a `next` query parameter:\n\n1. **ActionsRpcResponse**\n   - **Supports `next` query parameter:** Yes\n   - **Response field returning the cursor:** `next`\n\n2. **ActionsMetaPaginated**\n   - **Supports `next` query parameter:** Yes\n   - **Response field returning the cursor:** `next`\n\n3. **UnifiedLogsPaginated**\n   - **Supports `next` query parameter:** Yes (by the same pagination pattern; `next` is the unified cursor)\n   - **Response field returning the cursor:** `next`",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_actionsrpcresponse",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "stackone_components_actionsmetapaginated",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "stackone_components_unifiedlogspaginated"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "In both APIs, field selection works the same way, but only HRIS Employees explicitly exposes `updated_after` in the provided context; HRIS Jobs and CRM Accounts share the same generic filter mechanism but `updated_after` is not shown as a dedicated parameter for them.\n\n**Field selection**\n\n- **HRIS Jobs (`GET /unified/hris/jobs`)**\n  - Parameter: `fields` (query, optional, string)  \n  - Behavior: Comma\u2011separated list of fields to return; if empty, all fields are returned.\n\n- **CRM Accounts (`GET /unified/crm/accounts`)**\n  - Parameter: `fields` (query, optional, string)  \n  - Behavior: Same as HRIS Jobs: comma\u2011separated list of fields; if empty, all fields are returned.\n\n**Filtering by `updated_after`**\n\n- **HRIS Jobs**\n  - There is a generic filter parameter:  \n    - `filter` (query, optional, object): \u201cFilter parameters that allow greater customisation of the list response.\u201d\n  - The snippet does **not** list a dedicated `updated_after` query parameter for Jobs. If Jobs supports `updated_after`, it would be passed inside `filter` (e.g., `filter[updated_after]=...`), but that is **not explicitly documented** in the given context.\n\n- **CRM Accounts**\n  - There is also a generic filter parameter:  \n    - `filter` (query, optional, object): Same description as above.\n  - The snippet does **not** list a dedicated `updated_after` parameter here either. As with Jobs, if `updated_after` is supported, it would be via `filter`, but this is **not explicitly stated** in the provided text.\n\nSo, explicitly from the context:\n\n- Field selection parameter in both:\n  - HRIS Jobs: `fields`\n  - CRM Accounts: `fields`\n\n- `updated_after`:\n  - Appears explicitly only for **HRIS Employees** (not Jobs, not Accounts).\n  - For Jobs and Accounts, only a generic `filter` object is documented; any `updated_after` filtering would have to be inferred as part of that filter, but is not directly specified.",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "hris_paths_get_unified_hris_custom_field_definitions_employees_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "hris_paths_get_unified_hris_employees_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "- **Authentication mechanism for both endpoints:**  \n  - **HTTP Basic** authentication\n\n- **Required header for both endpoints:**  \n  - `x-account-id` (string) \u2013 identifies the account making the request\n\n- **Common query parameters your client can reuse across both APIs:**\n\n  1. **`raw` (boolean)**  \n     - Purpose: Whether to return the raw provider response in addition to the unified/mapped result.\n\n  2. **`proxy` (object)**  \n     - Purpose: Pass-through parameters to the underlying provider request (wrapped under the `proxy` key).\n\n  3. **`fields` (string)**  \n     - Purpose: Comma-separated list of fields to include in the response (if empty, all fields are returned).\n\n  4. **`filter` (object)**  \n     - Purpose: Filter parameters to customize which records are returned (e.g., by status, date ranges, etc.).\n\n  5. **`page` (string)**  \n     - Purpose: Page number to fetch, for paginating through results.\n\n  6. **`page_size` (string)**  \n     - Purpose: Number of results per page (page size control).\n\n- **Incremental sync parameter:**\n\n  - Only present on the **ATS `List Offers`** endpoint:\n    - **`next` (string)**  \n      - Purpose: Token for unified/incremental pagination or sync to fetch the next set of results.  \n    - There is **no `next` parameter on the MARKETING `List Email Templates`** endpoint in the provided spec, so incremental sync via `next` cannot be reused across both; it is specific to ATS.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "ats_paths_get_unified_ats_offers_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don\u2019t have pricing or commercial details for StackOne in the provided API documentation, and I don\u2019t have up\u2011to\u2011date external pricing information for this specific product.\n\nThe context you shared only covers technical API endpoints and schemas (e.g., `/unified/proxy`, `/accounts`) and doesn\u2019t mention:\n\n- Pricing tiers or plan names  \n- Included request volumes or limits  \n- Overage fees per extra API call  \n- Volume discounts or enterprise arrangements  \n\nTo get accurate, current pricing details (tiers, overages, and volume discounts), you\u2019ll need to:\n\n1. **Check StackOne\u2019s official pricing page** on their website (often `/pricing`).\n2. **Contact StackOne sales/support** directly for:\n   - Current tiers and included monthly API quota\n   - Per\u2011unit overage fees (e.g., per 1,000 or per 1M requests)\n   - Volume or enterprise discounts for high\u2011volume usage\n3. If you already have an account, review:\n   - Your **contract/order form** (for custom pricing)\n   - The **billing/usage section** in the StackOne dashboard, which may outline your plan limits and overage rules.\n\nWithout access to StackOne\u2019s commercial documentation or site, I can\u2019t reliably specify their pricing tiers, overage structure, or discount levels.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "stackone_paths_get_accounts_part0",
        "stackone_components_proxyrequestbody"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** mention or document any **financially backed SLA** (Service Level Agreement) in the provided context. There is no information about:\n\n- Any specific **uptime guarantee** (e.g., 99.9%, 99.95%, etc.)\n- Any **service credits**, refunds, or other **compensation terms** tied to SLA breaches\n\nBased on the given material, you should assume that:\n\n- No formal, financially backed SLA is described.\n- No explicit uptime percentage or compensation framework is provided.\n\nTo get authoritative details, you would need to consult StackOne\u2019s official legal/SLA documentation or contact their sales/support team directly.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_accounts_id_part2",
        "iam_components_iammfatypeenum",
        "stackone_components_preconditionfailedresponse",
        "lms_paths_put_unified_lms_content_part0",
        "stackone_components_badrequestresponse"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "You can\u2019t directly customize the StackOne *web dashboard UI* (e.g., adding custom widgets, changing themes, or defining role-specific layouts) via the public API described here.\n\nFrom the provided context:\n\n- The **Connectors** APIs (`GET /connectors/meta`) and related schemas (`ConnectorsMeta`, `ConnectorsMetaResources`, `ConnectorsMetaResourcesImagesApiModel`) only expose:\n  - Which providers exist and their metadata (name, category, etc.).\n  - Whether they\u2019re active for your project.\n  - Provider resources like logos and images.\n\n- The **Request Logs** API (`GET /requests/logs/steps`) exposes:\n  - Step log data for requests, with pagination and filtering parameters.\n\nThese allow you to **read metadata and logs**, but there is:\n- No endpoint to configure or extend the built-in StackOne dashboard.\n- No schema related to themes, layouts, widgets, or role-based UI configurations.\n\n### What you *can* do instead\n\n1. **Build a custom UI on top of StackOne APIs**\n   - Use `/connectors/meta` to:\n     - List connectors\n     - Show human-readable provider names, categories, and status.\n     - Display provider logos via `resources.images.logo_url` or `original_logo_horizontal_url`.\n   - Use `/requests/logs/steps` to:\n     - Build custom log viewers, charts, or debugging tools.\n     - Apply your own filters, sorting, and pagination.\n\n   In your own application you can then:\n   - Add custom widgets (charts, status cards, connector health, etc.).\n   - Apply your own themes (dark mode, brand colors).\n   - Implement role-based views (e.g., admins see full logs, others see only summaries).\n\n2. **Role-specific views in your app**\n   - Implement authentication/authorization in your own stack (e.g., JWT roles, RBAC).\n   - Show or hide different panels or routes depending on the user\u2019s role, while the backend uses the same StackOne APIs.\n\n### Summary\n\n- The StackOne APIs provided here **do not support direct customization of the official StackOne dashboard**.\n- To add custom widgets, themes, or role-specific views, you\u2019ll need to **build your own UI** that consumes StackOne\u2019s APIs (`/connectors/meta`, `/requests/logs/steps`) and implement customization in your own frontend and auth layer.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectorsmeta",
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_connectors_meta",
        "stackone_components_connectorsmetaresources"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s public API documentation you\u2019ve provided does **not** describe deployment models (cloud vs. on\u2011prem), hardware requirements, or installation steps. It only documents how to call existing StackOne endpoints once a deployment already exists.\n\nBecause of that, I **cannot reliably confirm from this context alone** whether StackOne supports a fully on\u2011premise deployment, nor can I state specific hardware requirements or installer commands.\n\nWhat you should do next (and what typically applies in cases like this):\n\n1. **Check official deployment documentation or sales/solutions engineering:**\n   - Look for a section like \u201cSelf\u2011Hosted / On\u2011Prem\u201d or \u201cEnterprise Deployment\u201d in the StackOne docs or knowledge base.\n   - If you have an enterprise contract or are evaluating StackOne, contact your account rep or support and ask specifically:\n     - \u201cDo you offer a fully on\u2011premise deployment (no outbound data to your cloud)?\u201d\n     - \u201cIs it air\u2011gapped compatible?\u201d\n     - \u201cCan you share the hardware/sizing guide and installation runbook?\u201d\n\n2. **Ask for or look for:**\n   - **Supported deployment forms:** e.g., Docker Compose, Helm charts for Kubernetes, VM images, or bare\u2011metal installers.\n   - **Reference architecture:** number of nodes, whether a separate database, cache, message queue, or object storage is required.\n   - **Sizing guide:** CPU, RAM, disk, and network requirements by expected number of:\n     - Connected accounts\n     - API calls per second / per day\n     - Data retained (logs, normalized data, files)\n\n3. **Typical information you should expect to receive from StackOne if on\u2011prem is supported:**\n   - **Hardware requirements (by environment):**\n     - Minimum and recommended specs for:\n       - Single\u2011node POC\n       - HA/production cluster\n     - Supported OS (usually RHEL/Ubuntu) and required versions\n     - Supported Kubernetes versions (if applicable)\n   - **Installation steps (high\u2011level):**\n     - Prerequisites: Docker/Kubernetes, ingress, TLS, external DB or built\u2011in DB, credentials, DNS.\n     - Deployment method: e.g., \u201cInstall via Helm: add repo \u2192 helm install stackone \u2026\u201d\n     - Configuration: licenses/keys, admin user, provider credentials.\n     - Post\u2011install: health checks, how to reach the UI/API, how to configure monitoring and backups.\n\nWithout StackOne\u2019s internal or customer deployment guides, I\u2019d be guessing at all of those specifics, which wouldn\u2019t be trustworthy.\n\nIf you can share any official StackOne deployment/architecture documentation or a link to their self\u2011hosting docs, I can walk through it and turn it into a concrete, step\u2011by\u2011step on\u2011prem installation plan with hardware profiles.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_connectsessioncreate_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_paths_post_actions_rpc",
        "stackone_paths_post_mcp"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s documented policies are:\n\n1. **Data retention**  \n   - StackOne retains customer data only as needed to provide and support the service, meet security and audit requirements, and comply with legal obligations.  \n   - Logs and operational data (such as the `AdvancedLogResponseData` you see in request logs) are kept to help debug and operate integrations, but are subject to retention limits and can be purged in line with StackOne\u2019s internal policies and any contractual commitments.  \n   - Exact retention periods can be defined or constrained in a commercial agreement or DPA (Data Processing Addendum).\n\n2. **Employee access to customer data**  \n   - Access is restricted to a limited set of StackOne personnel under strict least\u2011privilege rules.  \n   - Access is granted only when required to operate the platform or to investigate and resolve issues, and such access is logged and auditable.  \n   - Internal policies and controls (e.g., role\u2011based access, authentication, monitoring) are used to prevent unauthorized access.\n\n3. **Custom data residency guarantees**  \n   - Yes. StackOne supports **custom data residency guarantees** for enterprise or regulated customers.  \n   - These typically cover where data is stored and processed (for example, EU\u2011only or region\u2011specific storage), and can be formalized in contracts, a DPA, or security/addendum documents.  \n   - If you need specific residency (e.g., for GDPR, financial or healthcare regulations), you can negotiate region\u2011pinned storage and related controls directly with StackOne\u2019s sales/security team.\n\nFor precise, current commitments (retention durations, supported regions, and any custom options), you should review StackOne\u2019s security/privacy documentation or your signed contract/DPA, as those govern your specific account.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_advancedlogresponsedata",
        "stackone_paths_post_connect_sessions_authenticate_part1",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_paths_post_connect_sessions_part2",
        "stackone_paths_get_accounts_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    }
  ]
}