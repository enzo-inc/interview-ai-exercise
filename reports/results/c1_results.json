{
  "config": "c1",
  "timestamp": "2025-12-10T21:37:27.307562",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.9240506329113924,
      "mrr": 0.7972573839662448,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.2023809523809526,
      "abstention_accuracy": 0.2
    }
  },
  "results_by_category": {
    "factual": {
      "count": 21,
      "avg_accuracy": 3.238095238095238,
      "retrieval_hit_rate": 1.0
    },
    "endpoint": {
      "count": 21,
      "avg_accuracy": 3.4761904761904763,
      "retrieval_hit_rate": 0.9047619047619048
    },
    "auth": {
      "count": 7,
      "avg_accuracy": 3.7142857142857144,
      "retrieval_hit_rate": 0.8571428571428571
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 3.0,
      "retrieval_hit_rate": 0.0
    },
    "schema": {
      "count": 21,
      "avg_accuracy": 3.2857142857142856,
      "retrieval_hit_rate": 1.0
    },
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.0,
      "retrieval_hit_rate": 0.6666666666666666
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The documentation you provided does not state an explicit default value for the `expires_in` field when creating a connect session with `POST /connect_sessions`. It only describes:\n\n> `expires_in (number): How long the session should be valid for in seconds`\n\nSo, from the given context:\n\n- **Default value:** Not specified in the docs (no documented default).\n- **Unit:** The duration is expressed in **seconds**.",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_connectsession"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the `GET /requests/platform-logs` endpoint, the sort order is controlled **not via `filter`**, but via the dedicated **query parameters**:\n\n- `order_by` (string): the field to order the results by  \n- `order_direction` (string): the direction to order the results by  \n\nThe context you provided does **not** define a specific schema or allowed values for `order_by` or `order_direction` for platform logs (nor any `filter` properties that affect sorting). Therefore, based solely on the given documentation:\n\n- There are **no documented `filter` properties** that control sort order for `GET /requests/platform-logs`.\n- The only sorting-related controls are:\n  - `order_by`: free-form string (field name), allowed values not specified in the context.\n  - `order_direction`: free-form string (direction), allowed values not specified in the context (typically `\"asc\"` / `\"desc\"`, but this is not stated here).",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs",
        "stackone_components_platformlogspaginated",
        "stackone_components_platformlog",
        "stackone_paths_get_requests_logs_steps"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should pass the target provider account identifier in the `x-account-id` HTTP header.  \n\nIf you omit the header, you can alternatively provide the same `x-account-id` value as a query parameter in the request URL (e.g., `POST /mcp?x-account-id=...`).",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_get_accounts_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the **`GET /requests/logs`** endpoint (`stackone_list_logs`) to retrieve a paginated list of unified request logs.\n\nYou can use the following query parameters:\n\n- **Pagination / ordering**\n  - `order_by` (string): field to order by  \n  - `order_direction` (string): direction to order (e.g. `asc` / `desc`)  \n  - `page_size` (number): results per page (default 25)  \n  - `next` (string): unified cursor for the next page  \n\n- **Filtering (including HTTP method and provider)**\n  - `filter` (object): use this to filter by:\n    - `http_method` (e.g. `GET`, `POST`, etc.)\n    - `provider` (e.g. the integration/provider name)\n\n  The exact JSON structure of `filter` depends on the API\u2019s filter syntax, but conceptually it should include at least:\n  ```json\n  {\n    \"http_method\": \"GET\",\n    \"provider\": \"your-provider\"\n  }\n  ```\n\n- **Include step logs in the response**\n  - `include` (string): set this to request step logs be included, for example:\n    - `include=steps`\n  \nPutting it together, an example request might look like:\n\n```http\nGET /requests/logs?order_by=event_datetime&order_direction=desc&page_size=25&include=steps&filter={\"http_method\":\"GET\",\"provider\":\"your-provider\"}\nAuthorization: Basic <credentials>\n```",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_paths_get_requests_platform_logs",
        "stackone_components_unifiedlogs"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Call the `GET /requests/logs` endpoint (operation ID: `stackone_list_logs`) to retrieve a paginated list of request logs.\n\nAvailable query parameters:\n\n- `order_by` (string, optional): Field to sort by.  \n- `order_direction` (string, optional): Sort direction (e.g. asc/desc).  \n- `page_size` (number, optional): Page size (default 25).  \n- `next` (string, optional): Cursor for pagination.  \n- `include` (string, optional): Include additional related data.  \n- `filter` (object, optional): Use this to filter logs, e.g. by:\n  - account IDs  \n  - HTTP methods  \n  - providers  \n  - success status  \n\nThe schema for `filter` is not expanded in the excerpt, but those criteria (account IDs, HTTP methods, providers, success) should be expressed as fields inside this `filter` object according to StackOne\u2019s filtering conventions.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Use the `GET /actions` endpoint (operation ID: `stackone_list_actions_meta`) to list all actions metadata.\n\nYou can use these query parameters to filter and paginate the results:\n\n- `page_size` (string, optional): Number of results per page (default: 25)  \n- `next` (string, optional): Cursor for fetching the next page of results  \n- `group_by` (string, optional): Relation to group the results by  \n- `filter` (object, optional): Filters to apply to the actions metadata  \n- `include` (array, optional): Additional related data to include in the response",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_components_actionsmetapaginated",
        "stackone_paths_post_actions_rpc",
        "stackone_paths_get_requests_logs",
        "stackone_components_actionsrpcresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "- **Type:** `string`  \n- **Description:** \u201cThe method of the request\u201d  \n- **Allowed values:** Not restricted in the schema (no explicit enum); any HTTP method string is allowed (e.g., `GET`, `POST`, `PUT`, `DELETE`, etc.).  \n- **Default value:** None specified (no default).  \n- **Nullable:** No indication that it is nullable; it is a normal string field and not marked as nullable.",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_jsonrpcmessagedto",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_actionsrpcrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The `method` field in the `ProxyRequestBody` schema can be any standard HTTP method string (for example: `\"GET\"`, `\"POST\"`, `\"PUT\"`, `\"PATCH\"`, `\"DELETE\"`, etc.). The schema does not restrict it to a specific enum of values.\n\nIf `method` is omitted, there is **no documented default** in the provided StackOne specification. In other words, you should not rely on a default; you should explicitly set the HTTP method you intend to use.",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_jsonrpcmessagedto",
        "stackone_components_advancedlogrequestdata"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `POST /connect_sessions` (creating a connect session):\n\n**Required fields in the `ConnectSessionCreate` request body:**\n- `origin_owner_id` (string) \u2013 required  \n- `origin_owner_name` (string) \u2013 required  \n\nAll other fields (`categories`, `provider`, `provider_version`, `origin_username`, `account_id`, `expires_in`, `metadata`, `multiple`) are optional.\n\n**Allowed values for its `type` property:**\nThe `type` property is **not part of the `ConnectSessionCreate` schema**. It only appears on the `ConnectSession` response object and the specification does not list any enum/allowed values for it. Therefore:\n- You **do not** send `type` when creating a connect session.\n- The API may set `type` in the returned `ConnectSession`, but the spec does not define constrained/allowed values.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsession",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_connectsessionauthenticate"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the MCP endpoints under `/mcp`, the supported authentication and relevant headers are:\n\n**Supported authentication scheme:**\n- **HTTP Basic Authentication** (required on all `/mcp` endpoints)\n\n**Headers related to authentication and account context:**\n\n1. **`x-account-id`**  \n   - Location: header (or as a query parameter alternative)  \n   - Type: `string`  \n   - Required: **optional**  \n   - Purpose: Specifies the **account secure id** for the target provider account.  \n   - Notes:\n     - You may provide it either as a **header** (`x-account-id`) or as a **query parameter** (`?x-account-id=...`).\n     - It is used to provide account context for all `/mcp` operations (POST, GET, DELETE).\n\n2. **`mcp-session-id`**  \n   - Location: header  \n   - Type: `string`  \n   - Required:\n     - **POST /mcp**: **optional** \u2014 omit when initializing a session; include for subsequent JSON-RPC calls in an existing session.\n     - **GET /mcp**: **required** \u2014 must be included to open the SSE stream tied to that MCP session.\n     - **DELETE /mcp**: **required** \u2014 must be included to close the existing MCP session.\n   - Purpose: Identifies the **MCP session** for streaming and session lifecycle operations.\n\n3. **`Accept`** (for SSE only)  \n   - Location: header  \n   - Type: `string`  \n   - Required: **required for GET /mcp**  \n   - Value: Must be `text/event-stream`  \n   - Purpose: Indicates the client is opening a **Server-Sent Events (SSE)** stream for MCP notifications.\n\n**Summary per endpoint:**\n\n- **POST `/mcp`** (send JSON-RPC message)\n  - Auth: HTTP Basic\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (optional: omit for session init, include for subsequent calls)\n\n- **GET `/mcp`** (open SSE stream)\n  - Auth: HTTP Basic\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (**required**)\n    - `Accept` = `text/event-stream` (**required**)\n\n- **DELETE `/mcp`** (close session)\n  - Auth: HTTP Basic\n  - Headers:\n    - `x-account-id` (optional; or as query parameter)\n    - `mcp-session-id` (**required**)",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "crm_paths_get_unified_crm_accounts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The filter field is `type`, and its allowed values are defined by the `TimeOffPolicyTypeEnum` schema.",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_components_timeoffpolicytypeenum",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You can use the `filter[type]` query parameter to filter employee time off policies by their type.\n\nThree valid values for this `type` filter are:\n1. `VACATION`\n2. `SICK`\n3. `PERSONAL`",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_paths_get_unified_hris_time_off_types_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "If the `status` field is omitted when calling `PATCH /unified/hris/employees/{id}/tasks/{subResourceId}`, no new default status is applied by the API; the task\u2019s existing status remains unchanged.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_patch_unified_hris_employees_id_tasks_subresourceid",
        "hris_components_updatetaskrequestdto",
        "hris_components_taskstatusenum",
        "hris_paths_get_unified_hris_employees_id_tasks_subresourceid_part0",
        "hris_components_tasktypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use this endpoint:\n\n**Endpoint:** `GET /unified/hris/time_off_policies/{id}/time_off_policies`  \n**Operation ID:** `hris_list_employee_time_off_policies`\n\n**Required parameters:**\n1. **Path parameter**\n   - `id` (string): The identifier of the employee whose assigned time off policies you want to list.\n\n2. **Header**\n   - `x-account-id` (string): The account identifier.\n\nNo request body is required.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use this endpoint to list all employee time off requests:\n\n- **Endpoint:** `GET /unified/hris/employees/{id}/time_off/{subResourceId}`\n\nTo filter those time off requests by a specific time off policy, use the **`filter`** query parameter and include the policy ID inside that filter object (e.g., a field like `time_off_policy_id` within `filter`, depending on the provider\u2019s schema).",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "To create a new time off request for a specific employee, use this endpoint and method:\n\n**Endpoint (HRIS API):**  \n`POST /unified/hris/employees/{id}/time_off`\n\n**HTTP Method:**  \n`POST`\n\n**Required parameters:**\n\n- **Path parameter:**\n  - `id` (string, required): The employee\u2019s ID for whom you are creating the time off request.\n\n- **Header:**\n  - `x-account-id` (string, required): The account identifier.\n\n- **Request body (JSON, required):**\n  - `approver_id` (string): The approver ID.\n  - `status` (unknown): Status of the time off request.\n  - `type` (unknown): Type of the time off request.\n  - `start_date` (string): Start date/time in ISO8601 without timezone.\n  - `end_date` (string): Inclusive end date/time in ISO8601 without timezone.\n  - `start_half_day` (unknown): True if the request starts halfway through the first day.\n  - `end_half_day` (unknown): True if the request ends halfway through the last day.\n  - `time_off_policy_id` (string): The associated time off policy ID.",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_time_off_id_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Here\u2019s what a single `Employment` object (an element of an employee\u2019s `employments` array) can contain, based on the provided HRIS API context.\n\n## Top-level fields of `Employment`\n\nAn `Employment` object has the following top-level properties:\n\n1. **`id`** (`string`)  \n   - Description: Unique identifier.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n2. **`remote_id`** (`string`)  \n   - Description: Provider's unique identifier.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n3. **`unified_custom_fields`** (`object`)  \n   - Description: Custom Unified Fields configured in your StackOne project.  \n   - References other schema: **No specific named schema** given here; it\u2019s a generic `object`.  \n   - Deprecated: **No** (not indicated).\n\n4. **`job_title`** (`string`)  \n   - Description: The job title of the employee.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n5. **`pay_rate`** (`string`)  \n   - Description: The amount of compensation for the employee.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n6. **`pay_period`** (`unknown`)  \n   - Description: The time period over which the pay rate is calculated.  \n   - References other schema: **Not explicitly named in the snippet.**  \n   - Deprecated: **Not stated**.\n\n7. **`pay_frequency`** (`unknown`)  \n   - Description: How often the employee is paid.  \n   - References other schema: **Not explicitly named in the snippet.**  \n   - Deprecated: **Not stated**.\n\n8. **`pay_currency`** (`string`)  \n   - Description: The currency used for pay.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n9. **`effective_date`** (`string`)  \n   - Description: The effective date of the employment contract.  \n   - References other schema: **No**.  \n   - Deprecated: **No** (not indicated).\n\n10. **`end_date`** (`string`)  \n    - Description: The end date of employment.  \n    - References other schema: **No**.  \n    - Deprecated: **No** (not indicated).\n\n11. **`grade`** (`unknown`)  \n    - Description: Represents the employee\u2019s position within the organizational hierarchy.  \n    - References other schema: **No named enum/schema specified in the snippet.**  \n    - Deprecated: **Not stated**.\n\n12. **`employment_type`** (`unknown`)  \n    - Description: The type of employment (e.g., contractor, permanent).  \n    - References other schema: **Yes, conceptually linked to `EmploymentTypeEnum`**.  \n      - `EmploymentTypeEnum` is defined as:\n        - `value` (`string`)\n        - `source_value` (`unknown`)  \n    - This suggests that in some representations, `employment_type` may use this enum wrapper schema.  \n    - Deprecated: **Not stated**.\n\n13. **`employment_contract_type`** (`unknown`)  \n    - Description: The employment work schedule type (e.g., full-time, part-time).  \n    - References other schema: **Yes, conceptually linked to `EmploymentScheduleTypeEnum`**.  \n      - `EmploymentScheduleTypeEnum` is defined as:\n        - `value` (`string`)\n        - `source_value` (`unknown`)  \n    - Deprecated: **Not stated**.\n\n> Note: The snippet also defines `EmploymentStatusEnum` and `HrisUpdateEmploymentRequestDto`, but `EmploymentStatusEnum` is **not** listed as a property of `Employment` in the provided schema, and no fields in `Employment` are explicitly marked as deprecated in the text you\u2019ve given.\n\n## Enum-wrapper schemas referenced\n\nFrom your context:\n\n- **`EmploymentTypeEnum`** (wrapper enum schema)\n  - Used conceptually by: `employment_type`\n  - Fields:\n    - `value` (`string`)\n    - `source_value` (`unknown`)\n\n- **`EmploymentScheduleTypeEnum`** (wrapper enum schema)\n  - Used conceptually by: `employment_contract_type`\n  - Fields:\n    - `value` (`string`)\n    - `source_value` (`unknown`)\n\n- **`EmploymentStatusEnum`**\n  - Defined but **not shown as directly used** in the `Employment` schema snippet you provided.\n\n## Deprecated fields\n\n- In the provided context, **no properties of the `Employment` object are explicitly labeled as deprecated**. If any field is deprecated in the full API documentation, that information is not shown in the snippet you\u2019ve supplied.",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employmenttypeenum",
        "hris_components_employment_part0",
        "hris_components_employmentscheduletypeenum",
        "hris_components_employmentstatusenum",
        "hris_components_hrisupdateemploymentrequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `EmployeesPaginated` response schema:\n\n**Required field:**\n- `data` (array of object) \u2013 **required**  \n  - Contains the actual list of employee records for the current page.\n\n**Other properties:**\n\n- `next_page` (string)  \n  - Type: string  \n  - Purpose: Holds a token, cursor, or identifier for the next page of results. Typically used client\u2011side to request the subsequent page.\n\n- `next` (string)  \n  - Type: string  \n  - Purpose: Often a fully formed URL or path to retrieve the next page of results, built from `next_page` or equivalent pagination info.\n\n- `raw` (array of object)  \n  - Type: array of object  \n  - Purpose: Contains the raw, unprocessed objects as returned by the underlying HRIS system, useful for debugging or accessing fields not normalized into the main `data` objects.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employeespaginated",
        "hris_components_hrisjobspaginated",
        "hris_components_employmentspaginated",
        "hris_components_hrisbenefitspaginated",
        "hris_components_hrisdepartmentspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Based on the provided context, **none** of the fields in `HrisCreateEmployeeRequestDto` are defined to represent:\n\n- the employee\u2019s **gender**\n- the employee\u2019s **preferred language**\n- the employee\u2019s **ethnicity**\n\nThe only related enum schema shown is:\n\n- `GenderEnum` (with properties `value` and `source_value`)\n\nHowever, `HrisCreateEmployeeRequestDto` as given does **not** include any field (e.g., `gender`) that references `GenderEnum`, nor any fields for preferred language or ethnicity, and no enum types for language or ethnicity are defined in the context.\n\nSo:\n\n- **Gender field in `HrisCreateEmployeeRequestDto`:** Not present; no field references `GenderEnum`.\n- **Preferred language field in `HrisCreateEmployeeRequestDto`:** Not present; no enum schema provided.\n- **Ethnicity field in `HrisCreateEmployeeRequestDto`:** Not present; no enum schema provided.",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hriscreateemployeerequestdto_part0",
        "hris_components_hriscreateemploymentrequestdto_part0",
        "hris_components_hrisupdateemployeerequestdto_part0",
        "hris_components_hrisupdateemploymentrequestdto_part0",
        "hris_components_genderenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use API key authentication via an `X-API-Key` header.  \n\nRequired header:  \n- `X-API-Key: <YOUR_API_KEY>`",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_id_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_time_off_types_id_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_employees_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The GET `/unified/ats/job_postings` endpoint uses the `updated_after` query parameter to filter job postings by (last) update/creation time, and its value must be provided as a **string** (typically a timestamp in string form, e.g., an ISO 8601 datetime).",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_id_part0",
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_jobs_id_application_stages_part0",
        "ats_paths_get_unified_ats_jobs_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The ATS `GET /unified/ats/offers` endpoint uses **cursor-based** pagination in the `x-speakeasy-pagination` metadata, and the **`next`** query parameter is used as the cursor input name.",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_offerspaginated",
        "ats_paths_get_unified_ats_offers_part0",
        "ats_paths_get_unified_ats_interviews_part0",
        "ats_paths_get_unified_ats_candidates_part0",
        "ats_components_atsjobspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The supported `filter.change_type` enum values for `GET /unified/ats/applications/{id}/changes` are those defined by the `ApplicationChangeTypeEnum.value` field. These are:\n\n- `STAGE_CHANGE` \u2013 the application\u2019s stage in the hiring process changed  \n- `STATUS_CHANGE` \u2013 the application\u2019s overall status changed (e.g., open, rejected, hired)  \n- `OWNER_CHANGE` \u2013 the application\u2019s owner/assignee changed  \n- `SCORE_CHANGE` \u2013 the application\u2019s score or rating changed  \n- `SOURCE_CHANGE` \u2013 the application\u2019s candidate/source info changed  \n\nUse one of these string values with `filter.change_type` when calling the endpoint.",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_applicationchangetypeenum",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_components_applicationchanges",
        "ats_paths_get_unified_ats_applications_part0",
        "ats_components_applicationchangespaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use an HTTP **GET** request to the job postings collection endpoint, and control pagination, field selection, and filtering via query parameters.\n\n**Method**:  \n`GET`\n\n**Path** (example):  \n`/job-postings`  \n(or the equivalent list endpoint for job postings in your API, e.g. `/ats/job-postings` or `/jobs/postings`)\n\n**Key query parameters**:\n\n- **Pagination**\n  - `page` (optional, string): Page number of results to fetch.  \n    Example: `page=1`\n  - `page_size` (optional, string): Number of results per page (default 25).  \n    Example: `page_size=50`\n  - `next` (optional, string): Unified cursor for cursor-based pagination, used when continuing from a previous response\u2019s `next` value.\n\n- **Field selection**\n  - `include` (optional, string): Comma-separated list of fields to include in the response.  \n    Example: `include=id,title,status`\n\n- **Date filtering**\n  - `updated_after` (optional, string): Only select results updated after the given date. You can use this to approximate \u201ccreated after\u201d if the API doesn\u2019t expose a separate `created_after`.  \n    Example: `updated_after=2024-01-01T00:00:00Z`\n\n**Example request**:\n\n```http\nGET /job-postings?page=1&page_size=25&include=id,title,status&updated_after=2024-01-01T00:00:00Z HTTP/1.1\nHost: api.yourdomain.com\nAuthorization: Bearer <token>\n```\n\nThe response will contain:\n\n- `data`: array of job posting objects with only `id`, `title`, and `status` (plus any defaults your API always returns)  \n- `next_page` and/or `next`: values to request the subsequent page.",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part1",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "hris_paths_get_unified_hris_jobs_part1",
        "ats_paths_get_unified_ats_jobs_part1",
        "ats_paths_get_unified_ats_applications_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use this ATS API endpoint:\n\n- **Endpoint:** `GET /unified/ats/applications/{id}/notes`\n\nYou need to include the **application ID** as the `{id}` path parameter in the request URL.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part0",
        "ats_paths_get_unified_ats_candidates_id_notes_subresourceid_part0",
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part0",
        "ats_paths_get_unified_ats_applications_id_offers_part0",
        "ats_paths_get_unified_ats_applications_id_notes_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the **ATS Documents Upload** endpoint.\n\nIt requires a request body that conforms to the  \n`AtsDocumentsUploadRequestDto` schema, which includes fields like:\n\n- `name` (string): filename of the file to upload  \n- `file_format` (unknown): format of the file (e.g., pdf, docx)  \n- `content` (string): **base64\u2011encoded content** of the resume  \n- `category_id` (string): category ID of the document  \n- `path` (string): upload path  \n- `confidential` (unknown): confidentiality level  \n- `category` (unknown): category object/name (ID takes precedence over name)",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atscreateapplicationrequestdto",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_atsupdatecandidaterequestdto_part0",
        "ats_components_atsdocumentsuploadrequestdto",
        "ats_components_atscreatejobrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema has the following fields:\n\n1. **statusCode** (number, **required**)  \n   - Purpose: The HTTP status code for the error response (e.g., 400). Indicates that the request was malformed or invalid.\n\n2. **message** (string, **required**)  \n   - Purpose: A human-readable error message describing what went wrong with the request.\n\n3. **timestamp** (string, **required**)  \n   - Purpose: The time at which the error occurred, allowing clients to log or trace the error in time.\n\n4. **data** (unknown, *optional*)  \n   - Purpose: Additional error details. This can contain any structure with more specific information about why the request was bad (e.g., validation errors).\n\n5. **provider_errors** (array of object, *optional*)  \n   - Purpose: A list of provider-specific error objects, used when the ATS API is acting as a wrapper around underlying providers and wants to expose their individual error details.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "ats_components_badrequestresponse",
        "ats_components_unauthorizedresponse",
        "crm_components_badrequestresponse",
        "ats_components_badgatewayresponse",
        "ats_components_rawresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Here are the fields defined for `AtsUpdateCandidateRequestDto` and their types, based on the provided context:\n\n**Schema:** `AtsUpdateCandidateRequestDto`  \n**Type:** `object`  \n**Description:** Schema for AtsUpdateCandidateRequestDto\n\n**Properties:**\n\n1. `passthrough` \u2013 **object**  \n   - Description: Value to pass through to the provider\n\n2. `unified_custom_fields` \u2013 **object**  \n   - Description: Custom Unified Fields configured in your StackOne project\n\n3. `name` \u2013 **string**  \n   - Description: Candidate name\n\n4. `first_name` \u2013 **string**  \n   - Description: Candidate first name\n\n5. `last_name` \u2013 **string**  \n   - Description: Candidate last name\n\n6. `email` \u2013 **string**  \n   - Description: Candidate email\n\n7. `emails` \u2013 **array of object**  \n   - Description: List of candidate emails\n\n8. `social_links` \u2013 **array of object**  \n   - Description: List of candidate social links\n\n9. `phone` \u2013 **string**  \n   - Description: Candidate phone number\n\n10. `phone_numbers` \u2013 **array of object**  \n    - Description: List of candidate phone numbers including the type of the number when available\n\n11. `company` \u2013 **string**  \n    - Description: Candidate company\n\n12. `title` \u2013 **string**  \n    - Description: Candidate title\n\n13. `application_ids` \u2013 **array of string**  \n    - Description: List of candidate application IDs\n\n14. `hired_at` \u2013 **string**  \n    - Description: Candidate hired date\n\n15. `country` \u2013 **string**  \n    - Description: Candidate country\n\nFrom the provided context:\n\n- **No properties are explicitly marked as deprecated.**  \n- **No properties are explicitly marked as nullable.**\n\nIf the underlying OpenAPI/JSON schema outside this excerpt marks any of these as `nullable: true` or `deprecated: true`, that information is not present in the text you supplied.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atsupdatecandidaterequestdto_part0",
        "ats_components_atsupdatecandidatesassessmentsresultsrequestdto",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_atsupdatejobrequestdto",
        "ats_components_atscreatecandidatesassessmentsrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The `AttachmentContentType.value` field can be one of the StackOne unified content-type enum values defined for attachments (for example values like normalized MIME/content types managed by StackOne).  \n\nThe provider\u2019s original, unnormalized content type is exposed via the `AttachmentContentType.source_value` property.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "ats_components_attachmentcontenttype",
        "ats_components_atsupdatebackgroundcheckresultrequestdto",
        "lms_components_writecontenttypeenum",
        "ats_components_attachment",
        "lms_components_contenttypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id: <your_account_id>`",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_patch_unified_ats_background_checks_orders_id_result_part0",
        "ats_paths_post_unified_ats_background_checks_orders",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part0",
        "ats_paths_get_unified_ats_background_checks_packages_id_part0",
        "ats_paths_get_unified_ats_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only mandatory field in the request body is:\n\n- **`external_reference`** \u2013 it represents the external reference (identifier) associated with this assignment, used to link the assignment in this system to the corresponding record in the external provider or source system.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_get_unified_lms_assignments_id_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory field is `learning_object_external_reference`.  \n\nIt represents the external reference (main identifier) of the learning object that the assignment is being created for\u2014the learning content to which the user is being linked.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_get_unified_lms_assignments_id_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is `learning_object_external_reference`, described as *\u201cthe main identifier for creating assignments.\u201d*",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_get_unified_lms_assignments_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You should call the **`GET /unified/lms/users/{id}/assignments`** endpoint (operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment\u2011type learning records for a specific user**.\n\n**Pagination & filtering parameters you can use:**\n\n- `page` (query, optional, string): Page number of the results to fetch  \n- `page_size` (query, optional, string): Number of results per page (default 25)  \n- `updated_after` (query, optional, string): Only return assignments updated after this date  \n- `filter` (query, optional, object): LMS Assignment Filter \u2013 this is where you would include the `status` filter (e.g., `filter[status]=in_progress` depending on how filters are encoded in your client/convention)\n\nOther useful parameters:\n- `fields` (query, optional, string): Comma\u2011separated list of fields to return  \n- `next` (query, optional, string): Unified cursor for cursor\u2011based pagination  \n- `user_id` / `remote_user_id` (query, optional, string): Additional ways to identify the user if supported by your implementation  \n- `raw` (query, optional, boolean): Include raw provider response  \n- `proxy` (query, optional, object): Pass\u2011through provider parameters",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **`GET /unified/lms/users/{id}/assignments`** endpoint to retrieve a **paginated list of assignment learning records for a specific user**.\n\nTo filter those assignments by status (e.g. `completed`), use the **`filter`** query parameter (the LMS Assignment Filter), specifying the appropriate status value within that filter object.",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_assignments_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **user\u2011scoped completions list endpoint**:\n\n**Endpoint:**  \n`GET /unified/lms/users/{id}/completions`\n\nThis returns all completed learning records for the specified user.\n\n**Required parameters:**\n\n1. **Path parameter**\n   - `id` \u2013 the user\u2019s identifier\n\n2. **Header**\n   - `x-account-id` \u2013 the account identifier",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_completions_part0",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part0",
        "lms_paths_get_unified_lms_completions_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only required field in `LmsCreateCompletionRequestDto` is:\n\n- **`learning_object_external_reference` (string)** \u2013 This is the external reference of the learning object associated with the completion and is the **main identifier** used when creating the completion.\n\nTwo example optional fields you can include to capture completion details are:\n\n- **`completed_at` (string)** \u2013 The date the content was completed.  \n- **`time_spent` (string)** \u2013 An ISO 8601 duration value representing how long the user spent completing the learning object.",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_components_completionresult_part0",
        "lms_components_completion_part0",
        "lms_paths_post_unified_lms_users_id_completions_part1",
        "lms_components_completion_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In the `LmsCreateAssignmentRequestDto` request body, the only required field is:\n\n- **`learning_object_external_reference` (string, required)**\n\n**Purpose:**  \n`learning_object_external_reference` is the main identifier used to link the assignment to a specific learning object. When you create an assignment for a user, this value tells the LMS which learning object the assignment should be associated with. Without it, the system cannot know what content or course the assignment refers to.",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In `POST /unified/lms/users/{id}/assignments`, the `LmsCreateAssignmentRequestDto` has **one required field**:\n\n- **`learning_object_external_reference` (string, required)**\n\nAll other listed fields (`passthrough`, `external_reference`, `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are **optional** unless otherwise constrained by a specific integration.\n\n**Purpose of `learning_object_external_reference`:**  \nIt is the **main identifier used to create the assignment**, linking the new assignment record to an existing learning object. Instead of relying on an internal ID, this field supplies the external reference of the learning object that the assignment should be created for.",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part3",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_paths_get_unified_lms_assignments_id_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must include:\n\n1. **Authentication header**:  \n   - `Authorization: Bearer <access_token>`\n\n2. **Required header** (for identifying the customer/connection):  \n   - Typically `X-Account-Id` or `X-Customer-Id` (the exact name is defined in the OpenAPI under the global `parameters` or `components/parameters` section).\n\nIn the OpenAPI description, both are specified under:\n\n- `components.securitySchemes` (or `securitySchemes`) for the `Authorization` bearer token, and  \n- Either:\n  - `components.parameters` for the required custom header, referenced by `parameters` on the path or operation, or  \n  - Directly under each operation\u2019s `parameters` list (e.g., for `GET /unified/lms/courses` and `POST /unified/lms/users/{id}/completions`).",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part0",
        "lms_paths_post_unified_lms_users_id_completions_part0",
        "lms_paths_get_unified_lms_courses_id_part0",
        "lms_paths_get_unified_lms_users_id_completions_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `next_page` query parameter is deprecated for pagination. You should use the newer cursor-based `next` query parameter instead.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_get_unified_iam_policies_id_part0",
        "iam_components_iampoliciespaginated",
        "iam_paths_get_unified_iam_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `fields` query parameter, and include the related objects you want as a comma\u2011separated list. For example:\n\n```http\nGET /unified/iam/users?fields=roles,groups\n```\n\nThis tells the API to return the full `roles` and `groups` objects in the response instead of only their identifiers.",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_roles_id_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_groups_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the `raw` query parameter, and its default value is `false`.",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_id_part0",
        "iam_paths_get_unified_iam_policies_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the `GET /unified/iam/groups` endpoint, and you must include the `x-account-id` header (the account identifier) in the request.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_groups_id_part0",
        "iam_components_iamgroupspaginated",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_roles_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the **IAM endpoint**:\n\n**PATCH** `/unified/iam/users/{id}`\n\n### Mandatory parameters\n\n1. **Path parameter**\n   - `id` (string, required): The user\u2019s identifier whose email you want to update.\n\n2. **Header**\n   - `x-account-id` (string, required): The account identifier.\n\n3. **Authentication**\n   - HTTP Basic authentication is required.\n\n### Required request body schema (JSON)\n\nThe body must conform to `IamUpdateUserRequestDto`. At minimum, to update the primary email you need:\n\n```json\n{\n  \"primary_email_address\": \"new.email@example.com\"\n}\n```\n\nOther optional fields that can also be included in the same request:\n\n- `first_name` (string)\n- `last_name` (string)\n- `name` (string) \u2013 full name or display name\n- `username` (string)\n- `is_bot_user` (unknown) \u2013 indicates if the user is a bot/service user\n- `status` (unknown)\n- `passthrough` (object) \u2013 value to pass through to the provider",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iamupdateuserrequestdto",
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamuser",
        "iam_components_iamuserresult_part0",
        "iam_paths_get_unified_iam_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the **List Policies** endpoint:\n\n**Endpoint:** `GET /unified/iam/policies`  \n**Operation ID:** `iam_list_policies`\n\nTo control pagination and filtering, you can use these query parameters:\n\n**Pagination:**\n- `page` (string, optional): The page number of the results to fetch.\n- `page_size` (string, optional): The number of results per page (default is 25).\n- `next` (string, optional): The unified cursor for cursor-based pagination.\n- The response body also includes:\n  - `next_page` (string): Next page number (if available).\n  - `next` (string): Next cursor (if available).\n\n**Filtering and field selection:**\n- `filter` (object, optional): Filter parameters for more customized list results.\n- `fields` (string, optional): Comma-separated list of fields to return (if empty, all fields are returned).\n- `proxy` (object, optional): Used to pass through provider-specific query parameters under the `proxy` key.\n- `raw` (boolean, optional): If `true`, returns the raw provider result in addition to the mapped result (default is `false`).",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_components_iampoliciespaginated",
        "iam_paths_get_unified_iam_policies_id_part0",
        "iam_paths_get_unified_iam_policies_part1",
        "iam_paths_get_unified_iam_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, when you delete a user and a response body is returned, it uses the `DeleteResult` schema, which contains:\n\n- `statusCode` (number) \u2013 **required**\n- `message` (string) \u2013 **required**\n- `timestamp` (string) \u2013 **required**",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "hris_components_deleteresult",
        "lms_components_deleteresult",
        "ats_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, when a user is successfully deleted via `DELETE /unified/iam/users/{id}`, the response is a `DeleteResult` object with the following properties:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id",
        "hris_components_deleteresult",
        "lms_components_deleteresult",
        "ats_components_deleteresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "For `IamPermissionTypeEnum` in the IAM API:\n\n- The `value` field holds the **normalized permission type**, with examples such as:\n  - `read`\n  - `read_write`\n  - `delete`\n  - (and similar permission-type strings following that pattern)\n\n- The `source_value` field holds the **raw, underlying value from the provider** (the unmodified provider-specific string or representation that was mapped into the normalized `value`). This lets you see exactly what the upstream system sent, even if it differs in naming or format from the unified `value`.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iampermissiontypeenum",
        "iam_components_iamresourcetypeenum",
        "iam_components_iammfatypeenum",
        "iam_components_iampermission",
        "iam_components_roletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints use **HTTP Basic authentication**, and you must include the **`x-account-id` header** with the account identifier for the request to be authorized.",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_id_part0",
        "iam_paths_get_unified_iam_roles_id_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_groups_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the explicitly configured HTTP status codes that trigger the `x-speakeasy-retries` backoff strategy are:\n\n- **408** (Request Timeout)  \n- **429** (Too Many Requests)  \n- **5XX** (all 5xx server error status codes)",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "ats_paths_get_unified_ats_rejected_reasons_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and its data format is a **string containing a date** (e.g., `\"2024-01-01\"`).",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies that the `backoff` retry strategy applies to these HTTP status codes:\n\n- **408**  \n- **429**  \n- **5XX** (all 5xx server error codes)",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint:** `GET /unified/crm/contacts`\n\nThe relevant query parameters are:\n\n- **Update filter:**  \n  - `updated_after` \u2014 supply a date/time string to only return contacts updated after that timestamp.\n\n- **Cursor-based pagination:**  \n  - `next` \u2014 the unified cursor returned from the previous response; pass it to get the next page of results.  \n  - (Optionally, `page_size` controls how many results per page; default is 25.)",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_accounts_part1",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the endpoint:\n\n- `PATCH /accounts/{id}` (Operation ID: `crm_get_account`)\n\nand include the following required header containing the account identifier:\n\n- `x-account-id: {ACCOUNT_ID}`",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_accounts_id",
        "stackone_paths_get_accounts_part0",
        "stackone_paths_patch_accounts_id_part0",
        "crm_paths_get_unified_crm_accounts_id_part1",
        "stackone_paths_get_accounts_id_meta"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the **`GET /unified/crm/custom_field_definitions/contacts`** endpoint to retrieve all custom field definitions for contacts.\n\nThe query parameter that enables cursor-based pagination is **`next`**.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part2",
        "crm_paths_get_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "In the `Create Contact` endpoint (`POST /unified/crm/contacts`), the request body uses the `CrmCreateContactRequestDto` schema. You can include the following fields:\n\n- `first_name` (string): The contact\u2019s first name  \n- `last_name` (string): The contact\u2019s last name  \n- `company_name` (string): The contact\u2019s company name  \n- `emails` (array of string): List of the contact\u2019s email addresses  \n- `phone_numbers` (array of string): List of the contact\u2019s phone numbers  \n- `deal_ids` (array of string): List of associated deal IDs  \n- `account_ids` (array of string): List of associated account IDs  \n- `custom_fields` (array of object): Any custom fields for the contact  \n- `passthrough` (object): Arbitrary data that will be forwarded as\u2011is to the underlying CRM provider but is not interpreted by the unified API itself.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "hris_components_hrisinviteemployeerequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_atscreatenotesrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "A successful `200` response from `GET /unified/crm/contacts` returns a `ContactsPaginated` object with the following structure:\n\n```json\n{\n  \"next_page\": \"string or null\",\n  \"next\": \"string or null\",\n  \"data\": [\n    { /* contact object */ },\n    { /* contact object */ }\n  ],\n  \"raw\": [\n    { /* raw provider response object(s) */ }\n  ]\n}\n```\n\nField details:\n\n- **data** (array of object, required):  \n  The list of mapped contact objects in the unified CRM schema.\n\n- **next_page** (string):  \n  A pagination token or page indicator for the *next page number* of results (implementation-specific). If present, you can use it with the `page` query parameter to fetch the next page.\n\n- **next** (string):  \n  A unified cursor for pagination. If present, you can pass it back via the `next` query parameter to retrieve the next set of contacts.\n\n- **raw** (array of object):  \n  Contains the raw provider-level data returned from the underlying CRM system(s), included when `raw=true` is specified in the request. Each entry corresponds to the original un-mapped response objects or segments from the provider.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the CRM API, when using `CrmCreateContactRequestDto` to create or update a contact:\n\n**1. `custom_fields`**\n\n- **Type:** `array of object`\n- **Structure in the request body:**  \n  ```json\n  \"custom_fields\": [\n    { /* custom field object 1 */ },\n    { /* custom field object 2 */ }\n  ]\n  ```\n- Each element is an **object**. The specific keys and value types inside each object are not further constrained by this schema, so they are provider-/project-specific. At the schema level, they are simply arbitrary JSON objects in an array.\n\n**2. `passthrough`**\n\n- **Type:** `object`\n- **Structure in the request body:**  \n  ```json\n  \"passthrough\": {\n    /* arbitrary key-value pairs */\n  }\n  ```\n- It is a single JSON object meant to carry any extra data you want to pass directly through to the provider. The schema places no restriction on the internal keys or value types beyond being valid JSON.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "hris_components_hrisinviteemployeerequestdto",
        "crm_components_contact_part0",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_atsupdateapplicationrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id` (string): the account identifier.",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "crm_paths_get_unified_crm_accounts_id_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0",
        "crm_paths_post_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Described purpose:** It is **\"The account identifier\"** and must be included on every request to identify the account.",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_content_blocks_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The `x-speakeasy-pagination` configuration treats the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_email_part1",
        "marketing_paths_get_unified_marketing_campaigns_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and it is specified to be a **string containing a date** (i.e., \u201cUse a string with a date to only select results updated after that given date\u201d).",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_campaigns_part1",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_components_campaign"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use this endpoint:\n\n**Endpoint**\n- `PATCH /unified/marketing/templates/push/{id}`  \n- Operation ID: `marketing_update_push_template`\n\n**Authentication**\n- HTTP Basic\n\n**Required parameters**\n- `x-account-id` (in header, string): The account identifier  \n- `id` (in path, string): The ID of the push template you want to update\n\n**Request body (JSON, required)**  \nObject with the following fields:\n\n```json\n{\n  \"name\": \"string\",\n  \"tags\": [\"string\"],\n  \"messages\": [ { /* object */ } ],\n  \"passthrough\": { /* object passed through to provider */ }\n}\n```\n\nAll four keys must be present in the JSON body; types are:\n- `name`: string  \n- `tags`: array of strings  \n- `messages`: array of objects  \n- `passthrough`: object (arbitrary key/value to pass through to the provider)",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_components_pushtemplate",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_components_pushtemplateresult",
        "marketing_paths_patch_unified_marketing_templates_sms_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **`PATCH /unified/marketing/templates/push/{id}`** endpoint.\n\n- **HTTP method:** `PATCH`  \n- **Required header parameter:**  \n  - `x-account-id` (string) \u2013 The account identifier  \n- **Required path parameter:**  \n  - `id` (string) \u2013 The identifier of the push template to update",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_paths_get_unified_marketing_templates_push_id_part0",
        "marketing_paths_patch_unified_marketing_templates_sms_id",
        "marketing_paths_patch_unified_marketing_templates_email_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to retrieve a paginated list of SMS templates.\n\nYou must include the following required header to identify the account:\n- `x-account-id: <your_account_id>`",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_id_part0",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_paths_post_unified_marketing_templates_sms",
        "marketing_paths_patch_unified_marketing_templates_sms_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You can include the following fields in the request body for `MarketingCreateContentBlocksRequestDto`:\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (enum/unknown): a Stackone enum that identifies the type of content block (e.g., to distinguish between different kinds of blocks such as text, HTML, layout, etc., depending on the provider\u2019s supported types).\n- `passthrough` (object): an arbitrary object whose value is passed directly through to the underlying provider without modification, allowing you to send provider-specific or custom configuration data that isn\u2019t part of the standard schema.",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_components_marketingcreatetemplaterequestdto",
        "marketing_components_marketingcreateinapptemplaterequestdto",
        "marketing_components_marketingcreateemailtemplaterequestdto",
        "marketing_components_marketingcreatepushtemplaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `POST /unified/marketing/content_blocks`, the JSON request body can include the following fields (as per `MarketingCreateContentBlocksRequestDto`):\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (unknown enum) \u2013 Stackone enum identifying the type of content block\n- `passthrough` (object) \u2013 arbitrary data to pass through to the provider\n\nRegarding the allowed value set for the `type` field:\n\n- The docs only state that `type` is a \u201cStackone enum identifying the type of content block\u201d and do **not** list the actual enum values.\n- Therefore, from the given context we can only say that `type` must be one of a predefined Stackone enum values for content block types, but the specific allowed values are **not provided** in the supplied documentation.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_paths_patch_unified_marketing_content_blocks_id",
        "marketing_paths_get_unified_marketing_content_blocks_part0",
        "marketing_components_contentblock"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "In the `PushTemplatesPaginated` response, the **only required field** is:\n\n- **`data`** (required)\n\n**Structure of `data`:**\n- Type: **array**\n- Items: **object**\n- Schema reference for each item: **`PushTemplate`**\n\nSo `data` is an array of `PushTemplate` objects.",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_pushtemplatespaginated",
        "marketing_components_pushtemplate",
        "marketing_paths_get_unified_marketing_templates_push_part0",
        "marketing_components_pushtemplateresult",
        "marketing_components_marketingcreatepushtemplaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You must use **HTTP Basic authentication**, and you must include the **`x-account-id`** header (required) to specify the account context.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **List applications\u2019 scheduled interviews**  \n   - Parameter: `filter.updated_after`  \n   - Type: string  \n   - Format: date string (`\"Use a string with a date to only select results updated after that given date\"`)\n\n2. **List application custom field definitions**  \n   - Parameter: `filter.updated_after`  \n   - Type: string  \n   - Format: date string\n\n3. **List application document categories**  \n   - Parameter: `filter.updated_after`  \n   - Type: string  \n   - Format: date string\n\n4. **List background check packages**  \n   - Parameter: `filter.updated_after`  \n   - Type: string  \n   - Format: date string\n\n5. **List omni-channel templates**  \n   - Parameter: `filter.updated_after`  \n   - Type: string  \n   - Format: date string\n\nIn all sampled APIs, `filter.updated_after` is a **query parameter of type string**, expected to contain a **date-formatted string** used to return only resources updated after the specified date.",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part2",
        "ats_paths_get_unified_ats_custom_field_definitions_applications_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1",
        "ats_paths_get_unified_ats_background_checks_packages_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "For both APIs, pagination is handled in almost the same way, with small differences in the available query params.\n\n**1. Pagination query parameters**\n\n- **IAM API (listing users)**\n  - `page` (query, optional, string): Page number to fetch.\n  - `page_size` (query, optional, string): Number of results per page (default 25).\n  - `next` (query, optional, string): Unified cursor for cursor-based pagination.\n  - `updated_after` (query, optional, string): Filter by last update time (not strictly pagination but can affect pages).\n\n- **CRM API (listing contacts via `GET /unified/crm/contacts`)**\n  - `page` (query, optional, string): Page number to fetch.\n  - `page_size` (query, optional, string): Number of results per page (default 25).\n  - `next` (query, optional, string): Unified cursor for cursor-based pagination.\n  - Additional query params unrelated to basic pagination but that affect the result set:\n    - `fields`, `filter`, `raw`, `proxy`, `updated_after`, `include` (from the paginated schema description).\n\nSo, in both IAM and CRM, **`page` and `page_size` control page-based pagination**, and **`next` controls cursor-based pagination**.\n\n**2. Cursor-based pagination in the response**\n\n- **IAM API response schema: `IamUsersPaginated`**\n  - `next_page` (string): A value indicating the next page (typically for page-based navigation).\n  - `next` (string): The unified cursor value to request the next \"cursor page\".\n  - `data` (array of object, required): Current page of users.\n  - `raw` (array of object): Raw provider data, if requested.\n\n- **CRM API response schema: `ContactsPaginated`**\n  - `next_page` (string): A value indicating the next page (page-based).\n  - `next` (string): The unified cursor value for cursor-based pagination.\n  - `data` (array of object, required): Current page of contacts.\n  - `raw` (array of object): Raw provider data, if requested.\n\n**Summary**\n\n- Both IAM and CRM use the **same pattern**:\n  - Request: `page`, `page_size` for page-based; `next` for cursor-based.\n  - Response: `next_page` for page-based; `next` as the cursor for cursor-based pagination.\n- The main difference is domain and some extra non-pagination query parameters (e.g., `fields`, `filter`, `include` in CRM), but pagination mechanics are aligned.",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "iam_components_iamuserspaginated",
        "crm_paths_get_unified_crm_accounts_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "For HRIS employee documents:\n\n1. **HRIS document download \u2013 response media type & schema**\n\n- **Endpoint:** `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`  \n- **Response media type:** It returns *file* content (binary) plus headers. In the spec this is modeled as an object, not as JSON metadata plus file; effectively it\u2019s a binary download with associated headers.  \n- **Response schema:** `DownloadApiModel`  \n  - `headers` (unknown, required): headers related to the download (e.g., content-type, filename, etc.)  \n  - `data` (string, required): the file data in **binary format**  \n\nSo, for your monitoring tool, the HRIS download side exposes:\n- Binary file body via `data`\n- Download-related headers via `headers`, modeled in `DownloadApiModel`.\n\n2. **IAM file metadata schema with `remote_url` and `file_format`**\n\nFrom the sampled specs, the schema that exposes fields like `remote_url` and `file_format` is:\n\n- **Schema:** `HrisDocumentResult` (used by `hris_get_employee_document`)  \n  - `data` object contains:\n    - `id` (string): internal unified ID\n    - `remote_id` (string): provider\u2019s unique identifier\n    - `name` (string): file name\n    - `remote_url` (string): URL where the file content is located\n    - `file_format` (unknown): file format of the file\n    - `category`, `category_id`, `created_at`, `updated_at`, `type`, `unified_custom_fields`, etc.\n\nAlthough the question mentions \u201cIAM\u201d file metadata, in the provided sample this metadata is actually coming from the HRIS side via `HrisDocumentResult`. This is the schema you would use to get `remote_url` and `file_format` to correlate with downloads.\n\n3. **How to combine these for auditing**\n\nA monitoring/audit tool could:\n\n1. **Call the metadata API**  \n   - Use `GET /unified/hris/employees/{id}/documents/{subResourceId}` (operation `hris_get_employee_document`) to retrieve an `HrisDocumentResult`.  \n   - Extract:\n     - `data.id` (unified document ID)\n     - `data.remote_id` (provider\u2019s ID)\n     - `data.name`\n     - `data.remote_url`\n     - `data.file_format`\n     - `data.category_id`, `data.category`, `data.type`, timestamps\n\n2. **Call the download API**  \n   - Use `GET /unified/hris/employees/{id}/documents/{subResourceId}/download` (operation `hris_download_employee_document`) to retrieve a `DownloadApiModel`.  \n   - Log:\n     - `headers` (e.g., content-type, content-length, content-disposition)\n     - `data` size and checksum (you typically wouldn\u2019t store full binary in the audit log, but you could hash it)\n\n3. **Correlate the two**  \n   - Correlate using the shared path parameters `id` (employee) and `subResourceId` (document) and/or `data.id` / `data.remote_id`.  \n   - For each download event, your audit record might include:\n     - Employee ID (`id`)\n     - Document ID (`subResourceId`, plus `HrisDocumentResult.data.id` / `remote_id`)\n     - Document name (`name`)\n     - File metadata (`remote_url`, `file_format`, `category_id`, `type`)\n     - Download-specific info (timestamp, requester identity, response headers like content-type, length, and maybe a hash of `DownloadApiModel.data`)\n\nBy doing this, the **download stream** (`DownloadApiModel`) and the **file metadata** (`HrisDocumentResult`) are tied together into a single audit entry that proves *what* file was downloaded, *how* it was represented (format, URL, type), and *when/how* it was served (headers, size).",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_download",
        "hris_components_hrisdocumentsuploadrequestdto",
        "hris_components_downloadapimodel",
        "hris_components_hrisdocumentresult",
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "From the context provided:\n\n**Unified APIs that require the `x-account-id` header:**\n- **HRIS**  \n  - Endpoint shown: `GET /unified/hris/employees`  \n  - Explicitly requires header: `x-account-id` (string, required)\n\nBy design in StackOne, the other unified APIs you listed (ATS, LMS, IAM, CRM, MARKETING) follow the same pattern as HRIS:  \n**they are unified APIs and require the same `x-account-id` header for authenticated requests**, in addition to HTTP Basic auth.  \n(They are not shown explicitly in the snippet, but they follow the same unified pattern as `/unified/hris/...`.)\n\n**StackOne endpoints that use only HTTP Basic (no `x-account-id` header):**\n- **Connect Sessions**\n  - `POST /connect_sessions/authenticate`  \n    - Authentication: HTTP Basic  \n    - No `x-account-id` header parameter\n- **MCP**\n  - `GET /mcp`  \n    - Authentication: HTTP Basic  \n    - `x-account-id` is *optional* (can be header or query); the core auth is HTTP Basic\n- **Proxy**\n  - `POST /unified/proxy`  \n    - Authentication: HTTP Basic  \n    - Does require `x-account-id` header, but this is not a unified HRIS/ATS/LMS/IAM/CRM/MARKETING resource; it is a generic proxy endpoint.\n\nSo, in summary:\n\n- **Unified domain APIs (HRIS, ATS, LMS, IAM, CRM, MARKETING):** use HTTP Basic **plus** a required `x-account-id` header.\n- **Infrastructure/utility endpoints like `POST /connect_sessions/authenticate` (Connect Sessions) and `GET /mcp`:** rely on HTTP Basic, and do **not** require `x-account-id` in the same way (MCP\u2019s `x-account-id` is optional).",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "lms_paths_put_unified_lms_content_part1",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_get_mcp",
        "hris_paths_get_unified_hris_employees_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "All three endpoints implement **cursor-based pagination** in a very similar way, with largely shared parameters and response fields.\n\nShared pagination query parameters:\n- `page` (query, optional, string): Page number of the results to fetch\n- `page_size` (query, optional, string): Number of results per page (default 25)\n- `next` (query, optional, string): The unified **cursor** used for cursor-based pagination\n- `updated_after` (query, optional, string): Filter to only return records updated after a given date (when present)\n\nShared pagination response fields:\n- `next` (string): The cursor to fetch the next \"page\" of results\n- `next_page` (string): A page-based indicator for the next page (often derived/legacy, but still present)\n- `data` (array): The actual list of returned records\n- `raw` (array): Raw provider data, if `raw=true` was requested\n\nEndpoint-specific notes:\n\n1. **HRIS \u2013 GET /unified/hris/jobs (hris_list_jobs)**\n   - Uses: `page`, `page_size`, `next`, `updated_after` in the query.\n   - Response: `next`, `next_page`, `data`, `raw`.\n   - Filter parameter is described generically as \u201cFilter parameters that allow greater customisation of the list response\u201d.\n\n2. **ATS \u2013 GET /unified/ats/jobs (ats_list_jobs)**\n   - Uses: `page`, `page_size`, `next`, `updated_after` in the query.\n   - Response (by convention in this API family): `next`, `next_page`, `data`, `raw`.\n   - Filter parameter is specifically \u201cATS Jobs filters\u201d.\n\n3. **ATS \u2013 GET /unified/ats/job_postings (ats_list_job_postings)**\n   - Uses: `page`, `page_size`, `next` in the query; `updated_after` is mentioned but truncated in the text, implying the same `updated_after` usage.\n   - Response: Same structure (`next`, `next_page`, `data`, `raw`).\n\n4. **ATS \u2013 GET /unified/ats/candidates (ats_list_candidates)**\n   - Uses: `page`, `page_size`, `next`; `updated_after` again appears but is truncated, implying the same.\n   - Response: Same structure (`next`, `next_page`, `data`, `raw`).\n\n(You also mentioned a CRM list contacts endpoint, but its specific definition isn\u2019t included in the provided context. In this API family, the CRM list contacts endpoint typically follows the same pattern: query params `page`, `page_size`, `next`, `updated_after` and response fields `next`, `next_page`, `data`, `raw`.)\n\nDifferences in pagination-related parameters:\n- **Naming and behavior of filters differ**, but not the pagination itself:\n  - HRIS: generic `filter` (\u201cFilter parameters that allow greater customisation\u2026\u201d).\n  - ATS Jobs: `filter` (\u201cATS Jobs filters\u201d).\n  - ATS Job Postings: `filter` (\u201cATS Job Postings Filter\u201d).\n  - ATS Candidates: `filter` (\u201cATS Candidate Filter\u201d).\n- **Otherwise, pagination is consistent**:\n  - Same `page` / `page_size` semantics.\n  - Same cursor parameter name: `next`.\n  - Same response fields: `next` and typically `next_page`.\n  - Same optional `updated_after` where documented.\n\nIn summary, the HRIS list jobs, ATS list jobs, and (by extension) CRM list contacts all share the same pagination model and parameter names; the only real differences are in how their `filter` parameter is described and which resource they operate on.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part0",
        "hris_paths_get_unified_hris_jobs_part0",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_candidates_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "You\u2019d combine:\n\n1. **StackOne \u201cmeta / connect\u201d endpoint** (STACKONE API)  \n   - **Purpose in your feature:** Get high\u2011level metadata about the business customer\u2019s linked account and connector configuration.  \n   - **Relevant schema:**  \n     - `LinkedAccountMeta` \u2013 for a given linked account, this exposes:\n       - `provider`\n       - `category`\n       - `models`\n       - (and other connector/account\u2011level info)  \n     - Potentially `ConnectSessionTokenAuthLink` \u2013 if you\u2019re surfacing how/when the account was connected, by whom, and with what metadata:\n       - `id`, `organization_id`, `project_id`\n       - `categories`, `provider`\n       - `origin_owner_id`, `origin_owner_name`, `origin_username`\n       - `account_id`, `label`\n       - `created_at`\n       - `metadata` (custom tagging such as plan, tenant ID, etc.)\n       - `external_trigger_token`, `type`, `integration_id`, etc.\n\n2. **LMS \u201clist users\u201d endpoint** (LMS API)  \n   - **Purpose in your feature:** For that same `account_id`, retrieve all LMS users and filter them by email or external_reference.  \n   - **Relevant schema for items:**  \n     - `LmsUser`:\n       - `id`, `remote_id`\n       - `unified_custom_fields`\n       - `external_reference`\n       - `name`, `email`, `phone_number`\n       - `active`\n       - `created_at`, `updated_at`  \n   - **Relevant schema for single\u2011item responses:**  \n     - `UserResult`:\n       - `data`: a single `LmsUser` object\n       - `raw`: array of provider\u2011native user objects\n\n### How filtering differs\n\n- **StackOne meta / connect endpoints (LinkedAccountMeta, ConnectSessionTokenAuthLink):**\n  - Typically filtered or looked up by:\n    - `account_id`\n    - `provider`\n    - `category`\n    - or connect\u2011session / organization identifiers (`origin_owner_id`, `project_id`, etc.).\n  - **They do not filter on LMS user fields** like `email` or `external_reference`.  \n  - Used to identify *which* linked account and connector configuration belongs to the business customer.\n\n- **LMS list users endpoint:**\n  - Filter parameters are **user\u2011centric**:\n    - Can filter by `email` and/or `external_reference` (and usually by `account_id` in the path or query, plus pagination params).\n  - The endpoint returns a list of `LmsUser` objects (or `UserResult` wrappers, depending on the exact path), each representing an LMS user in that linked account.\n\n### How response structures differ\n\n- **StackOne meta / connect responses (high\u2011level account/connector view):**\n  - Object\u2011level configuration and linkage:\n    - `LinkedAccountMeta`: `{ provider, category, models, ... }`\n    - `ConnectSessionTokenAuthLink`: a single object with connection and metadata fields.\n  - Focus is on:\n    - Which provider & category\n    - How the integration is configured for that business\n    - Any tagging/metadata used at the account level\n  - No list of users; each object represents a *connection* or *linked account*, not an LMS entity.\n\n- **LMS list users responses (user\u2011level view):**\n  - A **collection** of LMS users for that account:\n    - Either an array of `LmsUser`\n    - Or an array of `UserResult` objects where each item has:\n      - `data`: the unified LMS user fields\n      - `raw`: provider\u2011native user payload(s)\n  - Focus is on:\n    - Per\u2011user identifiers (`id`, `remote_id`, `external_reference`)\n    - Contact info (`email`, `phone_number`)\n    - Status (`active`)\n    - Timestamps\n\n### Putting it together in your audit feature\n\n1. **Identify account + configuration (StackOne API):**\n   - Call the StackOne meta/connect endpoint using your business customer\u2019s identifiers to get:\n     - `LinkedAccountMeta` (provider, category, models)\n     - Optionally `ConnectSessionTokenAuthLink` (who connected, when, metadata, etc.)\n   - This populates the \u201cAccount & Connector Configuration\u201d section of your audit view.\n\n2. **Fetch and filter LMS users (LMS API):**\n   - Using the same `account_id` (and provider/category as needed), call the LMS **list users** endpoint.\n   - Pass filter parameters for:\n     - `email`\n     - `external_reference`\n   - Display the returned `LmsUser` (or `UserResult.data`) records as the \u201cUsers for this account\u201d section, optionally exposing `raw` for deep audits.\n\nIn summary:  \n- **StackOne endpoints + `LinkedAccountMeta` / `ConnectSessionTokenAuthLink`** \u2192 account\u2011level, connector\u2011level metadata; filtering by account/provider/category.  \n- **LMS list users endpoint + `LmsUser` / `UserResult`** \u2192 user\u2011level data, filtered by `email` / `external_reference` for that same account.",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_put_unified_lms_content_part1",
        "lms_components_lmsuser",
        "stackone_components_linkedaccountmeta",
        "stackone_components_connectsessiontokenauthlink",
        "lms_components_userresult"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following StackOne unified APIs support cursor-based pagination using a `next` query parameter, and they all return the cursor in a response field also named `next`:\n\n1. **Actions RPC API (ActionsRpcResponse)**\n   - **Request pagination parameter:** `next` (query)\n   - **Response cursor field:** `next` (string) \u2014 cursor for fetching the next page of results\n\n2. **Actions Metadata API (ActionsMetaPaginated)**\n   - **Request pagination parameter:** `next` (query)\n   - **Response cursor field:** `next` (string) \u2014 cursor for fetching the next page of results\n\n3. **Unified Logs API (UnifiedLogsPaginated)**\n   - **Request pagination parameter:** `next` (query, optional, string) \u2014 the unified cursor\n   - **Response cursor field:** `next` (string)\n\n4. **Step Logs API (StepLogsPaginated)**\n   - **Request pagination parameter:** `next` (query, optional, string) \u2014 the unified cursor\n   - **Response cursor field:** `next` (string)",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_actionsrpcresponse",
        "stackone_components_actionsmetapaginated",
        "stackone_components_unifiedlogspaginated",
        "stackone_components_steplogspaginated",
        "ats_paths_get_unified_ats_applications_id_changes_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "Here\u2019s the comparison, parameter by parameter:\n\n### HRIS \u2013 Jobs list endpoint  \n**Endpoint:** `GET /unified/hris/jobs`\n\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Description: Comma\u2011separated list of fields to return. If empty, all fields are returned.\n\n- **Filter by `updated_after`:**  \n  - Based on the provided context, there is **no explicit `updated_after` query parameter** documented for the Jobs list endpoint.  \n  - The only filtering hook shown is:\n    - `filter` (query, optional, object): generic filter parameters.\n\n### CRM \u2013 Accounts list endpoint  \n(From the question\u2019s reference to \u201cCRM Accounts API\u201d; details are inferred to parallel HRIS style.)\n\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Same pattern: comma\u2011separated list of fields to return; if omitted/empty, all fields are returned.\n\n- **Filter by `updated_after`:**  \n  - Parameter: `updated_after` (query, optional, string)  \n  - Used explicitly to restrict results to records updated after the given timestamp.\n\n### Summary\n\n- **HRIS Jobs API**\n  - Field selection: `fields`\n  - Updated-after filtering: not explicitly supported via a dedicated `updated_after` parameter (would have to be done, if at all, via the generic `filter` object).\n\n- **CRM Accounts API**\n  - Field selection: `fields`\n  - Updated-after filtering: `updated_after` (dedicated query parameter).",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "hris_paths_get_unified_hris_employees_part0",
        "hris_paths_get_unified_hris_employments_part0",
        "hris_paths_get_unified_hris_custom_field_definitions_employees_part0",
        "hris_paths_get_unified_hris_shifts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "- **Authentication mechanism for both endpoints:**  \n  - **HTTP Basic** authentication is required.\n\n- **Required header for both endpoints:**  \n  - **`x-account-id`** (string): identifies the account under which the request is made.\n\n- **Common query parameters your client can reuse across both APIs:**\n\n  1. **`raw`** (boolean) \u2013 Controls raw responses  \n     - Purpose: When `true`, returns the raw provider result in addition to the unified/mapped result.\n\n  2. **`proxy`** (object) \u2013 Provider passthrough  \n     - Purpose: Allows you to pass through arbitrary query parameters directly to the underlying provider by nesting them under the `proxy` key.\n\n  3. **`fields`** (string) \u2013 Field selection  \n     - Purpose: Comma\u2011separated list of fields to include in the response; if omitted/empty, all fields are returned.\n\n  4. **`filter`** (object) \u2013 Filtering  \n     - Purpose: Allows custom filter parameters to refine the list results (e.g., by status, date ranges, etc., depending on provider support).\n\n  5. **`page`** (string) \u2013 Pagination: page index  \n     - Purpose: Selects which page of results to fetch.\n\n  6. **`page_size`** (string) \u2013 Pagination: page size  \n     - Purpose: Controls how many results are returned per page.\n\n- **Incremental sync parameter (only on ATS `List Offers`):**\n\n  7. **`next`** (string) \u2013 Incremental sync / cursor  \n     - Purpose: A unified pagination cursor used to fetch the next \u201cpage\u201d for incremental sync. This is **only present on the ATS `List Offers` endpoint**, not on MARKETING `List Email Templates`.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "ats_paths_get_unified_ats_offers_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don\u2019t have any pricing information in the provided context, and the StackOne API reference you shared doesn\u2019t describe commercial terms such as pricing tiers, overage fees, or volume discounts.\n\nPublic documentation I\u2019ve seen for tools like this often omits specific pricing, which is instead:\n\n- Listed on a separate pricing page on the vendor\u2019s website, or  \n- Provided via sales on a quote-based / contract basis (especially for high-volume API usage).\n\nTo get accurate and current details on:\n\n- Available pricing tiers (e.g., free, starter, business, enterprise)  \n- Rate limits and what happens beyond them  \n- Overage charges (per-1,000 calls, per-seat, etc.)  \n- Volume discounts for large API volumes or annual commitments  \n\nyou\u2019ll need to:\n\n1. Check StackOne\u2019s official pricing page (typically something like `https://stackone.com/pricing` or similar).\n2. If that\u2019s not detailed enough, contact StackOne sales/support directly and ask specifically about:\n   - Your expected monthly API call volume,\n   - Whether they offer tiered or custom pricing past certain thresholds,\n   - Any overage fee structure (per-call cost after included quota),\n   - Discounts for annual prepayment or committed usage.\n\nIf you share any pricing table or terms you have (e.g., from a screenshot, PDF, or webpage), I can help interpret it and calculate effective per-call costs, overage scenarios, or when a higher tier becomes more economical.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_get_accounts_part0",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_get_requests_logs",
        "crm_paths_get_unified_crm_accounts_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** publicly publish a detailed, financially backed SLA (with specific uptime percentage and compensation/credit terms) in the material you\u2019ve provided, and I do not have access to any non\u2011public contractual documents between StackOne and its customers.\n\nFrom the available context and my general knowledge cutoff (Oct 2024):\n\n- I cannot confirm that StackOne offers a **financially backed SLA** (e.g., 99.9% uptime with service credits) as a standard, publicly documented term.\n- I also cannot state specific **uptime guarantees** (such as 99.9% or 99.95%) or **compensation terms** (e.g., percentage service credits by downtime tier), because those details are not present in the given schemas and are not part of any public specification I\u2019ve seen.\n\nTo get an authoritative answer, you would need to:\n\n1. Check StackOne\u2019s official **Terms of Service / SLA** page or customer agreement (often linked from their website\u2019s legal or documentation section).\n2. If you are an enterprise customer or in a sales/security review, request their **formal SLA document** from your StackOne account representative or support, as these terms are often:\n   - Included in a Master Services Agreement (MSA) or Order Form, and  \n   - May vary by pricing tier or contract.\n\nUnless and until you see a contractual SLA that explicitly mentions:\n- \u201cfinancially backed SLA,\u201d\n- a specific **uptime percentage** (e.g., 99.9% per calendar month), and\n- defined **service credits or other compensation** for falling below that uptime,\n\nyou should assume there is **no guaranteed, financially backed SLA**.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_accounts_id_part2",
        "stackone_components_preconditionfailedresponse",
        "stackone_components_badrequestresponse",
        "ats_paths_get_unified_ats_offers_id_part2",
        "stackone_components_internalservererrorresponse"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "You can\u2019t directly customize the StackOne *hosted* web dashboard UI (e.g., adding your own widgets, themes, or per\u2011role layouts) in the way you might with a low\u2011code dashboard builder. StackOne is primarily an API platform, and the \u201cdashboard\u201d it provides is mostly for configuration, monitoring, and administration.\n\nTo achieve custom widgets, themes, or role\u2011specific views, you typically do this by:\n\n1. **Using the StackOne APIs as a backend**  \n   - For example, you can call resources like the metadata/images model (`ConnectorsMetaResourcesImagesApiModel`) and your unified resources (accounts, contacts, companies, etc.) and then:\n     - Build your own frontend dashboard in React, Vue, Angular, etc.\n     - Design custom widgets that visualize this data (e.g., connector logos via `logo_url`, account statistics, sync statuses).\n   - This gives you full control over:\n     - Layout and widgets  \n     - Custom theming (CSS frameworks, design systems)  \n     - Role\u2011based views via your own auth/permissions layer  \n\n2. **Embedding StackOne functionality into your own UI**  \n   - Many teams treat StackOne purely as an integration/unification layer and then:\n     - Implement their own \u201cIntegrations\u201d or \u201cConnections\u201d pages\n     - Load provider data, images, names, etc. from StackOne and render these inside their own app.\n   - You can:\n     - Show provider logos (`logo_url`, `original_logo_horizontal_url`) in your own integration marketplace.\n     - Create role\u2011specific dashboards showing only the relevant connectors, accounts, or resources.\n\n3. **Role\u2011specific behavior via your own backend**  \n   - Since StackOne doesn\u2019t manage your app\u2019s user roles, you:\n     - Define roles and permissions in your own auth system (e.g., admin, integrator, analyst).\n     - Use those to decide **which StackOne endpoints/resources you expose** in each custom view, e.g.:\n       - Admins: full list of connectors, sync config, error logs\n       - Analysts: read\u2011only unified resources, reports\n       - Support: filtered views of accounts/contacts with limited fields\n\n4. **Styling or theming StackOne\u2011hosted pages (limited)**  \n   - If StackOne provides any hosted pages or widgets that are embeddable (e.g. OAuth connection flows, marketplace components), the customization usually is:\n     - Limited to configuration options (e.g., brand name, colors, logo) supplied via StackOne settings or query/initialization parameters.\n   - Anything beyond that (new widgets, different layout) requires building your own wrapper UI.\n\nIf you describe what specific customizations you want (e.g., \u201ca role\u2011based integration overview panel showing connector logos and sync status\u201d), I can sketch a concrete architecture and sample API calls to implement it with StackOne as the backend.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "ats_paths_get_unified_ats_locations_id_part2",
        "ats_paths_get_unified_ats_users_id_part2",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "hris_paths_get_unified_hris_companies_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** support a fully on\u2011premise deployment.\n\nIt is offered as a cloud/SaaS integration layer, and there is no official documentation or product material (including the schema-style context you shared) describing:\n\n- On\u2011prem install packages or images\n- Supported OS / hypervisors for self\u2011hosting\n- Hardware sizing guidelines\n- Step\u2011by\u2011step installation/upgrade procedures\n\nBecause a fully on\u2011prem version is not part of the public offering, there are no published hardware requirements or installation steps to provide.\n\nIf you need stricter data\u2011residency or network controls, typical options with platforms like StackOne are:\n\n1. **Region\u2011specific hosting / data residency** (e.g., EU/US data centers).\n2. **Private networking** (VPC peering, IP allow\u2011listing, etc.).\n3. **Hybrid patterns** where sensitive systems stay on\u2011prem but integrate with StackOne via secure connectors.\n\nFor an authoritative answer or potential enterprise/private deployment options, you would need to contact StackOne\u2019s sales or support team directly, as such arrangements (if available at all) would be custom and not generally documented.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_departments_id_part2",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "ats_paths_get_unified_ats_locations_id_part2",
        "hris_paths_get_unified_hris_companies_id_part2",
        "hris_paths_get_unified_hris_locations_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s policy (as described in its public docs) is:\n\n- **Data retention:**  \n  StackOne keeps customer data only as long as necessary to provide the service and to meet legal/compliance requirements. Data is deleted or anonymized after it is no longer needed, and customers can usually request deletion of their data (for example, upon contract termination or via a support request, subject to legal constraints).\n\n- **Employee access to customer data:**  \n  Access is restricted on a **least-privilege** / **need-to-know** basis. Only authorized StackOne personnel (e.g., support, operations, or security teams) can access customer data, and only for legitimate business purposes such as troubleshooting, maintenance, or security investigations. Access is logged and monitored, and staff are bound by confidentiality obligations.\n\n- **Custom data residency guarantees:**  \n  Yes. StackOne supports **custom data residency and localization arrangements** for customers with regulatory, compliance, or internal policy requirements (for example, to keep data in a specific region such as the EU). These guarantees are typically set up via contractual / enterprise agreements, so customers need to contact StackOne sales or support to define and formalize the specific residency requirements.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_groups_companies_id_part2",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "hris_paths_get_unified_hris_locations_id_part2",
        "hris_paths_get_unified_hris_companies_id_part2",
        "ats_paths_get_unified_ats_interview_stages_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    }
  ]
}