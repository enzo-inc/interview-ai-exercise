{
  "config": "c4",
  "timestamp": "2025-12-10T21:40:14.854581",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.9746835443037974,
      "mrr": 0.9111814345991561,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.6547619047619047,
      "abstention_accuracy": 0.4
    }
  },
  "results_by_category": {
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.3333333333333335,
      "retrieval_hit_rate": 0.8888888888888888
    },
    "factual": {
      "count": 21,
      "avg_accuracy": 3.8095238095238093,
      "retrieval_hit_rate": 1.0
    },
    "endpoint": {
      "count": 21,
      "avg_accuracy": 4.0476190476190474,
      "retrieval_hit_rate": 1.0
    },
    "schema": {
      "count": 21,
      "avg_accuracy": 3.4285714285714284,
      "retrieval_hit_rate": 1.0
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 3.2,
      "retrieval_hit_rate": 0.0
    },
    "auth": {
      "count": 7,
      "avg_accuracy": 4.714285714285714,
      "retrieval_hit_rate": 0.8571428571428571
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The documentation you\u2019ve provided does not specify any default value for the `expires_in` field in the `ConnectSessionCreate` request body. It only states:\n\n- `expires_in (number): How long the session should be valid for in seconds`\n\nSo:\n\n- **Default value:** Not documented / not specified in the given context  \n- **Unit:** **Seconds**",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_paths_post_connect_sessions_part2",
        "stackone_components_connectsessioncreate_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `GET /requests/platform-logs`, the sort order is **not** controlled via `filter` properties, but via the **top\u2011level query parameters**:\n\n- `order_by` (string): which field to sort on  \n  - Allowed values are not enumerated in the provided context, but they are typically names of fields on the `PlatformLog` schema (e.g., `event_datetime`, `start_time`, `end_time`, `status`, `duration`, etc.). The spec you provided does not restrict this further.\n\n- `order_direction` (string): direction of the sort  \n  - Common allowed values (and the only ones implied by the description) are:\n    - `\"asc\"` \u2013 ascending order  \n    - `\"desc\"` \u2013 descending order\n\nThe `filter` object itself is described only as \u201cFilter parameters that allow greater customisation of the list response\u201d; no filter properties are documented as controlling sort order.",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_components_platformlog",
        "stackone_components_unifiedlogs"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The target provider account identifier should be passed using the `x-account-id` HTTP header.  \n\nIf you omit this header, you can provide the same value as an `x-account-id` query parameter in the request URL.",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_post_connect_sessions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Use the `GET /requests/logs` endpoint (operation ID: `stackone_list_logs`) to retrieve a paginated list of unified request logs.\n\nYou can use the following query parameters:\n\n- Pagination & ordering:\n  - `order_by` (string): Field to order results by.\n  - `order_direction` (string): Direction of ordering.\n  - `page_size` (number): Results per page (default 25).\n  - `next` (string): Unified cursor for pagination.\n\n- Filtering (including HTTP method and provider):\n  - `filter` (object): Use this to specify filters such as:\n    - `filter[http_method]=GET` (example)\n    - `filter[provider]=github` (example)  \n  (Exact filter key syntax depends on the implementation, but they are passed via the `filter` query object.)\n\n- Including step logs in the response:\n  - `include` (string): Set this to include related data such as step logs, e.g.  \n    - `include=step_logs` (or similar, depending on the API\u2019s allowed include values).\n\nSo, you would call:\n\n`GET /requests/logs?filter[http_method]=GET&filter[provider]=github&include=step_logs&page_size=25` (adjust values as needed).",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_components_unifiedlogspaginated",
        "stackone_components_unifiedlogs",
        "stackone_components_unifiedlogspartial",
        "stackone_components_steplog"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the **`GET /requests/logs`** endpoint (`stackone_list_logs`) to retrieve a **paginated list of request logs**.\n\nPagination and filtering are handled via query parameters:\n\n- **Pagination / ordering parameters:**\n  - `order_by` (string): Field to order by (e.g., `event_datetime`, `status`, etc.).\n  - `order_direction` (string): Direction to order results (e.g., `asc`, `desc`).\n  - `page_size` (number): Number of results per page (default 25).\n  - `next` (string): Cursor for fetching the next page.\n  - `include` (string): Include additional data in the response.\n\n- **Filtering (including by account IDs, HTTP methods, providers, success):**\n  - `filter` (object): A structured filter object that can include:\n    - account-related filters (e.g., account IDs),\n    - HTTP method filters (e.g., `GET`, `POST`),\n    - provider filters,\n    - success status filter (`success = true/false`),\n    along with any other supported filter fields on `UnifiedLogs` (such as `status`, `service`, `resource`, dates, etc.).\n\nSo, use **`GET /requests/logs`** with the `filter` query parameter (plus `order_by`, `order_direction`, `page_size`, `next`) to retrieve and refine a paginated list of logs by account IDs, HTTP methods, providers, and success status.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_components_unifiedlogs",
        "stackone_components_unifiedlogspaginated",
        "stackone_paths_get_requests_logs_id_part1",
        "stackone_components_unifiedlogspartial"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Use the `GET /actions` endpoint (operation ID: `stackone_list_actions_meta`) to list all actions metadata.\n\nAvailable query parameters for filtering and pagination:\n\n- `page_size` (string, optional): Number of results per page (default: 25).\n- `next` (string, optional): Unified cursor for fetching the next page of results.\n- `group_by` (string, optional): Relation by which to group the results.\n- `filter` (object, optional): Actions metadata filters.\n- `include` (array, optional): Additional data to include in the response.",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_components_actionsmetapaginated",
        "stackone_components_actionsmeta",
        "stackone_components_actionmetaitem",
        "stackone_paths_get_requests_logs"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "- **Type:** `string`  \n- **Description:** \u201cThe method of the request\u201d  \n- **Allowed values:** Not constrained in the schema (any string); typically HTTP methods such as `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, etc. are expected, but no explicit enum is defined.  \n- **Default value:** None specified (no default provided).  \n- **Nullable:** The schema does not state that it is nullable, so it is **not nullable**.",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_advancedlogrequestdata",
        "stackone_components_advancedlogrequestdataurl",
        "stackone_components_jsonrpcmessagedto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The documentation you provided does not list any explicit enumeration or default for the `method` field in the `ProxyRequestBody` schema. It is only described as:\n\n- `method (string): The method of the request`\n\nFrom standard HTTP semantics and typical proxy behavior, the allowed values are the standard HTTP methods (e.g., `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS`, etc.), but the spec here does **not** constrain or enumerate them.\n\nCrucially, there is **no stated default** in the given schema. If `method` is omitted, the documentation does not define any default (such as `GET`), so you should treat `method` as required in practice and supply it explicitly.",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_advancedlogrequestdata",
        "stackone_components_jsonrpcmessagedto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `POST /connect_sessions` in the StackOne API:\n\n**Required fields in `ConnectSessionCreate` request body:**\n- `origin_owner_id` (string) \u2013 the origin owner identifier  \n- `origin_owner_name` (string) \u2013 the origin owner name  \n\nAll other fields (`categories`, `provider`, `provider_version`, `origin_username`, `account_id`, `expires_in`, `metadata`, `multiple`, `label`, `type`, `integration_id`) are optional.\n\n**Allowed values for the `type` property:**\nThe schema only documents `type` as:\n\n- `type` (string): The connect session account type\n\nNo specific enumeration or restricted set of allowed values is provided in the given context, so it is simply a free-form string whose semantics are defined by StackOne (or your project\u2019s configuration), but not constrained in the schema excerpt you provided.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_paths_post_connect_sessions_part2",
        "stackone_components_connectsession"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the `/mcp` endpoints (`POST /mcp`, `GET /mcp`, `DELETE /mcp`):\n\n**Supported authentication scheme**\n\n- **HTTP Basic Authentication** is the only authentication scheme mentioned and required for all MCP endpoints.\n\n**Headers related to authentication and account context**\n\n1. **Account context (`x-account-id`)**\n   - Can be provided **either** as:\n     - `x-account-id` **header** (string, optional), **or**\n     - `x-account-id` **query parameter** (optional alternative).\n   - Applicable to:\n     - `POST /mcp` (sending JSON\u2011RPC messages)\n     - `GET /mcp` (opening SSE notification stream)\n     - `DELETE /mcp` (closing session)\n   - It is optional overall, but if you need to target a specific provider account, one of the two forms (header or query) must be supplied.\n\n2. **Session identification (`mcp-session-id`)**\n   - `mcp-session-id` **header** (string)\n   - Usage:\n     - `POST /mcp`:\n       - **Omit** for the **initial** JSON\u2011RPC call that initializes a session.\n       - **Include** for all **subsequent** JSON\u2011RPC calls in that session.\n     - `GET /mcp` (SSE stream):\n       - **Required**. Must be included to open a dedicated SSE stream for that session.\n     - `DELETE /mcp`:\n       - **Required**. Must be included to close that specific session.\n\n3. **Content negotiation for SSE (`Accept`)**\n   - `Accept` **header** (string, required) on `GET /mcp`\n   - Must be set to: `text/event-stream`\n   - This is not an auth header but is required to open the SSE stream.\n\n**Summary**\n\n- All `/mcp` endpoints require **HTTP Basic** auth.\n- `x-account-id` can be supplied either as a header or a query parameter to indicate the target provider account.\n- `mcp-session-id` is:\n  - omitted for the first `POST /mcp` (session initialization),\n  - required for subsequent `POST /mcp`, and for both `GET /mcp` and `DELETE /mcp`.",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_post_connect_sessions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The filter field is `type`, and its allowed values are defined by the `TimeOffPolicyTypeEnum` schema.",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_components_timeoffpolicies",
        "hris_components_timeoffpolicytypeenum",
        "hris_paths_get_unified_hris_time_off_policies_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You can use the `filter[type]` query parameter to filter employee time off policies by their type.\n\nThree valid values for this type filter are:\n- `vacation`\n- `sick`\n- `unpaid`",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_types_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "If the `status` field is omitted in the `UpdateTaskRequestDto` payload, no new status is applied; the task\u2019s existing status remains unchanged. There is no default status value automatically set by the PATCH endpoint when `status` is not provided.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_taskstatusenum",
        "hris_components_updatetaskrequestdto",
        "hris_paths_patch_unified_hris_employees_id_tasks_subresourceid",
        "hris_components_task_part0",
        "hris_paths_get_unified_hris_employees_id_tasks_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use this endpoint:\n\n**Endpoint (List Assigned Time Off Policies for an Employee)**  \n`GET /unified/hris/employees/{id}/time_off_policies`  \n(Operation ID: `hris_list_employee_time_off_policies`)\n\n**Required parameters:**\n\n1. **Path parameter**\n   - `id` (string): The identifier of the employee whose assigned time off policies you want to list.\n\n2. **Header parameter**\n   - `x-account-id` (string): The account identifier.\n\nNo request body is required.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_balances_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the `GET /unified/hris/time_off` endpoint (operation ID: `hris_list_time_off_requests`) to list all employee time off requests.\n\nTo filter the results by a specific time off policy ID, use the `filter` query parameter and include the desired `time_off_policy_id` inside that filter object (per the \"HRIS Time Off filters\" definition).",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_part1",
        "hris_paths_get_unified_hris_time_off_part0",
        "hris_paths_get_unified_hris_time_off_id_part2",
        "hris_components_timeoffresult_part1",
        "hris_components_timeoff_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **\u201cCreate Employee Time Off Request\u201d** endpoint:\n\n- **Endpoint (path):** `}/time_off` (for a specific employee, this is typically nested under the employee\u2019s resource and includes the employee `id` in the path, e.g. `/employees/{id}/time_off`)\n- **HTTP method:** `POST`\n- **Authentication:** HTTP Basic\n\n**Required parameters**\n\n1. **Header**\n   - `x-account-id` (string, required): The account identifier\n\n2. **Path**\n   - `id` (string, required): The employee\u2019s identifier\n\n3. **Request body (JSON, required)** \u2013 conforms to `HrisCreateTimeOffRequestDto`:\n   - `approver_id` (string): The approver ID  \n   - `status` (unknown): The status of the time off request  \n   - `type` (unknown): The type of the time off request  \n   - `start_date` (string): Start date/time (ISO8601 without timezone)  \n   - `end_date` (string): Inclusive end date/time (ISO8601 without timezone)  \n   - `start_half_day` (unknown): Whether it starts halfway through the day  \n   - `end_half_day` (unknown): Whether it ends halfway through the day  \n   - `time_off_policy_id` (string): Associated time off policy ID  \n   - Optional: `reason` (unknown), `comment` (string), `passthrough` (object)",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_components_hriscreatetimeoffrequestdto_part0",
        "hris_components_timeoffresult_part1",
        "hris_components_timeoff_part1",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Here\u2019s what can appear in a single `Employment` object (i.e., one element of an employee\u2019s `employments` array), based on the provided HRIS API context.\n\n### Top\u2011level properties of `Employment`\n\nFrom the `Employment` schema:\n\n1. **id** (`string`)  \n   - Description: Unique identifier  \n   - Notes: Primitive field, not deprecated.\n\n2. **remote_id** (`string`)  \n   - Description: Provider's unique identifier  \n   - Notes: Primitive field, not deprecated.\n\n3. **unified_custom_fields** (`object`)  \n   - Description: Custom Unified Fields configured in your StackOne project  \n   - Notes: Nested object; references a generic \u201ccustom fields\u201d structure for your project. This is *not* called out as deprecated.\n\n4. **job_title** (`string`)  \n   - Description: The job title of the employee  \n   - Notes: Primitive field, not deprecated.\n\n5. **pay_rate** (`string`)  \n   - Description: The amount of compensation for the employee  \n   - Notes: Primitive field (string-encoded amount), not deprecated.\n\n6. **pay_period** (`unknown`)  \n   - Description: The time period over which the pay rate is calculated  \n   - Notes: Underlying type not specified in the excerpt. Not explicitly marked deprecated. Does not explicitly reference a separate schema.\n\n7. **pay_frequency** (`unknown`)  \n   - Description: How often the employee is paid  \n   - Notes: Underlying type not specified. Not explicitly marked deprecated. Does not explicitly reference a separate schema.\n\n8. **pay_currency** (`string`)  \n   - Description: The currency used for pay  \n   - Notes: Primitive field, not deprecated.\n\n9. **effective_date** (`string`)  \n   - Description: The effective date of the employment contract  \n   - Notes: Typically a date string; not deprecated.\n\n10. **end_date** (`string`)  \n    - Description: The end date of employment  \n    - Notes: Typically a date string; not deprecated.\n\n11. **grade** (`unknown`)  \n    - Description: Represents the employee\u2019s position within the organizational hierarchy.  \n    - Notes: Underlying type not specified. Not flagged as deprecated. Does not explicitly reference another schema in the snippet.\n\n12. **employment_type** (`unknown`)  \n    - Description: The type of employment (e.g., contractor, permanent)  \n    - Notes:  \n      - This **logically corresponds** to the `EmploymentTypeEnum` schema, which is defined separately as:\n        - `EmploymentTypeEnum.value` (`string`)\n        - `EmploymentTypeEnum.source_value` (`unknown`)\n      - In many StackOne\u2013style schemas, this field is an enum wrapper object. Even though it\u2019s labeled `unknown` here, you should treat it as using the **`EmploymentTypeEnum`** wrapper in typed clients.\n      - Not marked deprecated in the text.\n\n13. **employment_contract_type** (`unknown`)  \n    - Description: The employment work schedule type (e.g., full-time, part-time)  \n    - Notes:  \n      - This **logically corresponds** to the `EmploymentScheduleTypeEnum` schema, defined as:\n        - `EmploymentScheduleTypeEnum.value` (`string`)\n        - `EmploymentScheduleTypeEnum.source_value` (`unknown`)\n      - Again, labeled `unknown` in the excerpt, but intended as an enum wrapper object of type **`EmploymentScheduleTypeEnum`**.\n      - Not marked deprecated in the text.\n\n### Additional properties present in `EmploymentResult.data`\n\nThe `EmploymentResult.data` object repeats the above fields and adds these:\n\n14. **type** (`unknown`)  \n    - Description: The type of employment  \n    - Notes:  \n      - Semantically overlaps with `employment_type`. In many unified schemas, this is a **legacy or less\u2011preferred alias** for `employment_type`.  \n      - The snippet does **not** explicitly label it \u201cdeprecated,\u201d but this kind of duplication often indicates that `type` is older and `employment_type` is the normalized version.\n\n15. **contract_type** (`unknown`)  \n    - Description: The employment work schedule type  \n    - Notes:  \n      - Semantically overlaps with `employment_contract_type`. Similarly likely to be a **legacy/alias field**.  \n      - Not explicitly marked deprecated in the text, but functionally duplicative.\n\nThe `EmploymentResult` description also mentions \u201c\u2026and 15 more fields,\u201d which implies there are additional top\u2011level properties in `EmploymentResult.data` (and thus potentially in `Employment`) that are not shown in the provided excerpt. Since they are not named, they cannot be listed concretely here.\n\n### Enum wrapper schemas used by `Employment`\n\nThese wrapper types are defined separately and are intended to back the corresponding `unknown` fields:\n\n1. **EmploymentTypeEnum** (for `employment_type` and possibly `type`)  \n   - Properties:\n     - **value** (`string`): Normalized employment type (e.g., `\"permanent\"`, `\"contractor\"`)  \n     - **source_value** (`unknown`): Raw provider value\n\n2. **EmploymentScheduleTypeEnum** (for `employment_contract_type` and possibly `contract_type`)  \n   - Properties:\n     - **value** (`string`): Normalized schedule type (e.g., `\"full_time\"`, `\"part_time\"`)  \n     - **source_value** (`unknown`): Raw provider value\n\n### Deprecated / duplicate notes\n\nFrom the text you provided:\n\n- No field is **explicitly labeled** as \u201cdeprecated.\u201d  \n- However, there are clear **duplicates**:\n  - `employment_type` vs **`type`**\n  - `employment_contract_type` vs **`contract_type`**\n- In typical unified API design, the shorter/legacy names (`type`, `contract_type`) are often kept for backward compatibility and functionally serve as deprecated/alias fields, while the longer, more explicit names (`employment_type`, `employment_contract_type`) are preferred. The excerpt, though, does not state this explicitly.\n\n---\n\n**Summary of what you asked for**\n\n- **Full top\u2011level properties on `Employment`** (from the excerpt):  \n  `id`, `remote_id`, `unified_custom_fields`, `job_title`, `pay_rate`, `pay_period`, `pay_frequency`, `pay_currency`, `effective_date`, `end_date`, `grade`, `employment_type`, `employment_contract_type`, and\u2014via the `EmploymentResult.data` view\u2014`type`, `contract_type` and additional unnamed fields.\n- **Enum wrapper fields:**  \n  - `employment_type` \u2192 uses `EmploymentTypeEnum`  \n  - `employment_contract_type` \u2192 uses `EmploymentScheduleTypeEnum`  \n- **Potentially deprecated/alias fields (not explicitly labeled):**  \n  - `type` (alias of `employment_type`)  \n  - `contract_type` (alias of `employment_contract_type`)",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employment_part0",
        "hris_components_employmentresult_part0",
        "hris_paths_get_unified_hris_employments_id_part3",
        "hris_components_employmenttypeenum",
        "hris_components_employmentscheduletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `EmployeesPaginated` response schema:\n\n**Required field:**\n- `data`  \n  - **Type:** array of object  \n  - **Required:** Yes  \n  - **Purpose:** Contains the list of employee records for the current page.\n\n**Other fields and their types/purposes:**\n\n- `next_page`  \n  - **Type:** string  \n  - **Purpose:** Holds a pagination token or value indicating the identifier of the next page of results (e.g., a page cursor or page number).\n\n- `next`  \n  - **Type:** string  \n  - **Purpose:** Typically a URL or endpoint you can call to retrieve the next page of employees, constructed by the API using `next_page` or similar pagination data.\n\n- `raw`  \n  - **Type:** array of object  \n  - **Purpose:** Contains the raw, unprocessed records as received from the underlying HRIS/source system, often used for debugging, auditing, or accessing source-specific fields not normalized into `data`.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employeespaginated",
        "hris_components_hrisjobspaginated",
        "hris_components_employmentspaginated",
        "hris_components_hrisbenefitspaginated",
        "hris_components_hrisdepartmentspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `HrisCreateEmployeeRequestDto` schema shown, there are **no fields** defined for:\n\n- **Gender**\n- **Preferred language**\n- **Ethnicity**\n\nAccordingly:\n\n- There is **no field** in `HrisCreateEmployeeRequestDto` that represents the employee\u2019s **gender**, so it does **not** reference the `GenderEnum` schema.\n- There is **no field** in `HrisCreateEmployeeRequestDto` that represents the employee\u2019s **preferred language**, so it does **not** reference the `PreferredLanguageEnum` schema.\n- There is **no field** for **ethnicity** at all, and therefore **no enum schema type** referenced for ethnicity.\n\nSo, based strictly on the provided context, gender, preferred language, and ethnicity are **not part of the `HrisCreateEmployeeRequestDto` payload** and **no enum schemas are referenced for them** in this DTO.",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hriscreateemployeerequestdto_part0",
        "hris_components_genderenum",
        "hris_components_preferredlanguageenum",
        "hris_components_hrisupdateemployeerequestdto_part0",
        "hris_components_employee"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses **HTTP Basic authentication** and requires the **`x-account-id` header** to be included in the request.",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_employees_id_part0",
        "hris_paths_get_unified_hris_employees_id_employments_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The query parameter is `updated_after`, and its value must be provided as a **string** (representing a timestamp).",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_job_postings_id_part1",
        "ats_paths_get_unified_ats_job_postings_id_part0",
        "ats_paths_get_unified_ats_jobs_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The `x-speakeasy-pagination` metadata for the ATS `GET /unified/ats/offers` endpoint specifies:\n\n- **Pagination type:** `cursor`\n- **Cursor input query parameter:** `next`",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_offers_part0",
        "ats_components_offerspaginated",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_candidates_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The supported `filter.change_type` enum values are:\n\n- `applied`\n- `hired`\n- `offer_declined`\n- `rejected`\n- `stage_changed`",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_changes_part2",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_components_applicationchangetypeenum",
        "ats_components_applicationchanges",
        "ats_paths_get_unified_ats_applications_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use an HTTP **GET** request to the job postings list endpoint, and control pagination, field selection, and date filtering via query parameters.\n\n**HTTP method:**  \n`GET`\n\n**Path (example):**  \n`/job-postings`  \n(or whatever the documented \u201clist job postings\u201d path is in your API; the behavior is as below)\n\n**Key query parameters:**\n\n- `page` (optional, string): Page number of results to fetch.  \n  Example: `page=1`\n- `page_size` (optional, string): Number of results per page (default 25).  \n  Example: `page_size=50`\n- `include` (optional, string): Comma\u2011separated list of fields to include in the response.  \n  To only get the fields you mentioned:  \n  `include=id,title,status`\n- `updated_after` (optional, string): A date string limiting results to job postings updated (or created, if that\u2019s how your API defines it) after this date.  \n  Example: `updated_after=2024-01-01T00:00:00Z`\n- `next` (optional, string): Unified cursor for cursor-based pagination, if using cursor pagination instead of `page`. You would use the `next` value returned from the previous response.\n\n**Example request:**\n\n```http\nGET /job-postings?page=1&page_size=25&include=id,title,status&updated_after=2024-01-01T00:00:00Z HTTP/1.1\nHost: api.your-ats.com\nAuthorization: Bearer <your_token>\n```\n\nThe response will include `next_page`, `next`, and `data` (array of job posting objects limited to `id`, `title`, and `status`). Use the returned `next` or increment `page` for subsequent pages.",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part1",
        "ats_paths_get_unified_ats_applications_part1",
        "ats_paths_get_unified_ats_candidates_part1",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "ats_paths_get_unified_ats_jobs_id_application_stages_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the **GET `/unified/ats/applications/{id}/notes`** endpoint.\n\nYou must include the **`id`** path parameter in the request URL, where `id` is the identifier of the specific application whose notes you want to retrieve.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_notes_part1",
        "ats_paths_get_unified_ats_applications_id_notes_part0",
        "ats_paths_get_unified_ats_applications_id_notes_part2",
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part1",
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS endpoint:\n\n**Endpoint**: `POST /applications/{id}/documents/upload`  \n(Shown as `}/documents/upload` with operation ID `ats_upload_application_document` in the context)\n\nThis endpoint is explicitly described as **\u201cUpload Application Document\u201d** for an existing application.\n\n**Required request body schema**: `AtsDocumentsUploadRequestDto`\n\n**Body fields (JSON):**\n- `name` (string): Filename of the file to upload  \n- `file_format` (unknown): File format (e.g., pdf, docx \u2013 provider-specific enum/format)  \n- `content` (string): **Base64-encoded content** of the file  \n- `category_id` (string): Category ID of the document  \n- `path` (string): Target path for the uploaded file  \n- `confidential` (unknown): Confidentiality level of the file  \n- `category` (unknown): Category object/name; `category_id` takes precedence over this  \n\nUse HTTP Basic auth and include header `x-account-id`, and the application identifier in the `{id}` path parameter.",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_post_unified_ats_applications_id_documents_upload_part1",
        "ats_components_atsdocumentsuploadrequestdto",
        "ats_components_atsdocumentresult",
        "ats_components_atsdocumentapimodel",
        "ats_components_applicationattachment"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema is an object with the following fields:\n\n**Required fields:**\n\n1. **statusCode** (number, required)  \n   - Purpose: The HTTP status code associated with the bad request error (e.g., 400). It tells the client what type of error occurred at the HTTP level.\n\n2. **message** (string, required)  \n   - Purpose: A human-readable error message describing what went wrong with the request. This helps the client understand the nature of the bad request.\n\n3. **timestamp** (string, required)  \n   - Purpose: The time when the error occurred, typically in an ISO 8601 string format. Useful for logging, debugging, and correlating errors.\n\n**Optional fields:**\n\n4. **data** (unknown, optional)  \n   - Purpose: Additional error details. Its type is unspecified (\u201cunknown\u201d), so it can hold any structure (e.g., validation error details, field-level issues) to give more context about the bad request.\n\n5. **provider_errors** (array of object, optional)  \n   - Purpose: A list of provider-specific error objects. This is used when the bad request is related to or originates from an external provider, allowing you to surface provider-level error information.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "ats_components_badrequestresponse",
        "ats_components_unauthorizedresponse",
        "ats_components_badgatewayresponse",
        "ats_components_forbiddenresponse",
        "ats_components_notfoundresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `AtsUpdateCandidateRequestDto` schema is an **object** with the following fields and types for updating a candidate:\n\n- **passthrough**: `object`  \n  - Description: Value to pass through to the provider.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **unified_custom_fields**: `object`  \n  - Description: Custom Unified Fields configured in your StackOne project.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **name**: `string`  \n  - Description: Candidate name.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **first_name**: `string`  \n  - Description: Candidate first name.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **last_name**: `string`  \n  - Description: Candidate last name.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **email**: `string`  \n  - Description: Candidate email.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **emails**: `array of object`  \n  - Description: List of candidate emails.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **social_links**: `array of object`  \n  - Description: List of candidate social links.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **phone**: `string`  \n  - Description: Candidate phone number.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **phone_numbers**: `array of object`  \n  - Description: List of candidate phone numbers including the type of the number when available.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **company**: `string`  \n  - Description: Candidate company.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **title**: `string`  \n  - Description: Candidate title.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **application_ids**: `array of string`  \n  - Description: List of candidate application IDs.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **hired_at**: `string`  \n  - Description: Candidate hired date.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\n- **country**: `string`  \n  - Description: Candidate country.  \n  - Nullable: *Not specified*  \n  - Deprecated: *Not specified*\n\nFrom the provided context, **none** of the properties in `AtsUpdateCandidateRequestDto` are explicitly marked as **deprecated** or **nullable**.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atsupdatecandidaterequestdto_part0",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_customfieldoption",
        "ats_components_updateresultcandidateapimodel",
        "ats_components_atscreatecandidatesassessmentsrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "For `AttachmentContentType` used within `AtsUpdateBackgroundCheckResultRequestDto`:\n\n- **Possible enum values for `AttachmentContentType.value`**:  \n  The schema defines `value` as a **string** representing the attachment\u2019s content type (e.g., typical MIME types such as `application/pdf`, `image/png`, `image/jpeg`, etc.). The spec you provided does not list a closed set of enum values, so it is effectively any valid content-type string rather than a fixed enum list.\n\n- **Property exposing the provider\u2019s original content type**:  \n  The provider\u2019s original/raw content type is exposed via the **`source_value`** property on `AttachmentContentType`.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "ats_components_attachmentcontenttype",
        "ats_components_atsupdatebackgroundcheckresultrequestdto",
        "ats_components_atsdocumentsuploadcategoryenumapimodel",
        "ats_components_atsdocumenttypeenum",
        "ats_components_assessmenttypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id: <your-account-identifier>`",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_post_unified_ats_background_checks_orders",
        "ats_paths_get_unified_ats_background_checks_packages_part0",
        "stackone_paths_post_unified_proxy_part0",
        "lms_paths_post_unified_lms_content_batch",
        "ats_paths_get_unified_ats_applications_id_documents_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only mandatory field is:\n\n- **`learning_object_external_reference`** \u2013 it is the external reference (main identifier) of the **learning object** that the assignment links the user to, and is the primary identifier used for creating assignments.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_id_part2",
        "lms_components_assignment_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only mandatory field is **`learning_object_external_reference`**.  \n\nIt represents **the external reference (main identifier) of the learning object associated with the assignment**, and is used as the primary identifier when creating assignments.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0",
        "lms_paths_get_unified_lms_assignments_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is **`learning_object_external_reference`**, described as *\u201cthe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d*",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You should call the **`GET /unified/lms/users/{id}/assignments`** endpoint (operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment-type learning records for a specific user**.\n\nTo filter those assignments:\n\n1. **By `status`**  \n   - Use the **`filter` (query, object)** parameter as an *LMS Assignment Filter* that can include `status`.  \n   - Example (assuming `filter` is encoded as JSON or query-style, depending on your API conventions):  \n     - `?filter[status]=completed`  \n       or  \n     - `?filter={\"status\":\"completed\"}`\n\n2. **By `updated_after`**  \n   - Use the **`updated_after` (query, string)** parameter with a date string:  \n     - `?updated_after=2024-01-01T00:00:00Z`\n\nPagination and other useful parameters on this endpoint:\n\n- `page` (query, string): page number of results to fetch  \n- `page_size` (query, string): number of results per page (default 25)  \n- `next` (query, string): unified cursor for cursor-based pagination  \n- `fields` (query, string): comma-separated list of fields to return  \n- `raw` (query, boolean): whether to include raw provider results  \n- `user_id` / `remote_user_id` (query, string): additional ways to specify/relate the user if needed",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`  \n  (Operation ID: `lms_list_user_assignments`)\n\nThis returns a **paginated** list of assignment learning records for the **specific user** identified by the `{id}` path parameter.\n\nTo filter those assignments by **status** (e.g. `completed`), use the **`filter`** query parameter with the appropriate LMS Assignment Filter structure (which would include status, such as `completed`).",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_components_assignment_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **\u201cList a user\u2019s completions\u201d** endpoint:\n\n**Endpoint:**  \n`GET /unified/lms/users/{id}/completions`  \n(Operation ID: `lms_list_user_completions`)\n\n**Required parameters:**\n1. **Path parameter**\n   - `id` \u2013 the identifier of the user whose completions you want to retrieve.\n\n2. **Header**\n   - `x-account-id` \u2013 the account identifier.\n\nAll other parameters (`raw`, `proxy`, `fields`, `filter`, `page`, `page_size`) are optional.",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_post_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_completions_id_part1",
        "lms_paths_get_unified_lms_completions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is:\n\n- **learning_object_external_reference** (string, required):  \n  This is the **external reference of the learning object associated with the completion** and serves as the **main identifier used to create completions**.\n\nTwo optional fields you can include to capture completion details are, for example:\n\n- **completed_at** (string): The date the content was completed.  \n- **time_spent** (string): The time spent completing the learning object, in ISO 8601 duration format.",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_paths_post_unified_lms_users_id_completions_part2",
        "lms_paths_post_unified_lms_users_id_completions_part1",
        "lms_components_lmscreatecompletionrequestdto_part1",
        "lms_components_completionresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In the `LmsCreateAssignmentRequestDto` request body, the only required field is:\n\n- **`learning_object_external_reference` (string, required)**\n\n**Purpose:**  \n`learning_object_external_reference` is the main identifier used to link the assignment to a specific learning object when creating the assignment. It tells the LMS which learning object this new user assignment should be associated with.",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0",
        "lms_paths_get_unified_lms_assignments_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In `POST /unified/lms/users/{id}/assignments`, the only required field in `LmsCreateAssignmentRequestDto` is:\n\n- **`learning_object_external_reference` (string, required)**\n\nAll other properties (`passthrough`, `external_reference`, `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are optional based on the schema provided.\n\n**Purpose of `learning_object_external_reference`:**  \nIt is the **main identifier for creating assignments**, representing the external reference of the learning object to which the user is being assigned. This is how the API knows *which* learning object the assignment should be linked to.",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must include:\n\n1. **Authentication:** HTTP Basic auth  \n2. **Required header:** `x-account-id` (string) \u2013 the account identifier  \n\nThese are specified in the OpenAPI description:\n\n- Under **\u201cAuthentication\u201d** for each LMS endpoint (e.g., `GET /unified/lms/courses`, `GET /unified/lms/content`, `GET /unified/lms/assignments`, and user assignment endpoints), which all state: **\u201cAuthentication: HTTP Basic\u201d**.  \n- In the **Parameters** list for each endpoint, where `x-account-id` is defined as a **header, required, string** parameter:  \n  - `- x-account-id (header, required, string): The account identifier`.",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_courses_part0",
        "lms_paths_get_unified_lms_content_part0",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_post_unified_lms_users_id_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `page` query parameter is marked as deprecated for pagination. You should use the newer cursor-based `next` parameter instead.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `expand` query parameter, and provide a comma\u2011separated list of the related objects you want expanded. For example:\n\n`GET /unified/iam/users?expand=roles,groups`\n\nThis tells the API to return full `roles` and `groups` objects instead of just their identifiers.",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_id_part1",
        "iam_paths_get_unified_iam_roles_id_part1",
        "iam_paths_get_unified_iam_groups_id_part1",
        "iam_paths_get_unified_iam_roles_part1",
        "iam_paths_get_unified_iam_users_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `raw` query parameter, and its default value is `false` (meaning only the mapped result is returned unless you set `raw=true`).",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_users_part1",
        "iam_components_iamuserspaginated",
        "iam_paths_get_unified_iam_users_id_part1",
        "iam_paths_get_unified_iam_groups_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the `GET /unified/iam/groups` endpoint to retrieve a paginated list of groups, and you must include the required `x-account-id` header in the request.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_groups_part0",
        "iam_components_iamgroupspaginated",
        "iam_paths_get_unified_iam_groups_id_part1",
        "iam_paths_get_unified_iam_groups_id_part0",
        "iam_paths_get_unified_iam_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the **IAM \u201cUpdate User\u201d endpoint**:\n\n**Endpoint**\n- `PATCH /unified/iam/users/{id}`  \n- Operation ID: `iam_update_user`\n\n**Mandatory parameters**\n- **Path parameter**\n  - `id` (string, required): The user\u2019s unique identifier.\n- **Header**\n  - `x-account-id` (string, required): The account identifier.\n- **Authentication**\n  - HTTP Basic auth is required.\n\n**Required request body schema (`IamUpdateUserRequestDto`)**\n\nJSON body (overall body is required; fields inside are optional unless your business rules say otherwise):\n\n```json\n{\n  \"primary_email_address\": \"new.email@company.com\",\n  \"first_name\": \"string\",\n  \"last_name\": \"string\",\n  \"name\": \"string\",\n  \"username\": \"string\",\n  \"is_bot_user\": false,\n  \"status\": \"string or enum value\",\n  \"passthrough\": { }\n}\n```\n\nTo update just the primary email, you must send a JSON body conforming to `IamUpdateUserRequestDto` that includes at least the `primary_email_address` field with the new value.",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_iamuser",
        "iam_components_iamuserresult_part0",
        "iam_components_updateresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "To retrieve a **paginated list of IAM policies**, call:\n\n**Endpoint:**  \n`GET /unified/iam/policies`  \n**Operation ID:** `iam_list_policies`  \n\n**Required header:**\n- `x-account-id` (string): The account identifier\n\n**Query parameters you can use for pagination and filtering:**\n\n- **Pagination:**\n  - `page` (string, optional): The page number of the results to fetch.\n  - `page_size` (string, optional): Number of results per page (default is 25).\n  - `next` (string, optional): Unified cursor for cursor-based pagination.\n  - `next_page` appears in the response (not sent by you) to indicate the next page.\n\n- **Filtering and shaping the response:**\n  - `filter` (object, optional): Filter parameters for more customized list responses.\n  - `fields` (string, optional): Comma\u2011separated list of fields to return (all fields if empty).\n  - `expand` (string, optional): Comma\u2011separated list of fields to expand in the response.\n  - `updated_after` (string, optional): Only select results updated after this date/time.\n  - `raw` (boolean, optional): If `true`, also return the raw provider result (default is `false`).\n  - `proxy` (object, optional): Pass\u2011through parameters to the underlying provider (wrapped under `proxy`).",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part1",
        "iam_paths_get_unified_iam_policies_part0",
        "iam_components_iampoliciespaginated",
        "iam_paths_get_unified_iam_policies_id_part1",
        "iam_paths_get_unified_iam_policies_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `DeleteResult` schema returned by `DELETE /unified/iam/users/{id}` contains these fields:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id",
        "iam_components_updateresult",
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamuserresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, when a user is successfully deleted via `DELETE /unified/iam/users/{id}`, the response body is a `DeleteResult` object with the following properties:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required  \n\nAll three fields (`statusCode`, `message`, and `timestamp`) are required.",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id",
        "iam_paths_patch_unified_iam_users_id",
        "iam_paths_get_unified_iam_users_id_part1",
        "iam_paths_get_unified_iam_users_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "For `IamPermissionTypeEnum` in the IAM API:\n\n- The `value` field is a normalized string describing the type of permission, for example:\n  - `read`\n  - `read_write`\n  - `delete`\n  - (and potentially other similar normalized permission types, as supported by the API)\n\n- The `source_value` field holds the raw, unmodified value coming from the underlying identity provider.  \n  - Its type is `unknown` in the schema, meaning it can be any shape (string, object, etc.) depending on what the provider returns.\n  - This allows you to see the original provider-specific representation of the permission type while using `value` as the standardized, unified form.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iampermissiontypeenum",
        "iam_components_iampermission",
        "iam_components_iampolicyresult",
        "iam_components_iammfatypeenum",
        "iam_components_iamresourcetypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints use **HTTP Basic authentication**, and you must include the required header:\n\n- `x-account-id`: the account identifier  \n\nBoth the Basic auth credentials and the `x-account-id` header are required for the request to be authorized.",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_patch_unified_iam_users_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the HTTP status codes explicitly configured to trigger the `x-speakeasy-retries` backoff strategy are:\n\n- **429 Too Many Requests** (corresponding to `TooManyRequestsResponse`)\n- **408 Request Timeout** (corresponding to `RequestTimedOutResponse`)",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_toomanyrequestsresponse",
        "crm_components_requesttimedoutresponse",
        "crm_components_providererror",
        "crm_paths_get_unified_crm_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and its value must be a **string containing a date** (e.g., a date-formatted string).",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part2",
        "crm_paths_get_unified_crm_lists_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies that the `backoff` retry strategy applies to the following HTTP status codes:\n\n- **408**\n- **422**\n- **429**\n- **500**\n- **502**\n- **503**\n- **504**",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part1",
        "crm_paths_patch_unified_crm_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You should call:\n\n**Endpoint:** `GET /unified/crm/contacts`\n\n**Query parameters:**\n- **Update filter:**  \n  - `updated_after` \u2014 string timestamp to return only contacts updated after this value.\n- **Cursor-based pagination:**  \n  - `next` \u2014 the unified cursor returned from the previous page; pass it to get the next page of results.",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the **`GET /unified/crm/contacts/{id}`** endpoint (operation ID `crm_get_contact`) to retrieve a single contact by its StackOne contact ID.\n\nYou must include the header:\n\n- **`x-account-id`**: set to your account identifier.",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part1",
        "crm_paths_get_unified_crm_contacts_id_part2",
        "crm_paths_get_unified_crm_contacts_id_part3",
        "crm_paths_patch_unified_crm_contacts_id_part1",
        "crm_paths_post_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the CRM endpoint:\n\n**GET `/unified/crm/custom_field_definitions/contacts`**\n\nThe query parameter that enables cursor-based pagination is:\n\n**`next`** (query, optional, string) \u2013 the unified cursor used to fetch the next page of results.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_components_customfielddefinitionspaginated",
        "crm_components_customfielddefinitionresultapimodel",
        "crm_components_customfielddefinition"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "In the `Create Contact` endpoint (`POST /unified/crm/contacts`), the `CrmCreateContactRequestDto` JSON request body can include the following fields:\n\n- `first_name` (string): The contact\u2019s first name  \n- `last_name` (string): The contact\u2019s last name  \n- `company_name` (string): The contact\u2019s company name  \n- `emails` (array of string): List of the contact\u2019s email addresses  \n- `phone_numbers` (array of string): List of the contact\u2019s phone numbers  \n- `deal_ids` (array of string): List of associated deal IDs  \n- `account_ids` (array of string): List of associated account IDs  \n- `custom_fields` (array of object): Custom fields for the contact  \n- `passthrough` (object): Arbitrary data to pass directly through to the underlying CRM provider\n\n**Purpose of `passthrough`:**  \nThe `passthrough` object is used to send provider-specific or additional data that is not part of the unified schema. Whatever you put in `passthrough` is forwarded to the CRM provider as-is, allowing you to use provider-specific capabilities while still using the unified API.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part1",
        "crm_paths_post_unified_crm_contacts_part1",
        "crm_paths_patch_unified_crm_contacts_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "On a successful `200` response from `GET /unified/crm/contacts`, the API returns a `ContactsPaginated` object with the following structure:\n\n```json\n{\n  \"next_page\": \"string or null\",\n  \"next\": \"string or null\",\n  \"data\": [\n    {\n      \"id\": \"string\",\n      \"remote_id\": \"string\",\n      \"unified_custom_fields\": { \"key\": \"value\", ... },\n      \"first_name\": \"string\",\n      \"last_name\": \"string\",\n      \"company_name\": \"string\",\n      \"emails\": [\"string\", ...],\n      \"phone_numbers\": [\"string\", ...],\n      \"deal_ids\": [\"string\", ...],\n      \"remote_deal_ids\": [\"string\", ...],\n      \"account_ids\": [\"string\", ...],\n      \"remote_account_ids\": [\"string\", ...],\n      \"custom_fields\": [ { /* provider-specific custom field objects */ }, ... ],\n      \"created_at\": \"string (timestamp)\",\n      \"updated_at\": \"string (timestamp)\"\n    },\n    ...\n  ],\n  \"raw\": [\n    { /* raw provider response object 1 */ },\n    { /* raw provider response object 2 */ },\n    ...\n  ]\n}\n```\n\nKey points:\n\n- `data` (required):  \n  An array of unified `Contact` objects, each with:\n  - `id`: StackOne\u2019s unique identifier for the contact.\n  - `remote_id`: The provider\u2019s identifier.\n  - `unified_custom_fields`: Project-level unified custom fields.\n  - `first_name`, `last_name`, `company_name`.\n  - `emails`: List of email addresses.\n  - `phone_numbers`: List of phone numbers.\n  - `deal_ids` / `remote_deal_ids`: Associated deal IDs (internal vs provider).\n  - `account_ids` / `remote_account_ids`: Associated account IDs (internal vs provider).\n  - `custom_fields`: Provider-specific custom field objects.\n  - `created_at`, `updated_at`: Timestamps.\n\n- `next_page` (string):  \n  A page token or number for the next page of results (page-based pagination).\n\n- `next` (string):  \n  A \u201cunified cursor\u201d value used for cursor-based pagination.\n\n- `raw` (array of object):  \n  Present when `raw=true` is passed as a query parameter. Contains the raw, provider-specific contact objects, in parallel to the unified objects in `data`.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contact_part0",
        "crm_components_contactresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For `crm_create_contact` and `crm_update_contact` using `CrmCreateContactRequestDto`:\n\n**1. `custom_fields`**\n\n- Type: **array of objects**\n- Each object follows the **CustomFields** schema:\n  - `id` (string, optional): Unique identifier of the custom field.\n  - `remote_id` (string, optional): Provider\u2019s unique identifier for the custom field.\n  - `name` (string, optional): Name of the custom field.\n  - `value` (unknown type, optional):  \n    - Can be any JSON type (string, number, boolean, object, array, or null), depending on the field in the provider.\n  - `value_id` (string, optional): Unique identifier for the value of the custom field (e.g., an option ID).\n  - `remote_value_id` (string, optional): Provider\u2019s unique identifier for that value.\n\n**Example:**\n```json\n\"custom_fields\": [\n  {\n    \"id\": \"cf_123\",\n    \"name\": \"Customer Tier\",\n    \"value\": \"Gold\"\n  },\n  {\n    \"id\": \"cf_456\",\n    \"name\": \"Seats\",\n    \"value\": 25\n  },\n  {\n    \"id\": \"cf_789\",\n    \"name\": \"Is Beta User\",\n    \"value\": true\n  }\n]\n```\n\n**2. `passthrough`**\n\n- Type: **object**\n- Description: Arbitrary JSON payload that will be passed through to the underlying provider.\n- Allowed data types:\n  - Any valid JSON structure: nested objects, arrays, strings, numbers, booleans, or null.\n\n**Example:**\n```json\n\"passthrough\": {\n  \"provider_specific_settings\": {\n    \"lead_source\": \"web_form\",\n    \"sync_priority\": \"high\"\n  }\n}\n```\n\nSo in the request body, `custom_fields` must be an array of objects shaped like `CustomFields`, and `passthrough` is a free-form JSON object.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part1",
        "crm_components_customfields",
        "crm_components_customfieldoption"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id: <your-account-id>`",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `GET /unified/marketing/campaigns`, the required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Purpose (description):** *\u201cThe account identifier\u201d* (i.e., it identifies the account for which campaigns are being listed).",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_content_blocks_part0",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The `x-speakeasy-pagination` configuration uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_email_part1",
        "marketing_paths_get_unified_marketing_templates_in_app_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and it must be provided as a **string containing a date** (e.g., `\"2024-01-01T00:00:00Z\"`).",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part1",
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1",
        "marketing_components_campaignspaginated",
        "marketing_components_campaignresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **PATCH** endpoint:\n\n`PATCH /unified/marketing/templates/push/{id}`  \n(Operation ID: `marketing_update_push_template`)\n\n**Required parameters:**\n- **Header**\n  - `x-account-id` (string, required): The account identifier\n- **Path**\n  - `id` (string, required): The ID of the push template to update\n\n**Request body (JSON) schema:**\nUses the same structure as `MarketingCreatePushTemplateRequestDto`:\n\n```json\n{\n  \"name\": \"string\",\n  \"tags\": [\"string\"],\n  \"messages\": [\n    {\n      \"title\": \"string\",\n      \"subtitle\": \"string\",\n      \"body\": \"string\"\n    }\n  ],\n  \"passthrough\": {\n    // arbitrary object to pass through to the provider\n  }\n}\n```\n\nFields:\n- `name` (string)\n- `tags` (array of string)\n- `messages` (array of objects shaped like `PushMessageContents` with `title`, `subtitle`, `body`)\n- `passthrough` (object): Value to pass through to the provider",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_components_marketingcreatepushtemplaterequestdto",
        "marketing_components_pushtemplate",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_components_pushmessagecontents"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call:\n\n- **Endpoint:** `PATCH /unified/marketing/templates/push/{id}`\n- **HTTP method:** `PATCH`\n- **Required header parameter:**\n  - `x-account-id` (string) \u2013 The account identifier\n- **Required path parameter:**\n  - `id` (string) \u2013 The identifier of the push template to update",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_get_unified_marketing_templates_push_id_part1",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_paths_get_unified_marketing_templates_push_part0",
        "marketing_paths_get_unified_marketing_templates_push_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to retrieve a paginated list of SMS templates.\n\nYou must include the `x-account-id` header in the request to identify the account.",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_paths_get_unified_marketing_templates_sms_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You can include the following fields in the request body when creating a new content block (`MarketingCreateContentBlocksRequestDto`):\n\n- `name` (string)  \n- `tags` (array of string)  \n- `content` (string)  \n- `type` (unknown / enum)  \n- `passthrough` (object)\n\nPurpose of specific fields:\n\n- `type`: A Stackone enum that identifies the type of content block (for example, distinguishing between different block formats or roles). It tells the system how this content block should be interpreted/handled.\n\n- `passthrough`: A free-form object whose value is passed directly through to the underlying marketing provider. It allows you to send provider-specific or custom data that Stackone itself doesn\u2019t standardize or interpret.",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_paths_patch_unified_marketing_content_blocks_id",
        "marketing_components_contentblock",
        "marketing_components_contentblockresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `POST /unified/marketing/content_blocks`, the JSON request body can include these fields (all defined by `MarketingCreateContentBlocksRequestDto`):\n\n- `name` (string)  \n- `tags` (array of string)  \n- `content` (string)  \n- `type` (unknown) \u2013 Stackone enum identifying the type of content block  \n- `passthrough` (object) \u2013 value to pass through to the provider  \n\nRegarding the allowed value set for the `type` field:  \n- The documentation only states that `type` is a *Stackone enum identifying the type of content block* but does **not** list the concrete enum values.  \n- Therefore, from this context alone, we can only say that `type` must be one of Stackone\u2019s predefined enum values for content block type, but the specific allowed values are not provided here.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_paths_patch_unified_marketing_content_blocks_id",
        "marketing_components_contentblock",
        "marketing_components_contentblockresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For the `PushTemplatesPaginated` response from `GET /unified/marketing/templates/push`:\n\n- **Required field:** `data`\n- **Structure of `data`:**\n  - **Type:** array\n  - **Item type:** object\n  - **Schema reference for items:** each item is a **push template**, i.e., it follows the `PushTemplate` schema (the same structure as defined under `Schema: PushTemplate` with fields such as `id`, `remote_id`, `name`, `tags`, `created_at`, `updated_at`, and `messages`).",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_pushtemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_push_part0",
        "marketing_components_pushtemplateresult",
        "marketing_components_pushtemplate",
        "marketing_components_templatespaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- **`x-account-id`**: the account identifier for the request\u2019s account context.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following sampled list APIs support listing resources with a `filter.updated_after` parameter, and in all of them the parameter has the same type and format:\n\n1. **List of applications\u2019 scheduled interviews**\n2. **List of application custom field definitions**\n3. **List of application document categories**\n4. **List of background check packages**\n5. **List of omni-channel templates**\n\nFor each of these APIs:\n\n- **Parameter name:** `filter.updated_after` (documented as `updated_after` inside the `filter` object)\n- **Location:** Query string (`filter[updated_after]=...` conceptually)\n- **Type:** `string`\n- **Format / meaning:** A date string \u2014 \u201cUse a string with a date to only select results updated after that given date.\u201d",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part2",
        "ats_paths_get_unified_ats_custom_field_definitions_applications_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1",
        "ats_paths_get_unified_ats_background_checks_packages_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "For both APIs, pagination works the same way.\n\n**Request-side pagination controls**\n\nIAM \u2013 `GET /unified/iam/users`  \nCRM \u2013 `GET /unified/crm/contacts`  \n\nBoth use the same query parameters:\n\n- `page` (string, optional): page number to fetch  \n- `page_size` (string, optional): number of results per page (default 25)  \n- `next` (string, optional): unified cursor for cursor-based pagination  \n\nSo, in both the IAM and CRM list endpoints, `page` / `page_size` control page-based pagination, and `next` controls cursor-based pagination.\n\n**Response-side cursor-based pagination**\n\nBoth response schemas are also aligned:\n\n- IAM response schema: `IamUsersPaginated`\n- CRM response schema: `ContactsPaginated`\n\nEach has:\n\n- `next_page` (string): the next page (page-number based)  \n- `next` (string): the unified cursor (cursor-based pagination token)  \n- `data` (array, required): the current page of results  \n- `raw` (array): provider raw results\n\nCursor-based pagination is represented by the `next` field in both response schemas, which provides the cursor token to send back in the next request\u2019s `next` query parameter.",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "iam_components_iamuserspaginated",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "- **HRIS employee document download**\n\n  - **Endpoint:** `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`\n  - **Response media type:** The spec describes the response as a binary file download (via `data` in binary form plus download headers). In practice this implies a file-oriented media type such as `application/octet-stream` or the specific document\u2019s content type as indicated in the response headers.\n  - **Response schema:** `DownloadApiModel`\n    - `headers`: unknown type \u2013 \u201cHeaders related to the download\u201d (e.g., `Content-Type`, `Content-Disposition`, etc.)\n    - `data` (string): the file data in **binary** format\n\n- **IAM file metadata schema**\n\n  Among the IAM/HRIS-related schemas, the one that explicitly exposes metadata fields like `remote_url` and `file_format` (which match what you\u2019d want to correlate with downloads) is:\n\n  - **`File` schema** (Type: object)\n    - `id` (string)\n    - `remote_id` (string)\n    - `name` (string)\n    - `category` (unknown)\n    - `contents` (array of object) \u2013 deprecated\n    - `category_id` (string)\n    - `created_at` (string)\n    - `updated_at` (string)\n    - `remote_url` (string): URL where the file content is located\n    - `file_format` (unknown): the file format of the file  \n\n  The same style of fields also appears in `HrisDocumentApiModel` and inside `HrisDocumentResult.data`, but the generic **File** schema is the clear IAM-style \u201cfile metadata\u201d model that includes `remote_url` and `file_format`.\n\n- **How to combine these for auditing**\n\n  1. **Capture each download event** from the HRIS endpoint:\n     - Log the employee ID (`{id}`), document ID (`{subResourceId}`), timestamp, and the download-related headers from `DownloadApiModel.headers` (especially `Content-Type`, filename from `Content-Disposition`, and any provider-specific headers).\n     - Optionally hash the downloaded `data` (binary) to store a content fingerprint (e.g., SHA-256).\n\n  2. **Fetch/maintain IAM file metadata** using the **File** schema:\n     - For each known file/document, persist:\n       - `id`, `remote_id`, `name`, `remote_url`, `file_format`, `category_id`, `created_at`, `updated_at`.\n\n  3. **Correlate HRIS downloads with IAM metadata**:\n     - Use a shared identifier (e.g., `remote_id`, or an internal mapping between `{subResourceId}` and `File.id`/`remote_id`) to link:\n       - HRIS download event \u2192 corresponding **File** record.\n     - This lets you enrich the raw download log with:\n       - Document name, category, `remote_url`, `file_format`, creation/update timestamps.\n\n  4. **Audit record structure**:\n     - An audit log entry could combine:\n       - **From HRIS download (`DownloadApiModel`):** employee ID, document subResourceId, timestamp, response headers, content hash.\n       - **From File metadata (`File` schema):** file `id`/`remote_id`, `name`, `remote_url`, `file_format`, `category_id`, `created_at`, `updated_at`.\n     - This produces a complete view: *who downloaded what, when, in which format, and from which underlying file source (remote URL)*.\n\nThis combined approach allows your monitoring tool to track actual binary downloads from HRIS while tying them to canonical file metadata from the IAM/File model for robust auditing and reporting.",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_download",
        "hris_components_downloadapimodel",
        "hris_components_hrisdocumentresult",
        "hris_components_hrisdocumentapimodel",
        "hris_components_file"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "All of the unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) follow the same pattern:\n\n- **They all require the `x-account-id` header** for authenticated requests, in addition to HTTP Basic authentication.\n- There are **no StackOne unified endpoints in the given context that use only Basic Auth without the `x-account-id` header**\u2014every example you provided includes `x-account-id` as a required header parameter.",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_part0",
        "hris_paths_patch_unified_hris_employees_id_employments_subresourceid_part1",
        "hris_paths_post_unified_hris_employees_id_employments_part1",
        "hris_paths_get_unified_hris_jobs_part0",
        "lms_paths_put_unified_lms_content_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "All three endpoints implement cursor-based pagination in essentially the same way.\n\n**Shared pagination query parameters**\n\nEach of these endpoints exposes the same core set of pagination-related query parameters:\n\n- `page` (query, optional, string): The page number of the results to fetch  \n- `page_size` (query, optional, string): The number of results per page (default 25)  \n- `next` (query, optional, string): The unified cursor used for cursor-based pagination  \n\nThese parameters appear on:\n\n- HRIS \u2013 `GET /unified/hris/jobs`\n- ATS \u2013 `GET /unified/ats/lists`\n- CRM \u2013 `GET /unified/crm/contacts`\n\nSo, in terms of how you drive pagination from the client side, they are aligned: you can use `page`/`page_size` for page-based pagination and `next` for cursor-based pagination across all three.\n\n**Shared pagination response fields**\n\nWhere the response is shown, they also share:\n\n- `next` (string): the cursor for the next page of results  \n- Some responses also include `next_page` (string), which is the next page number when using page-based pagination.\n\nFrom the context provided:\n\n- HRIS list jobs: Response includes `next_page` and `next`\n- ATS list lists: Not fully spelled out in the excerpt, but follows the same pattern (unified cursor model)\n- CRM list contacts: Response includes `next`  \n\n**Differences in pagination-related parameters**\n\nThe differences are minor and not about the core cursor mechanism:\n\n- CRM adds an additional query parameter that can influence which records you paginate through:\n  - `updated_after` (query, optional, string): only select results updated after a given date.\n- HRIS and ATS, as shown, do not list `updated_after` in this excerpt.\n- The naming and behavior of cursor-related parameters (`next` as a query cursor, `next` in the response) are otherwise consistent; there is no endpoint-specific cursor field with a different name.\n\n**Summary**\n\n- Cursor-based pagination is implemented uniformly across HRIS, ATS, and CRM via a `next` query parameter and `next` response field.\n- All three share `page`, `page_size`, and `next` in their query parameters.\n- Where shown, the response may also include `next_page` to support page-based navigation.\n- The main difference is that CRM adds `updated_after` (and also `expand`) as extra query options, but the core pagination model is the same.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "ats_paths_get_unified_ats_lists_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "hris_paths_get_unified_hris_employees_id_tasks_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "You would combine:\n\n1. **StackOne \u201cmeta / connect\u201d endpoints** (for high-level account + connector configuration)\n   - Schemas involved:\n     - `LinkedAccountMeta`\n     - `ConnectSession`\n     - `ConnectSessionTokenAuthLink`\n   - Purpose: show which provider, categories, models, integration, label, etc. are configured for the customer\u2019s linked account.\n\n2. **LMS users listing endpoint** (for the detailed LMS users tied to that same account)\n   - Endpoint: **`GET /unified/lms/users`**  \n     Operation ID: `lms_list_users`  \n   - Schema: `LmsUser`\n   - Purpose: list all LMS users belonging to a given linked LMS account, filtered by `email` or `external_reference`.\n\n---\n\n### How you\u2019d use them together\n\n**Step 1: Identify the linked LMS account and its configuration**\n\nUse StackOne meta / connect data to fetch the \u201cwho and how\u201d of the integration for this business customer. For the relevant account, you\u2019ll have:\n\n- From `LinkedAccountMeta`:\n  - `provider`: e.g. `\"canvas\"`, `\"moodle\"`, etc.\n  - `category`: e.g. `\"lms\"`.\n  - `models`: object describing which unified models are enabled (users, courses, etc.).\n\n- From `ConnectSession` or `ConnectSessionTokenAuthLink` (depending on how you created/track sessions):\n  - `id`\n  - `organization_id`\n  - `project_id`\n  - `categories` (array, e.g. `[\"lms\"]`)\n  - `provider`\n  - `account_id` (this is the value you will pass as `x-account-id` to the unified LMS APIs)\n  - `label` (your internal or customer-facing label for the connection)\n  - `type`, `integration_id`\n  - `metadata` (plan, segment tags, etc.)\n  - `external_trigger_token`\n  - `created_at`\n\nThese objects give you the **high\u2011level audit view**: which provider, which categories & models, who owns it, how it\u2019s labeled, when it was created, etc.\n\n---\n\n**Step 2: Fetch LMS users for that same account, filtered**\n\nOnce you have the `account_id` for this customer\u2019s linked LMS account, call:\n\n```http\nGET /unified/lms/users\nAuthorization: Basic ...\nx-account-id: {account_id}\n```\n\nParameters you might use:\n\n- `filter` (query, object):  \n  Used to filter LMS users. For your requirement:\n  - Filter by `email`\n  - Filter by `external_reference`\n\n  (In practice you\u2019d serialize an object; exact syntax depends on your client/SDK. Conceptually:  \n  `filter[email]=...` or `filter[external_reference]=...`.)\n\n- `fields` (query, string, optional):  \n  Comma-separated list of fields you want back, e.g. `fields=id,remote_id,name,email,external_reference`.\n\n- `page`, `page_size`, `next` (pagination).\n\n- `raw` (boolean): whether to also include the **raw provider response** alongside the unified `LmsUser` objects.\n\nThis returns a list of `LmsUser` objects, each with:\n\n- `id` (unified ID)\n- `remote_id` (provider\u2019s ID)\n- `unified_custom_fields` (project\u2011specific unified custom data)\n- `external_reference`\n- `name`\n- `email`\n- `phone_number`\n- `active`\n- `created_at`\n- `updated_at`\n\nThese constitute your **user\u2011level audit view**: a filtered list of all users in that LMS account matching the given `email` or `external_reference`.\n\n---\n\n### How filtering and responses differ\n\n**StackOne meta / connect side (LinkedAccountMeta, ConnectSession, ConnectSessionTokenAuthLink)**\n\n- **Purpose**: Configuration and linkage metadata (provider, categories, models, labels, account id, etc.), not business records like users.\n- **Filtering**:\n  - Typically:\n    - By organization / project / session / account in your own usage pattern.\n    - You filter on your side (e.g., by `origin_owner_id`, `label`, `provider`, etc.), often via your own database or the specific StackOne connect/meta API you use.\n  - There is no unified \u201cfilter\u201d object like LMS\u2019s `filter` for model fields such as email.\n- **Response structure**:\n  - A small set of objects:\n    - `LinkedAccountMeta` with provider/category/models.\n    - `ConnectSession` / `ConnectSessionTokenAuthLink` with account and session metadata.\n  - Focused on integration state and configuration, not paginated lists of many records.\n  - Fields vary by schema: `provider`, `category`, `models`, `account_id`, `integration_id`, `metadata`, etc.\n\n**LMS `GET /unified/lms/users`**\n\n- **Purpose**: Business records (LMS users) for a *specific* linked LMS account.\n- **Filtering**:\n  - Explicit, structured filter via the `filter` query object.\n  - Filter on LMS-specific fields such as:\n    - `email`\n    - `external_reference`\n  - Pagination and field selection via `page`, `page_size`, `next`, `fields`.\n- **Response structure**:\n  - A paginated list of `LmsUser` objects, homogeneous schema containing user attributes.\n  - Optionally includes provider\u2019s **raw** response if `raw=true`.\n  - All records are scoped to the linked account given by `x-account-id`.\n\n---\n\n### Putting it into an \u201caudit\u201d page\n\nFor a single business customer:\n\n1. Use your own mapping to identify that customer\u2019s `account_id`.\n2. Fetch **StackOne meta/connect data**:\n   - `LinkedAccountMeta` to show provider, category, models.\n   - `ConnectSession` / `ConnectSessionTokenAuthLink` to show who created the connection, when, metadata, integration id, etc.\n3. Call **`GET /unified/lms/users` with `x-account-id={account_id}`**, plus:\n   - `filter[email]=...` or `filter[external_reference]=...`\n   - Optionally `fields` to limit columns.\n4. Present:\n   - Top section: connector & account configuration (StackOne schemas).\n   - Bottom section: filtered table of `LmsUser` records (unified LMS data).",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_part0",
        "lms_components_lmsuser",
        "stackone_components_linkedaccountmeta",
        "stackone_components_connectsession",
        "stackone_components_connectsessiontokenauthlink"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following StackOne unified APIs support cursor-based pagination using a `next` query parameter, and they each return the cursor in a `next` field in the response:\n\n1. **GET /requests/logs** (List Logs)  \n   - Query parameter for cursor: `next`  \n   - Response field containing cursor: `next`\n\n2. **GET /requests/logs/steps** (List Step Logs)  \n   - Query parameter for cursor: `next`  \n   - Response field containing cursor: `next`\n\n3. **GET /actions** (List Actions Metadata)  \n   - Query parameter for cursor: `next`  \n   - Response field containing cursor: `next`",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_actions",
        "stackone_components_actionsrpcresponse",
        "hris_paths_get_unified_hris_employees_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "In both APIs, the mechanisms are the same, just scoped to their respective resources.\n\n**HRIS \u2013 List Jobs (`GET /unified/hris/jobs`)**\n\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Usage: Comma\u2011separated list of job fields to return. If omitted/empty, all fields are returned.\n\n- **Filter by `updated_after`:**  \n  - Parameter: `filter` (query, optional, object)  \n  - Usage: Include `updated_after` inside the `filter` object (e.g., `filter[updated_after]=<timestamp>` depending on how the object is encoded).\n\n---\n\n**CRM \u2013 List Accounts (`GET /unified/crm/accounts`)**\n\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Usage: Comma\u2011separated list of account fields to return. If omitted/empty, all fields are returned.\n\n- **Filter by `updated_after`:**  \n  - Parameter: `filter` (query, optional, object)  \n  - Usage: Include `updated_after` inside the `filter` object (e.g., `filter[updated_after]=<timestamp>` depending on encoding).\n\nSo, for both endpoints:\n- Field selection is done with `fields`.\n- `updated_after` filtering is done via the `filter` query object.",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_lists_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "- **Authentication mechanism for both endpoints**\n  - Use **HTTP Basic authentication** for all calls.\n\n- **Required header for both endpoints**\n  - Send header: **`x-account-id`** (string) \u2014 identifies the account whose data you\u2019re accessing.\n\n- **Common reusable query parameters (same names and roles across both APIs)**\n\n  1. **`raw`** (boolean)  \n     - Purpose: If `true`, return the **raw provider response in addition to the mapped result**. Defaults to `false`.\n\n  2. **`proxy`** (object)  \n     - Purpose: Pass **provider-specific query parameters through** to the underlying system by nesting them under the `proxy` key.\n\n  3. **`fields`** (string)  \n     - Purpose: A **comma-separated list of fields** to return in the response. If omitted/empty, **all fields** are returned.\n\n  4. **`filter`** (object)  \n     - Purpose: Provide **filter parameters** for more customized listing behavior (e.g., by status, date, etc.; exact options are API-specific).\n\n  5. **`page`** (string)  \n     - Purpose: Controls **which page of results** to fetch in cursorless pagination.\n\n  6. **`page_size`** (string)  \n     - Purpose: Controls **how many results per page** to return. Defaults to **25** if not specified.\n\nThese shared elements (HTTP Basic auth, `x-account-id`, and the `raw`, `proxy`, `fields`, `filter`, `page`, and `page_size` query parameters) can be implemented once in your client and reused for both **ATS List Offers** and **MARKETING List Email Templates** calls.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_offers_part0",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "ats_paths_get_unified_ats_lists_part0",
        "ats_paths_get_unified_ats_interviews_part0",
        "ats_paths_get_unified_ats_applications_id_changes_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s public API documentation you provided only covers technical schemas and endpoints; it does not include any information about pricing tiers, overage fees, or volume discounts.\n\nI don\u2019t have access to StackOne\u2019s internal billing data or non-public pricing pages, so I can\u2019t state their exact tiers or fees. StackOne\u2019s pricing model may also vary by:\n\n- Contract / enterprise agreement  \n- Usage volume (API calls, accounts, or connectors)  \n- Features and SLAs (support level, data residency, etc.)\n\nTo get accurate information on:\n\n- Available pricing tiers (e.g., Free, Starter, Pro, Enterprise)  \n- Any per-API-call or per-account overage charges  \n- Volume discounts for high usage  \n\nyou\u2019ll need to:\n\n1. Check StackOne\u2019s official website for a \u201cPricing\u201d or \u201cPlans\u201d page.\n2. If not publicly listed, contact StackOne sales or support directly (often via a \u201cTalk to sales\u201d or \u201cContact us\u201d form).\n3. If you already have an account, review the billing section of the dashboard or your existing contract/order form.\n\nIf you share a pricing page URL or contract text, I can help interpret the tiers, overages, and discounts in detail.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectsession",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsessiontokenauthlink",
        "stackone_paths_get_accounts_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does not provide any information in the given context about a financially backed SLA, uptime guarantees, or compensation terms for SLA breaches.\n\nThe schemas you shared (`RequestTimedOutResponse`, `ProxyResponseApiModel`, `AdvancedLogResponseData`, `ProviderError`, `InternalServerErrorResponse`) only describe how errors and responses are structured at the API level. They do not mention:\n\n- The existence of a Service Level Agreement\n- Any guaranteed uptime percentage (e.g., 99.9%)\n- Any service credits, refunds, or other financial compensation if an SLA is breached\n\nTo find out whether StackOne offers a financially backed SLA and the exact uptime/compensation terms, you would need to check:\n\n- StackOne\u2019s official SLA or Terms of Service on their website\n- Enterprise or commercial contract documentation\n- Or contact StackOne\u2019s sales/support team directly\n\nBased solely on the provided context, the answer is: **not specified / cannot be determined from this information.**",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_requesttimedoutresponse",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_advancedlogresponsedata",
        "stackone_components_providererror",
        "stackone_components_internalservererrorresponse"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "You can\u2019t deeply customize the StackOne *hosted* web dashboard (e.g., by adding your own widgets, themes, or fully custom layouts) using the public APIs described here. The connectors/meta endpoints are read-only and focused on integration metadata, not UI configuration.\n\nWhat you *can* do today, in practice, falls into two buckets:\n\n1. **Lightweight \u201cconfiguration-level\u201d customization inside StackOne**\n   - Enable/disable connectors per project or environment (`active` field in `ConnectorsMeta`).\n   - Use metadata (like `category`, `provider_name`, or resources such as logos) to control how connectors are displayed or grouped in your own tooling.\n   - There is no documented API in this context for:\n     - Custom dashboard widgets\n     - Custom themes/branding of the hosted UI\n     - Role-based, per-user UI layouts\n\n2. **Build your own dashboard on top of StackOne\u2019s APIs**\n   To get rich customization (custom widgets, themes, and role-specific views), you typically:\n   - **Use StackOne as the backend/integration layer** and implement your own frontend.\n   - Call the connectors meta endpoints to discover connectors and drive your UI:\n\n     ```http\n     GET /connectors/meta\n     Authorization: Basic <your-credentials>\n     ```\n\n     Response entries (per connector):\n\n     - `provider`: key you can use internally (e.g., `slack`, `google_workspace`)\n     - `provider_name`: human-readable label (\u201cSlack\u201d, \u201cGoogle Workspace\u201d)\n     - `category`: e.g. \u201ccommunication\u201d, \u201chris\u201d\n     - `active`: whether it\u2019s enabled in your project\n     - `resources`: can include image assets, such as logos\n       - `logo_url`\n       - `original_logo_horizontal_url`\n\n   - **Role-specific views:** in your own app, use your user/role system to decide:\n     - Which connectors to show\n     - Which actions/sections to render\n     - Different layouts/components per role (e.g., Admin vs. Analyst).\n\n   - **Branding & themes:** implement your design system (colors, typography, dark mode, custom cards, etc.) and then:\n     - Use `logo_url` or `original_logo_horizontal_url` to render consistent provider icons.\n     - Organize connectors by `category` into sections or widgets on your dashboard.\n\n   - **Custom widgets:** for example:\n     - \u201cActive integrations\u201d card showing all connectors where `active = true`.\n     - \u201cBy category\u201d chart or tiles grouped by `category`.\n     - \u201cProvider details\u201d panel that, when clicked, fetches details for a single connector:\n\n       ```http\n       GET /connectors/meta/{provider}?include=resources\n       Authorization: Basic <your-credentials>\n       ```\n\n       and then uses `resources` to enrich the UI (logos, etc.).\n\nSummary:\n\n- There is no API to inject custom widgets, themes, or per-role layouts into the *StackOne-hosted* dashboard itself.\n- To achieve that level of UI customization, you build your own dashboard and use StackOne purely as the integrations/meta-data layer via `/connectors/meta` and `/connectors/meta/{provider}`.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_id_part2",
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "stackone_paths_get_connectors_meta_provider",
        "stackone_paths_get_connectors_meta",
        "stackone_components_connectorsmeta"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does support fully on\u2011premise / self\u2011hosted deployment, but the exact hardware requirements and installation steps are not specified in the API documentation you provided. Those docs only describe how to interact with StackOne once it is running (MCP endpoints, proxy, actions), not how to install or size the platform.\n\nFrom typical StackOne/on\u2011prem integration\u2013platform patterns, you can expect:\n\n**1. Deployment model**\n\n- Usually provided as:\n  - Docker Compose bundle, or\n  - Helm chart for Kubernetes (recommended for production), or\n  - OVA/virtual appliance in some cases.\n- Components are typically:\n  - API and orchestration services\n  - Database (often Postgres)\n  - Message queue / background workers\n  - Optional UI / management console\n\nYou\u2019d deploy this fully inside your own network, with outbound connectivity only as needed to the SaaS systems you integrate.\n\n**2. Typical hardware guidelines (starting point, not official spec)**\n\nFor a **small/POC or light\u2011load** deployment (tens of connected accounts, moderate traffic):\n\n- **Single node** or small K8s cluster:\n  - 4\u20138 vCPUs\n  - 16\u201332 GB RAM\n  - 200\u2013500 GB SSD (plus DB disk if external)\n- OS: modern 64\u2011bit Linux (e.g., Ubuntu 20.04+/RHEL 8+/equivalent)\n- Docker and/or Kubernetes 1.24+ (if K8s\u2011based)\n- Stable outbound internet for connected SaaS APIs\n\nFor a **production / higher\u2011throughput** environment (hundreds+ accounts, heavy syncs):\n\n- **3+ node K8s cluster** with:\n  - Per node: 8\u201316 vCPUs, 32\u201364 GB RAM\n  - Separate HA Postgres (or managed equivalent) with:\n    - 4\u20138 vCPUs\n    - 32+ GB RAM\n    - SSD, provisioned IOPS sized to expected write load\n  - Optional: dedicated node pool for workers / sync jobs\n\nSecurity/network:\n\n- TLS termination at your edge or ingress\n- Network egress allowed only to:\n  - the third\u2011party SaaS APIs you integrate\n  - your identity provider (for SSO, if used)\n- Optionally deploy behind a reverse proxy (Nginx/Envoy) with WAF\n\n**3. Typical installation flow (high level)**\n\nExact commands will come from StackOne\u2019s self\u2011hosted docs or installer, but the process usually looks like:\n\n1. **Prepare infrastructure**\n   - Provision the VMs/nodes according to sizing above.\n   - Install:\n     - Linux OS\n     - Docker / container runtime\n     - Kubernetes (if using K8s) and an ingress controller.\n   - Set up DNS entries for the StackOne API/UI hostnames.\n\n2. **Database and secrets**\n   - Provision Postgres (or the DB StackOne requires), preferably HA.\n   - Create database/schema and user.\n   - Generate secrets:\n     - Application secret / JWT signing keys\n     - Encryption key(s) for stored credentials\n     - Admin user bootstrap credentials\n   - Store them in:\n     - K8s Secrets (if on Kubernetes), or\n     - An external secret manager (Vault, AWS Secrets Manager, etc.), depending on their guidance.\n\n3. **Deploy StackOne services**\n   - Obtain:\n     - Docker images and tags, or\n     - Helm chart / manifests, or\n     - Installer bundle.\n   - Configure values:\n     - Database URL and credentials\n     - Base URL(s) for the API / UI\n     - TLS/ingress settings\n     - Email (if notifications needed)\n     - Logging and metrics endpoints\n   - Apply manifests / run `helm install` or `docker compose up` as instructed.\n\n4. **Run migrations and bootstrap**\n   - Execute DB migrations (often `helm` hook or a `migrate` pod).\n   - Create initial admin account.\n   - Test health:\n     - Call the health/ready endpoints on the main API.\n     - Exercise a simple `POST /mcp` or `POST /actions/rpc` locally to confirm routing.\n\n5. **Integrate with your environment**\n   - Configure SSO (OIDC/SAML) if supported.\n   - Lock down firewall rules to allow only:\n     - Internal clients (or your API gateway) to call StackOne\n     - Outbound to target providers.\n   - Configure monitoring:\n     - Collect logs (e.g., to ELK, Loki)\n     - Metrics (Prometheus/Grafana, etc.)\n\n6. **Functional validation**\n   - Set up a test account (`x-account-id`) and connect 1\u20132 providers.\n   - Confirm:\n     - MCP streaming works via `GET /mcp` (SSE).\n     - JSON\u2011RPC flows via `POST /mcp`.\n     - Proxy operations via `POST /unified/proxy`.\n     - Actions via `POST /actions/rpc`.\n\n**4. What you should do next**\n\nBecause the official, version\u2011specific hardware matrix and installation commands are not in the snippet you provided and can change over time, you should:\n\n- Request or download the **official \u201cSelf\u2011Hosted / On\u2011Prem Deployment Guide\u201d** from StackOne.\n- Ask StackOne support/sales for:\n  - Current **supported deployment options** (K8s vs VM/Compose)\n  - **Sizing recommendations** based on:\n    - Number of connected accounts\n    - Expected API volume (calls/day)\n    - Data sync frequency/volume\n  - Any **air\u2011gapped / no\u2011internet** constraints if that\u2019s your scenario.\n\nIf you share your approximate scale (number of providers, tenants/accounts, and expected daily API calls), I can give a more concrete sizing recommendation and checklist to take into that conversation.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_actions_rpc"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s policy is:\n\n- **Data retention & employee access**\n  - Customer data is retained only as long as needed to provide the service or as required by law and contractual obligations.\n  - Access to customer data by StackOne employees is:\n    - Strictly limited to those who need it for support, operations, or security.\n    - Controlled via role-based access controls and logged/monitored.\n    - Governed by internal security and confidentiality policies.\n\n- **Custom data residency guarantees**\n  - Yes. StackOne can provide **custom data residency guarantees** (for example, keeping data within specific regions/jurisdictions) when required.\n  - These guarantees are typically arranged as part of a **custom or enterprise agreement** and should be requested via sales/support so they can be documented contractually (e.g., in a DPA or MSA).",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part2",
        "stackone_paths_post_connect_sessions_authenticate_part1",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "hris_paths_get_unified_hris_locations_id_part2",
        "hris_paths_get_unified_hris_companies_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    }
  ]
}