{
  "config": "c2",
  "timestamp": "2025-12-10T21:38:19.468753",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.9367088607594937,
      "mrr": 0.7681434599156118,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.3333333333333335,
      "abstention_accuracy": 0.4
    }
  },
  "results_by_category": {
    "endpoint": {
      "count": 21,
      "avg_accuracy": 3.619047619047619,
      "retrieval_hit_rate": 0.9523809523809523
    },
    "factual": {
      "count": 21,
      "avg_accuracy": 3.1904761904761907,
      "retrieval_hit_rate": 1.0
    },
    "auth": {
      "count": 7,
      "avg_accuracy": 4.571428571428571,
      "retrieval_hit_rate": 0.8571428571428571
    },
    "schema": {
      "count": 21,
      "avg_accuracy": 3.238095238095238,
      "retrieval_hit_rate": 1.0
    },
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.111111111111111,
      "retrieval_hit_rate": 0.6666666666666666
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 3.6,
      "retrieval_hit_rate": 0.0
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The documentation does not specify an explicit default value for the `expires_in` field when creating a connect session.  \n\nWhat *is* specified is the unit:  \n- `expires_in` is expressed in **seconds** (\u201cHow long the session should be valid for in seconds\u201d).  \n\nSo:\n- **Default value:** Not documented / not specified  \n- **Unit:** Seconds",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_components_connectsessioncreate_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `GET /requests/platform-logs`, the **sort order** is controlled **not** via `filter`, but via these top\u2011level query parameters:\n\n- `order_by` (string): the field to order the results by  \n- `order_direction` (string): the direction to order the results by\n\nThe `filter` object is only described as:\n\n> Filter parameters that allow greater customisation of the list response\n\nNo specific filter properties related to sorting are defined in the provided context, and no allowed values are given for any filter fields. Therefore:\n\n- **There are no documented filter properties for controlling sort order**.\n- **Allowed values for sort control are only:**\n  - `order_by`: any supported field name (not specified in the context)\n  - `order_direction`: typically `\"asc\"` or `\"desc\"` (the context only says \u201cdirection\u201d, without enumerating the exact values).",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "lms_paths_get_unified_lms_content_part0",
        "stackone_components_platformlogspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You must use the `x-account-id` HTTP header to pass the target provider account identifier.  \n\nIf you omit this header, you can provide the same value as a query parameter named `x-account-id` in the request URL.",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_mcp",
        "stackone_paths_post_connect_sessions_part0",
        "lms_paths_post_unified_lms_content_batch"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the **STACKONE `GET /requests/logs`** endpoint (`stackone_list_logs`) to retrieve a paginated list of unified request logs.\n\nTo meet your needs:\n\n1. **Pagination & ordering query parameters**\n   - `order_by` \u2013 field to order by  \n   - `order_direction` \u2013 direction to order (`asc` / `desc`)  \n   - `page_size` \u2013 number of results per page (default 25)  \n   - `next` \u2013 cursor for the next page  \n\n2. **Filtering by HTTP method and provider**\n   - Use the `filter` **query object** to pass filter criteria, e.g.:\n     - `filter[method]=GET` (or POST/PUT/etc., depending on how your implementation expects it)\n     - `filter[provider]=some-provider-id-or-name`  \n   (Exact filter field names depend on your specific StackOne setup, but they must be sent via the `filter` query parameter.)\n\n3. **Including step logs in the same response**\n   - Use the `include` query parameter, e.g.:\n     - `include=steps` (or the documented value used by your StackOne instance to include step logs)\n\nSo, conceptually:\n\n```http\nGET /requests/logs?order_by=created_at&order_direction=desc&page_size=25&include=steps&filter[method]=GET&filter[provider]=my-provider\n```",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_platform_logs",
        "stackone_paths_post_unified_proxy_part0",
        "lms_paths_get_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the **STACKONE** endpoint:\n\n**`GET /requests/logs`** (Operation ID: `stackone_list_logs`)  \nDescription: *List Logs* \u2013 returns a paginated list of request logs.\n\n**Pagination & filtering-related query parameters available on this endpoint:**\n\n- `order_by` (string, optional): Field to order results by.  \n- `order_direction` (string, optional): Direction to order results by.  \n- `page_size` (number, optional): Number of results per page (default: 25).  \n- `next` (string, optional): Cursor for fetching the next page.  \n- `include` (string, optional): Include additional data in the response.  \n- `filter` (object, optional): Filter parameters for customizing the list response.\n\nWithin the `filter` object (by API design), you would pass criteria such as:\n\n- **Account IDs** (e.g., `filter[account_id]=...` or similar)\n- **HTTP methods** (e.g., `filter[method]=GET,POST`)\n- **Providers** (e.g., `filter[provider]=...`)\n- **Success status** (e.g., `filter[success]=true`)\n\nThe exact filter field names and structure are defined by the StackOne API\u2019s filter schema, but they are all carried via the single `filter` query parameter on **`GET /requests/logs`**.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_paths_get_requests_platform_logs",
        "lms_paths_get_unified_lms_content_part0",
        "stackone_paths_get_requests_logs_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should use the **STACKONE** endpoint:\n\n**Endpoint:** `GET /actions`  \n**Operation ID:** `stackone_list_actions_meta`\n\nThis endpoint retrieves a paginated list of all actions metadata.\n\n**Available query parameters for filtering and pagination:**\n\n- `page_size` (string, optional)  \n  - Number of results per page (default: `25`).\n\n- `next` (string, optional)  \n  - Cursor for fetching the **next page** of results.\n\n- `group_by` (string, optional)  \n  - Relation to group the results by.\n\n- `filter` (object, optional)  \n  - Actions Metadata filters (structure depends on what fields you want to filter by, e.g. provider key, name, etc.).\n\n- `include` (array, optional)  \n  - Additional related data to include in the response.",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_components_actionsmeta",
        "lms_paths_get_unified_lms_content_part0",
        "stackone_components_actionsmetapaginated",
        "stackone_paths_post_actions_rpc"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "- **Type:** `string`  \n- **Description:** *\u201cThe method of the request\u201d*  \n- **Allowed values:** Any HTTP method as a string (e.g. `\"GET\"`, `\"POST\"`, `\"PUT\"`, `\"DELETE\"`, etc.); no explicit enumeration is defined in the schema.  \n- **Default value:** Not specified (no default defined).  \n- **Nullable:** No indication that it is nullable; it is defined as a plain string without nullable/`null` in the schema.",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "ats_components_field",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_jsonrpcmessagedto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The context does not specify any restricted/enum values for the `method` field in `ProxyRequestBody`; it is simply described as:\n\n- `method (string): The method of the request`\n\nSo, based on the given documentation:\n\n- Allowed values: Any HTTP method name as a string (e.g., `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, etc.). No explicit enumeration is provided.\n- Default if omitted: No default is documented. The behavior when `method` is omitted is not defined in the provided context.",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "ats_components_field",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_proxyresponseapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For `POST /connect_sessions` (creating a connect session):\n\n**Required fields in `ConnectSessionCreate` request body:**\n- `origin_owner_id` (string) \u2013 required  \n- `origin_owner_name` (string) \u2013 required  \n\nAll other fields in `ConnectSessionCreate` (`categories`, `provider`, `provider_version`, `origin_username`, `account_id`, `expires_in`, `metadata`, `multiple`) are optional.\n\n**Allowed values for its `type` property:**\nThe `ConnectSessionCreate` schema, as given, does **not** define a `type` property, so there are no documented allowed values for `type` in this request body.  \nThe `type` field appears only in the **response** schema (`ConnectSession` / `ConnectSessionTokenAuthLink`), and its allowed values are not specified in the provided context.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsession",
        "stackone_components_connectsessiontokenauthlink"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the MCP endpoints under `/mcp` (`POST /mcp`, `GET /mcp`, `DELETE /mcp`):\n\n**Supported authentication scheme**\n\n- **HTTP Basic authentication** is supported and required for all three endpoints.\n\n**Headers related to authentication and account context**\n\nWhen sending a JSON-RPC message (`POST /mcp`) or opening/closing an MCP session (`GET /mcp`, `DELETE /mcp`), these headers can or must be included:\n\n1. **Account context**\n\n   - `x-account-id` (header, optional, string)  \n     - Account secure id for the target provider account.  \n     - Optional if `x-account-id` is instead provided as a **query parameter**.  \n   - `x-account-id` (query, optional, string)  \n     - Same meaning as above; alternative to the header version.\n\n2. **MCP session context**\n\n   - `mcp-session-id`  \n     - `POST /mcp`: optional header  \n       - **Omit** this header when calling the **initialize** method (to start a new MCP session).  \n       - **Include** this header for all **subsequent** JSON-RPC calls in that session.\n     - `GET /mcp`: **required** header  \n       - Must be included to open a dedicated SSE stream for an existing MCP session.\n     - `DELETE /mcp`: **required** header  \n       - Must be included to identify which MCP session to close.\n\n3. **Content negotiation for SSE (only for `GET /mcp`)**\n\n   - `Accept` (header, required, string)  \n     - Must be set to `text/event-stream` when opening the SSE notification stream.\n\nNo other authentication schemes (e.g., Bearer tokens, API keys) are described for these `/mcp` endpoints.",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "lms_paths_put_unified_lms_content_part0",
        "stackone_paths_post_connect_sessions_authenticate_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "There is no filter field on `GET /unified/hris/time_off_policies` that restricts results by policy type (e.g., \"vacation\" or \"sick\"), and therefore there is no associated enum schema defined for such a filter in the provided context.",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_components_timeoffbalanceresult_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_components_hriscreatetimeoffrequestdto_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You can use the `filter[type]` query parameter to filter policies by their type.\n\nThree valid values for this type filter are:\n- `vacation`\n- `sick`\n- `unpaid`",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_id_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "There is no default status value applied by this endpoint. If the `status` field is omitted in the `UpdateTaskRequestDto` payload, the task\u2019s status remains unchanged from its existing value.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_patch_unified_hris_employees_id_tasks_subresourceid",
        "hris_components_task_part0",
        "hris_components_updatetaskrequestdto",
        "hris_paths_get_unified_hris_employees_id_tasks_subresourceid_part1",
        "lms_components_writecontenttypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use this endpoint:\n\n**Endpoint:** `GET /unified/hris/employees/{id}/time_off_policies`  \n**Operation ID:** `hris_list_employee_time_off_policies`\n\nTo list all time off policies **assigned to a specific employee**, you must include:\n\n1. **Path parameter**\n   - `id` (string, required): The identifier of the employee whose assigned time off policies you want to list.\n\n2. **Header**\n   - `x-account-id` (string, required): The account identifier.\n\nNo request body is required. All other parameters (`raw`, `proxy`, `fields`, `filter`, `page`, `page_size`) are optional.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_id_part1",
        "hris_paths_get_unified_hris_time_off_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the `GET /unified/hris/employees/{id}/time_off` endpoint (`hris_list_employee_time_off_requests`) to list all employee time off requests.\n\nTo filter the results by a specific time off policy ID, use the `filter` query parameter (an object) and include the desired time off policy ID within that filter object.",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_part1",
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_components_timeoffbalanceresult_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **HRIS \u201cCreate Employee Time Off Request\u201d** endpoint:\n\n**Endpoint (per employee):**\n- `POST /unified/hris/employees/{id}/time_off`\n\n**HTTP method:**\n- `POST`\n\n**Required parameters:**\n\n1. **Header**\n   - `x-account-id` (string, required): The account identifier\n\n2. **Path**\n   - `id` (string, required): The employee\u2019s identifier\n\n3. **Request body (JSON, required)**  \n   Include at least these fields as defined for creating a time off request:\n   - `approver_id` (string): The approver ID  \n   - `status`: The status of the time off request  \n   - `type`: The type of the time off request  \n   - `start_date` (string): Start date/time (ISO8601 without timezone)  \n   - `end_date` (string): Inclusive end date/time (ISO8601 without timezone)  \n   - `start_half_day`: True if it starts halfway through the first day  \n   - `end_half_day`: True if it ends halfway through the last day  \n   - `time_off_policy_id` (string): Associated time off policy ID",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "lms_paths_get_unified_lms_content_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "lms_paths_get_unified_lms_content_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Here\u2019s what a single `Employment` object (an element of an employee\u2019s `employments` array) can contain in the HRIS API, based on the provided context.\n\n### Top\u2011level properties of `Employment`\n\nEach `Employment` object has the following top\u2011level fields:\n\n1. **`id`** (`string`)  \n   - Description: Unique identifier.  \n   - Notes: Primitive string; no wrapper schema; not marked deprecated.\n\n2. **`remote_id`** (`string`)  \n   - Description: Provider's unique identifier.  \n   - Notes: Primitive string; no wrapper schema; not marked deprecated.\n\n3. **`unified_custom_fields`** (`object`)  \n   - Description: Custom Unified Fields configured in your StackOne project.  \n   - Notes: Nested object; references a conceptual \u201ccustom fields\u201d structure but no specific schema name is given here; not marked deprecated.\n\n4. **`job_title`** (`string`)  \n   - Description: The job title of the employee.  \n   - Notes: Primitive string; not marked deprecated.\n\n5. **`pay_rate`** (`string`)  \n   - Description: The amount of compensation for the employee.  \n   - Notes: Primitive string (not a numeric type in the description); not marked deprecated.\n\n6. **`pay_period`** (`unknown`)  \n   - Description: The time period over which the pay rate is calculated.  \n   - Notes: Declared as `unknown` (can be object, array, or primitive \u2013 same wording as elsewhere in the spec).  \n   - This is a candidate for being or becoming an enum wrapper in the same style as other \u201cEnum\u201d schemas, but in the given context **no explicit enum schema name is provided**, and it is not explicitly tied to a wrapper like `PayPeriodEnum`.  \n   - Not marked deprecated.\n\n7. **`pay_frequency`** (`unknown`)  \n   - Description: How often the employee is paid.  \n   - Notes: Also typed as `unknown`; could be an enum\u2011like structure, but the provided context does **not** name a specific wrapper schema.  \n   - Not marked deprecated.\n\n8. **`pay_currency`** (`string`)  \n   - Description: The currency used for pay.  \n   - Notes: Primitive string; not marked deprecated.\n\n9. **`effective_date`** (`string`)  \n   - Description: The effective date of the employment contract.  \n   - Notes: Primitive string (assumed date string); not marked deprecated.\n\n10. **`end_date`** (`string`)  \n    - Description: The end date of employment.  \n    - Notes: Primitive string (assumed date string); not marked deprecated.\n\n11. **`grade`** (`unknown`)  \n    - Description: Represents the employee\u2019s position within the organizational hierarchy.  \n    - Notes: Typed as `unknown`; no explicit wrapper/enum schema mentioned in the provided text; not marked deprecated.\n\n12. **`employment_type`** (`unknown`)  \n    - Description: The type of employment (e.g., contractor, permanent).  \n    - Notes:\n      - In the API, there is a separate schema **`EmploymentTypeEnum`** defined with:\n        - `value` (`string`)\n        - `source_value` (`unknown`)\n        - `provider_errors` (`array of object`)\n      - Given that pattern and name, **`employment_type` is the field that conceptually uses the `EmploymentTypeEnum` wrapper schema**, even though the snippet lists its type as `unknown` at the top level.  \n      - Not marked deprecated.\n\n13. **`employment_contract_type`** (`unknown`)  \n    - Description: The employment work schedule type (e.g., \u2026).  \n    - Notes:\n      - The HRIS schema also defines **`EmploymentScheduleTypeEnum`** with:\n        - `value` (`string`)\n        - `source_value` (`unknown`)\n      - Based on naming and description (\u201cwork schedule type\u201d), this field is the one that conceptually uses the **`EmploymentScheduleTypeEnum`** wrapper schema, though it\u2019s declared generically as `unknown` in the property list.  \n      - Not marked deprecated.\n\n### Enum wrapper schemas referenced\n\nWithin this context, the enum\u2011style wrapper schemas that relate to `Employment` are:\n\n1. **`EmploymentTypeEnum`** (used by `employment_type`)  \n   - Type: `object`  \n   - Properties:\n     - `value` (`string`)\n     - `source_value` (`unknown`) \u2013 can be object, array, or primitive\n     - `provider_errors` (`array of object`)\n\n2. **`EmploymentScheduleTypeEnum`** (used by `employment_contract_type`)  \n   - Type: `object`  \n   - Properties:\n     - `value` (`string`)\n     - `source_value` (`unknown`) \u2013 can be object, array, or primitive\n\n### Deprecated fields\n\nFrom the provided context:\n\n- **No fields of the `Employment` object are explicitly described as deprecated.**  \n- None of the related enum wrapper schemas (`EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`) are described as deprecated either.\n\nSo, a single `Employment` object can contain all 13 properties listed above. The ones that conceptually use enum wrapper schemas are:\n\n- `employment_type` \u2192 `EmploymentTypeEnum`\n- `employment_contract_type` \u2192 `EmploymentScheduleTypeEnum`\n\nAll others are either primitives, `object`, or `unknown`, and none are noted as deprecated in the given text.",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employmenttypeenum",
        "stackone_paths_post_unified_proxy_part1",
        "hris_components_employment_part0",
        "lms_paths_put_unified_lms_content_part0",
        "hris_components_employmentscheduletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `EmployeesPaginated` response schema:\n\n**Required fields:**\n- `data`  \n  - **Type:** array of object  \n  - **Required:** Yes  \n  - **Purpose:** Contains the list of employee records for the current page.\n\n**Other properties:**\n\n1. `next_page`  \n   - **Type:** string  \n   - **Purpose:** Represents the identifier or token for the next page of results (often used for cursor-based pagination). It lets the client know how to request the subsequent page.\n\n2. `next`  \n   - **Type:** string  \n   - **Purpose:** Typically a fully-qualified URL or path to retrieve the next page of results. It provides a direct link the client can call to get the next page.\n\n3. `raw`  \n   - **Type:** array of object  \n   - **Purpose:** Holds the original/raw data objects as returned from the underlying HRIS source or integration, useful for debugging, auditing, or accessing non-normalized fields.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employeespaginated",
        "hris_components_createhrisbenefit",
        "hris_components_hrisjobspaginated",
        "hris_components_shiftbreak",
        "hris_components_employmentspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In `HrisCreateEmployeeRequestDto`, the following fields are used:\n\n- **Gender**  \n  - Field: `gender`  \n  - Enum schema type: `HrisEmployeeGender` (or equivalent employee-gender enum defined in the HRIS schemas)\n\n- **Preferred language**  \n  - Field: `preferred_language`  \n  - Enum schema type: `HrisEmployeePreferredLanguage` (or equivalent preferred-language enum)\n\n- **Ethnicity**  \n  - Field: `ethnicity`  \n  - Enum schema type: `HrisEmployeeEthnicity` (or equivalent employee-ethnicity enum)",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hriscreateemploymentrequestdto_part0",
        "hris_components_hrisupdateemploymentrequestdto_part0",
        "hris_components_createemployeeemploymentapimodel_part0",
        "hris_components_employment_part0",
        "hris_components_hriscreateemployeerequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Authentication scheme: HTTP Basic  \nRequired header: `x-account-id` (string, required)",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_id_part0",
        "lms_paths_put_unified_lms_content_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "lms_paths_post_unified_lms_content_batch",
        "hris_paths_get_unified_hris_time_off_types_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The query parameter is `updated_after`, and its value must be a string representing a datetime (typically an ISO 8601\u2013formatted timestamp).",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_job_postings_id_part1",
        "ats_paths_get_unified_ats_job_postings_id_part0",
        "ats_components_jobpostingstatusenum",
        "ats_paths_get_unified_ats_jobs_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The ATS `GET /unified/ats/offers` endpoint uses **cursor-based pagination**, and the cursor input query parameter is named **`next`** (i.e., `x-speakeasy-pagination.cursor.name = \"next\"`).",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_offerspaginated",
        "ats_paths_get_unified_ats_lists_part0",
        "ats_paths_get_unified_ats_offers_part0",
        "crm_paths_get_unified_crm_lists_part0",
        "ats_paths_get_unified_ats_interviews_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The supported `filter.change_type` enum values are:\n\n- `application.created`\n- `application.updated`\n- `application.deleted`\n- `application.rejected`\n- `application.hired`",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_components_applicationchanges",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_paths_get_unified_ats_applications_part0",
        "ats_components_applicationchangetypeenum",
        "ats_paths_get_unified_ats_applications_id_changes_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use an HTTP GET request to the job postings list endpoint, with pagination, field selection, and date filtering via query parameters.\n\n**HTTP method:**  \n`GET`\n\n**Path:**  \n`/unified/ats/job-postings`  \n(or the equivalent job-postings list endpoint in your API; here we\u2019re targeting the \u201clist of job postings\u201d described in the context)\n\n**Key query parameters:**\n\n- `page` (optional, string): Page number to fetch, e.g. `page=1`\n- `page_size` (optional, string): Page size, e.g. `page_size=25`\n- `include` (optional, string): Comma\u2011separated list of fields to include in the response, e.g.  \n  `include=id,title,status`\n- `updated_after` (optional, string): Only return postings updated after a given date, e.g.  \n  `updated_after=2024-01-01T00:00:00Z`\n\n**Example request:**\n\n```http\nGET /unified/ats/job-postings?page=1&page_size=25&include=id,title,status&updated_after=2024-01-01T00:00:00Z HTTP/1.1\nHost: api.yourprovider.com\nAuthorization: Basic <credentials>\nAccept: application/json\n```\n\nIf you don\u2019t need the date filter, omit `updated_after`:\n\n```http\nGET /unified/ats/job-postings?page=1&page_size=25&include=id,title,status HTTP/1.1\n```",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_part1",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "ats_paths_get_unified_ats_job_postings_part1",
        "lms_paths_get_unified_lms_content_part0",
        "hris_paths_get_unified_hris_jobs_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS endpoint:\n\n`GET /unified/ats/applications/{id}/notes`\n\nYou need to include the application\u2019s identifier as the `{id}` path parameter in the request URL.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part0",
        "stackone_paths_get_requests_logs_id_part1",
        "ats_paths_get_unified_ats_candidates_id_notes_subresourceid_part0",
        "lms_paths_get_unified_lms_content_id_part1",
        "ats_paths_get_unified_ats_applications_id_notes_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the `POST /applications/{id}/documents/upload` endpoint (operation ID: `ats_upload_application_document`) to upload a base64\u2011encoded resume for an existing application.\n\nIt requires a JSON request body matching the `AtsDocumentsUploadRequestDto` schema:\n\n```json\n{\n  \"name\": \"resume.pdf\",              // string: filename of the file to upload\n  \"file_format\": \"pdf\",              // file format (type: unknown in schema)\n  \"content\": \"<base64-encoded data>\",// string: base64 encoded content of the file\n  \"category_id\": \"resume-category\",  // string: categoryId of the document\n  \"path\": \"/resumes/2025/\",          // string: upload path\n  \"confidential\": false,             // confidentiality level (type: unknown)\n  \"category\": \"Resume\"               // category associated with the file (type: unknown)\n}\n```",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atsdocumentsuploadrequestdto",
        "ats_components_atscreateapplicationrequestdto",
        "ats_components_atscreatecandidaterequestdto",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part1",
        "ats_components_atsupdatecandidaterequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema is defined as:\n\n**Type:** `object`  \n**Description:** Schema for BadRequestResponse\n\n### Fields and required status\n\n1. **statusCode** (`number`, **required**)  \n   - **Purpose:** The HTTP status code returned by the API for the bad request (e.g., 400). It indicates the type of error at the HTTP protocol level.\n\n2. **message** (`string`, **required**)  \n   - **Purpose:** A human-readable error message explaining why the request was considered bad (e.g., validation failure, missing parameter).\n\n3. **timestamp** (`string`, **required**)  \n   - **Purpose:** The time at which the error occurred, allowing clients to log, trace, or correlate the error with other events.\n\n4. **data** (`unknown`, optional)  \n   - **Purpose:** Additional error details. This can hold structured information (such as validation errors, offending field values, or diagnostic data) to help the client understand and fix the issue.\n\n5. **provider_errors** (`array` of `object`, optional)  \n   - **Purpose:** A list of provider-specific errors, useful when the ATS API is acting as a proxy or integrator to underlying providers and needs to expose their specific error messages or codes.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "ats_components_badrequestresponse",
        "lms_paths_get_unified_lms_content_part0",
        "ats_components_unauthorizedresponse",
        "lms_paths_get_unified_lms_content_id_part1",
        "crm_components_badrequestresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `AtsUpdateCandidateRequestDto` schema is defined as follows (for updating a candidate):\n\n**Type:** `object`  \n**Description:** Schema for AtsUpdateCandidateRequestDto  \n\n### Fields and Types\n\n- `passthrough` \u2014 `object`  \n  Value to pass through to the provider.\n\n- `unified_custom_fields` \u2014 `object`  \n  Custom Unified Fields configured in your StackOne project.\n\n- `name` \u2014 `string`  \n  Candidate name.\n\n- `first_name` \u2014 `string`  \n  Candidate first name.\n\n- `last_name` \u2014 `string`  \n  Candidate last name.\n\n- `email` \u2014 `string`  \n  Candidate email.\n\n- `emails` \u2014 `array of object`  \n  List of candidate emails.\n\n- `social_links` \u2014 `array of object`  \n  List of candidate social links.\n\n- `phone` \u2014 `string`  \n  Candidate phone number.\n\n- `phone_numbers` \u2014 `array of object`  \n  List of candidate phone numbers including the type of the number when available.\n\n- `company` \u2014 `string`  \n  Candidate company.\n\n- `title` \u2014 `string`  \n  Candidate title.\n\n- `application_ids` \u2014 `array of string`  \n  List of candidate application IDs.\n\n- `hired_at` \u2014 `string`  \n  Candidate hired date.\n\n- `country` \u2014 `string`  \n  Candidate country.\n\n*(The context ends with \u201c... and\u201d, so there may be additional fields in the full spec that are not shown here.)*\n\n### Deprecated or Nullable Properties\n\nThe provided context does **not** mark any of these properties as deprecated or nullable. There are:\n\n- **No fields explicitly labeled as deprecated** in the snippet you provided.\n- **No explicit `nullable: true` indicators** or equivalent notes in the given description.\n\nSo, based on the given context alone, none of the listed properties are documented as deprecated or nullable.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atscreateapplicationrequestdto",
        "ats_components_atsupdatecandidaterequestdto_part0",
        "lms_paths_put_unified_lms_content_part0",
        "ats_components_atsupdatecandidatesassessmentsresultsrequestdto",
        "lms_paths_get_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "For `AttachmentContentType` in the `AtsUpdateBackgroundCheckResultRequestDto` schema:\n\n- The possible enum values for `AttachmentContentType.value` are **not specified** in the provided context beyond being a `string`; they are implementation-defined by the ATS API and not listed here.\n- The provider\u2019s original content type value is exposed via the **`source_value`** property of `AttachmentContentType`.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "lms_components_writecontenttypeenum",
        "lms_components_contenttypeenum",
        "ats_components_attachmentcontenttype",
        "ats_components_field",
        "ats_components_atsupdatebackgroundcheckresultrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id` (string): the account identifier.",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_patch_unified_ats_background_checks_orders_id_result_part0",
        "lms_paths_put_unified_lms_content_part0",
        "ats_paths_post_unified_ats_background_checks_orders",
        "lms_paths_post_unified_lms_content_batch",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory request body field is `learning_object_id`, which represents the identifier of the learning object (e.g., course, module) that the user is being assigned to.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_id_part1",
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory field is `learning_object_external_reference`. It represents the external reference (main identifier) of the learning object that the assignment is being created for.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_id_part1",
        "lms_components_assignment_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is **`learning_object_external_reference`**, which is described as the main identifier for creating assignments.",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_components_assignment_part0",
        "lms_components_assignment_part1",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You should call the **`GET /unified/lms/users/{id}/assignments`** endpoint (operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment-type learning records for a specific user**.\n\nTo filter those assignments by `status` and `updated_after`, use the **`filter` query parameter** (which is an object for the LMS Assignment Filter). For example, conceptually:\n\n- `filter[status]` \u2013 to filter by assignment status (e.g., `pending`, `in_progress`, `completed`, depending on the API\u2019s allowed values).\n- `filter[updated_after]` \u2013 to return only assignments updated after a given timestamp.\n\nYou can also use:\n\n- `page` \u2013 to select the page number of results.\n- `page_size` \u2013 if supported for this user endpoint (it is defined for the general `/unified/lms/assignments` endpoint and may also be available here, depending on the full spec).\n\nSo, in summary:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n- **Key query parameters for your use case:**\n  - `filter[status]=...`\n  - `filter[updated_after]=...`\n  - `page=...`\n  - (optionally) `page_size=...` if supported.",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_assignments_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **`GET /unified/lms/users/{id}/assignments`** endpoint (operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment learning records for a specific user**.\n\nTo filter those assignments by status (e.g. `completed`), use the **`filter`** query parameter, providing an appropriate **LMS Assignment Filter** that includes the status condition (such as `completed`).",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_users_id_completions_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **`GET /unified/lms/users/{id}/completions`** endpoint (operation ID: `lms_list_user_completions`).\n\n**Required parameters:**\n1. **Path parameter**\n   - `id` \u2013 the identifier of the user whose completions you want to retrieve.\n\n2. **Header**\n   - `x-account-id` \u2013 the account identifier.\n\nAuthentication must be provided via **HTTP Basic** as specified.",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_completions_part0",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_get_unified_lms_completions_id_part1",
        "lms_paths_post_unified_lms_users_id_completions_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is:\n\n- **learning_object_external_reference** (string) \u2013 This is the external reference of the learning object associated with the completion and is the main identifier used when creating a completion.\n\nTwo optional fields you can include to capture completion details are, for example:\n\n- **completed_at** (string) \u2013 The date the content was completed.  \n- **time_spent** (string) \u2013 The time spent completing the learning object, in ISO 8601 duration format.",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_components_completion_part1",
        "lms_components_completion_part0",
        "lms_components_completionresult_part1",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In the `LmsCreateAssignmentRequestDto` request body, the only required field is:\n\n- **`learning_object_external_reference` (string, required)**\n\n**Purpose:**  \n`learning_object_external_reference` is the main identifier used to link the new assignment to a specific learning object. When you create an assignment for a user, this field tells the LMS which learning object (course, module, etc.) the assignment should be associated with.",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_lmscreateassignmentrequestdto",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0",
        "lms_paths_get_unified_lms_users_id_assignments_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In `LmsCreateAssignmentRequestDto` for POST `/unified/lms/users/{id}/assignments`:\n\n**Required fields:**\n- `external_reference` (also referred to as `learning_object_external_reference` in the description) \u2013 required  \n- Other body fields (`learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `passthrough`) are optional unless an integration explicitly requires `learning_object_id`.\n\n**Purpose of `learning_object_external_reference` (`external_reference`):**\nIt is the **main identifier of the learning object** that the assignment links the user to. When you create an assignment, this external reference tells the system *which* learning object (course/module/etc.) the user is being assigned, and is the primary key used for creating and mapping assignments to that learning object across systems.",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part3",
        "lms_paths_get_unified_lms_assignments_id_part3",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_assignments_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must include:\n\n1. **Authentication:** HTTP Basic auth (username/password in the `Authorization: Basic <base64-credentials>` header).  \n2. **Required header:** `x-account-id` (string) \u2013 the account identifier.\n\nBoth are specified in the OpenAPI description under:\n\n- The **\"Authentication: HTTP Basic\"** section, and  \n- The **Parameters** list, where `x-account-id` is defined as a required header parameter (`x-account-id (header, required, string): The account identifier`).",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_post_unified_lms_users_id_completions_part0",
        "lms_paths_put_unified_lms_content_part0",
        "lms_paths_post_unified_lms_users_id_assignments_part0",
        "lms_paths_post_unified_lms_content_batch",
        "lms_paths_get_unified_lms_courses_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `page` query parameter is marked as deprecated for pagination, and you should instead use the newer cursor-based `next` parameter.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_get_unified_iam_policies_id_part1",
        "stackone_paths_get_mcp",
        "iam_paths_get_unified_iam_policies_id_part0",
        "stackone_paths_delete_mcp"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `fields` query parameter, and include the related objects you want expanded as a comma\u2011separated list. For example:\n\n`GET /unified/iam/users?fields=roles,groups`\n\nThis tells the API to return full `roles` and `groups` objects in the response instead of just their identifiers.",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "lms_paths_get_unified_lms_users_part0",
        "lms_paths_post_unified_lms_content_batch"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the `raw` query parameter. Its default value is `false` (i.e., only the mapped result is returned unless you set `raw=true`).",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "lms_paths_get_unified_lms_users_part0",
        "ats_paths_get_unified_ats_users_part0",
        "lms_paths_get_unified_lms_content_id_part1",
        "iam_paths_get_unified_iam_groups_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the IAM endpoint:\n\n- **Endpoint:** `GET /unified/iam/groups`  \n- **Required header:** `x-account-id` (the account identifier)",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_groups_part0",
        "lms_paths_put_unified_lms_content_part0",
        "iam_paths_get_unified_iam_groups_id_part0",
        "lms_paths_post_unified_lms_content_batch",
        "iam_components_iamgroupspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the IAM endpoint:\n\n**Endpoint:** `PATCH /unified/iam/users/{id}`  \n**Operation ID:** `iam_update_user`\n\n### Mandatory parameters\n\n1. **Path parameter**\n   - `id` (string, required): The unique identifier of the user to update.\n\n2. **Header**\n   - `x-account-id` (string, required): The account identifier.\n\n3. **Authentication**\n   - HTTP Basic authentication must be provided.\n\n### Request body schema (JSON)\n\nThe body must follow **IamUpdateUserRequestDto**. To update the primary email you must at least include:\n\n- `primary_email_address` (string): New primary email address of the user.\n\nThe full available fields in the body are:\n\n- `primary_email_address` (string): Primary email address of the user (generally a work email).\n- `first_name` (string)\n- `last_name` (string)\n- `name` (string): Full name or display name.\n- `username` (string)\n- `is_bot_user` (unknown): Indicates if the user is a bot or service user.\n- `status` (unknown)\n- `passthrough` (object): Value to pass through to the provider.",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iamupdateuserrequestdto",
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamuser",
        "iam_components_iamuserresult_part0",
        "lms_paths_put_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the IAM endpoint:\n\n**GET `/unified/iam/policies`**  \n(Operation ID: `iam_list_policies`)\n\nThis endpoint returns a paginated list of policies, using the `IamPoliciesPaginated` schema (with `data`, `next_page`, `next`, and optional `raw`).\n\nYou can control pagination and filtering with these query parameters:\n\n- **`page` (string, optional)** \u2013 The page number of the results to fetch.  \n- **`page_size` (string, optional)** \u2013 Number of results per page (default: 25).  \n- **`next` (string, optional)** \u2013 Cursor/token for fetching the next page (works with the `next` field from the `IamPoliciesPaginated` response).  \n\nFiltering/customization parameters:\n\n- **`filter` (object, optional)** \u2013 Filter parameters to customize the list response.  \n- **`fields` (string, optional)** \u2013 Comma-separated list of fields to include in the response; if omitted, all fields are returned.  \n- **`raw` (boolean, optional)** \u2013 If `true`, returns the raw provider response in addition to the mapped result (default: `false`).  \n- **`proxy` (object, optional)** \u2013 Pass-through parameters to the underlying provider, nested under the `proxy` key.\n\nRequired header:\n\n- **`x-account-id` (string, header, required)** \u2013 The account identifier.",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "lms_paths_get_unified_lms_content_part0",
        "iam_components_iampoliciespaginated",
        "lms_paths_get_unified_lms_content_id_part1",
        "iam_paths_get_unified_iam_policies_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, when you delete a user and a response body is returned, it follows the `DeleteResult` schema, which contains:\n\n- `statusCode` (number) \u2013 **required**\n- `message` (string) \u2013 **required**\n- `timestamp` (string) \u2013 **required**",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_delete_unified_iam_users_id",
        "iam_components_iamuserresult_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_deleteresult",
        "hris_components_deleteresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "When a user is successfully deleted via `DELETE /unified/iam/users/{id}`, the IAM API returns a `DeleteResult` object with the following properties:\n\n- `statusCode` (number) \u2013 **required**\n- `message` (string) \u2013 **required**\n- `timestamp` (string) \u2013 **required**\n\nAll three properties in `DeleteResult` are required.",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iamuserresult_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_deleteresult",
        "iam_components_iamuser",
        "iam_paths_delete_unified_iam_users_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, the `IamPermissionTypeEnum.value` field holds a normalized string for the permission type, such as:\n\n- `read`\n- `read_write`\n- `delete`\n- (and similar standardized types, e.g., other CRUD-style actions)\n\nThe `source_value` field stores the original, raw value exactly as provided by the underlying identity provider. This means `value` is the unified/normalized permission type, while `source_value` is the provider-specific code or label from the source system.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iampermission",
        "hris_components_tasktypeenum",
        "iam_components_iampermissiontypeenum",
        "iam_components_iamresourcetypeenum",
        "hris_components_customfielddefinition"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints use **HTTP Basic authentication**, and you must include the required header:\n\n- **`x-account-id`** (string): The account identifier.\n\nBoth the Basic Auth credentials and the `x-account-id` header are required for the request to be authorized.",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_components_iamupdateuserrequestdto",
        "iam_paths_get_unified_iam_users_id_part0",
        "lms_paths_put_unified_lms_content_part0",
        "iam_paths_get_unified_iam_roles_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the HTTP status codes explicitly configured to trigger the `x-speakeasy-retries` backoff strategy are:\n\n- **408** (Request Timeout)  \n- **429** (Too Many Requests)  \n- **5XX** (all 5xx server error responses)",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "stackone_paths_post_connect_sessions_authenticate_part1",
        "lms_paths_get_unified_lms_content_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the deprecated query parameter is:\n\n- **`updated_after`** \u2013 it takes a **string containing a date** (e.g., `\"2024-01-01\"`).",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_users_part1",
        "crm_paths_get_unified_crm_contacts_id_part0",
        "ats_paths_get_unified_ats_jobs_id_application_stages_part2",
        "crm_paths_get_unified_crm_contacts_part0",
        "lms_paths_get_unified_lms_users_id_completions_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies that responses with HTTP status codes **408**, **429**, and any **5XX** status codes are retried using the **backoff** strategy.",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "lms_paths_get_unified_lms_content_id_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "stackone_paths_post_connect_sessions_part0",
        "crm_paths_patch_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You should call the **CRM endpoint**:\n\n**Endpoint:** `GET /unified/crm/contacts`  \n**Operation ID:** `crm_list_contacts`\n\n**Query parameters:**\n\n- **Update filter:**  \n  - `updated_after` \u2014 pass a date/time string to return only contacts updated after this timestamp.\n\n- **Cursor-based pagination:**  \n  - `next` \u2014 the unified cursor returned from the previous response; send it to get the next page.  \n  - (Optionally, `page` and `page_size` can be used for page-based pagination if supported by your usage.)",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "lms_paths_get_unified_lms_content_part0",
        "lms_paths_get_unified_lms_content_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the `GET /contacts/{id}` endpoint (StackOne CRM) to retrieve a single contact by its StackOne contact ID.\n\nYou must include the following header with the account identifier:\n- `x-account-id: <YOUR_ACCOUNT_ID>`",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part2",
        "stackone_paths_get_accounts_id",
        "lms_paths_get_unified_lms_content_id_part1",
        "stackone_paths_get_accounts_part0",
        "crm_components_contact_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the `GET /unified/crm/custom_field_definitions/contacts` endpoint (operation ID: `crm_list_contact_custom_field_definitions`) to retrieve all custom field definitions for contacts.\n\nCursor\u2011based pagination is controlled by the `page` query parameter.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part1",
        "hris_paths_get_unified_hris_custom_field_definitions_employees_part0",
        "ats_paths_get_unified_ats_custom_field_definitions_candidates_id_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "In the `Create Contact` (`crm_create_contact`) endpoint, the JSON request body uses the `CrmCreateContactRequestDto` schema. You can include the following fields:\n\n- `first_name` (string): The contact\u2019s first name  \n- `last_name` (string): The contact\u2019s last name  \n- `company_name` (string): The contact\u2019s company name  \n- `emails` (array of string): List of the contact\u2019s email addresses  \n- `phone_numbers` (array of string): List of the contact\u2019s phone numbers  \n- `deal_ids` (array of string): List of associated deal IDs  \n- `account_ids` (array of string): List of associated account IDs  \n- `custom_fields` (array of object): Custom fields for the contact  \n- `passthrough` (object): An arbitrary object whose content is passed through to the underlying provider as-is.\n\nPurpose of `passthrough`:\n- It allows you to send provider-specific or additional parameters that are not part of the standardized schema.  \n- The API will forward the contents of `passthrough` directly to the CRM provider, enabling you to use features or fields unique to that provider while still using the unified API.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "ats_paths_get_unified_ats_applications_id_part1",
        "hris_components_hrisinviteemployeerequestdto",
        "hris_paths_get_unified_hris_employees_id_part1",
        "crm_paths_post_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "A successful `200` response from `GET /unified/crm/contacts` returns a `ContactsPaginated` object with this structure:\n\n```json\n{\n  \"next_page\": \"string or null\",\n  \"next\": \"string or null\",\n  \"data\": [\n    {\n      /* normalized/mapped contact object(s) */\n    }\n  ],\n  \"raw\": [\n    {\n      /* raw provider-specific contact payload(s), if requested */\n    }\n  ]\n}\n```\n\nField details:\n\n- **`data`** (array, required):  \n  The list of mapped/normalized contact objects returned for this page. Each item is a contact in StackOne\u2019s unified CRM schema.\n\n- **`next_page`** (string):  \n  A pagination token or page identifier for the *next page* of results. Use this to request the next page (depending on how the API expects it: often via `page` or `next` query params).\n\n- **`next`** (string):  \n  Another pagination cursor/continuation token that can be passed directly to the `next` query parameter on subsequent list calls to continue where this response left off.\n\n- **`raw`** (array of objects):  \n  Present when you call the endpoint with `raw=true`. Contains the original provider-specific contact payloads, aligned with the items in `data`. This allows you to see the untransformed source data from the underlying CRM system.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "lms_paths_put_unified_lms_content_part0",
        "crm_components_contactspaginated",
        "lms_paths_post_unified_lms_content_batch",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "For the CRM API, when using `CrmCreateContactRequestDto` in the request body:\n\n**1. `custom_fields`**\n\n- **Type:** array of object  \n- **Structure:**  \n  ```json\n  \"custom_fields\": [\n    { /* custom field object 1 */ },\n    { /* custom field object 2 */ }\n  ]\n  ```\n- Each element is a JSON object. The schema of each custom field object is not further constrained in the provided context, so it can contain key\u2013value pairs as supported by your provider (e.g., strings, numbers, booleans, etc.) within normal JSON rules.\n\n**2. `passthrough`**\n\n- **Type:** object  \n- **Structure:**  \n  ```json\n  \"passthrough\": {\n    \"some_key\": \"some value\",\n    \"another_key\": 123,\n    \"nested\": { \"flag\": true }\n  }\n  ```\n- It is a free-form JSON object whose contents are passed directly through to the provider. Keys and values can be any valid JSON types (string, number, boolean, object, array, null), as supported by the provider.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_components_contact_part0",
        "crm_paths_post_unified_crm_contacts_part0",
        "hris_components_hrisinviteemployeerequestdto",
        "lms_paths_put_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id: <your account identifier>`",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part0",
        "lms_paths_put_unified_lms_content_part0",
        "crm_paths_get_unified_crm_accounts_id_part0",
        "lms_paths_post_unified_lms_content_batch",
        "crm_paths_get_unified_crm_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Described purpose:** It is *\u201cThe account identifier\u201d* and must be included on every request to list campaigns.",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "lms_paths_get_unified_lms_content_id_part1",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "lms_paths_put_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The `x-speakeasy-pagination` configuration treats the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_components_smstemplatespaginated",
        "hris_components_timeoffbalances_part1",
        "marketing_paths_get_unified_marketing_templates_email_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and it must be provided as a **string containing a date** (i.e., \u201cUse a string with a date to only select results updated after that given date\u201d).",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part1",
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "ats_paths_get_unified_ats_jobs_id_application_stages_part2",
        "lms_paths_get_unified_lms_content_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **MARKETING** endpoint:\n\n**Endpoint to use:**  \n`PATCH /unified/marketing/templates/push/{id}`  \n**Operation ID:** `marketing_update_push_template`  \n\n### Required parameters\n- **Header**\n  - `x-account-id` (string, required): The account identifier.\n- **Path**\n  - `id` (string, required): The identifier of the push template to update.\n\n### Required request body (JSON)\nThe body is required and has the following schema:\n\n```json\n{\n  \"name\": \"string\",\n  \"tags\": [\"string\"],\n  \"messages\": [\n    {\n      /* object structure per your integration */\n    }\n  ],\n  \"passthrough\": {\n    /* arbitrary key-value pairs to pass to provider */\n  }\n}\n```\n\nFields:\n- `name` (string)\n- `tags` (array of string)\n- `messages` (array of object)\n- `passthrough` (object): value to pass through to the provider.",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_paths_get_unified_marketing_templates_push_id_part1",
        "lms_paths_put_unified_lms_content_part0",
        "marketing_components_pushtemplate"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "To update an existing push notification template, use:\n\n- **Endpoint:** `PATCH /unified/marketing/templates/push/{id}`\n- **HTTP Method:** `PATCH`\n- **Required header parameter:**\n  - `x-account-id` (string) \u2013 The account identifier\n- **Required path parameter:**\n  - `id` (string) \u2013 The identifier of the push template to update",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "lms_paths_put_unified_lms_content_part0",
        "marketing_paths_post_unified_marketing_templates_push",
        "stackone_paths_post_actions_rpc",
        "marketing_paths_get_unified_marketing_templates_push_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to retrieve a paginated list of SMS templates.  \n\nThe required header to identify the account is:\n\n- `x-account-id` (string)",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_post_unified_marketing_templates_sms",
        "marketing_paths_patch_unified_marketing_templates_sms_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "When creating a new content block with `MarketingCreateContentBlocksRequestDto`, you can include the following fields in the request body:\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (Stackone enum / unknown)\n- `passthrough` (object)\n\nPurpose of specific fields:\n\n- `type`: This is a Stackone enum that identifies the **type of content block** (for example, text, image, HTML, etc., depending on how the platform defines its content block types). It tells the system how to interpret and render the `content`.\n\n- `passthrough`: This is an **opaque object passed through to the provider** unchanged. It allows you to send provider-specific or custom metadata/configuration that Stackone does not interpret itself but forwards to the underlying marketing provider.",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "lms_paths_post_unified_lms_content_batch",
        "marketing_components_marketingcreatetemplaterequestdto",
        "lms_paths_put_unified_lms_content_part2",
        "marketing_components_marketingcreateinapptemplaterequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `POST /unified/marketing/content_blocks`, the JSON request body can include the following fields (all defined by `MarketingCreateContentBlocksRequestDto`):\n\n- `name` (string)  \n- `tags` (array of string)  \n- `content` (string)  \n- `type` (unknown): Stackone enum identifying the type of content block  \n- `passthrough` (object): Arbitrary provider-specific data to pass through\n\nRegarding the `type` field: it is described only as a \u201cStackone enum identifying the type of content block,\u201d but the actual set of allowed enum values is **not provided** in the given context. You would need to refer to the broader Stackone/Marketing API schema or documentation to see the exact list of permitted values for `type`.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_post_unified_marketing_content_blocks",
        "lms_components_writecontenttypeenum",
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "lms_paths_post_unified_lms_content_batch",
        "marketing_paths_patch_unified_marketing_content_blocks_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "In the `PushTemplatesPaginated` response from `GET /unified/marketing/templates/push`, the **only required field** is:\n\n- **`data`** (required)  \n  - **Type:** array of objects  \n  - **Items:** each item is a **`PushTemplate`** object  \n  - **Schema reference for items:** `PushTemplate` (from the MARKETING API)",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_pushtemplatespaginated",
        "ats_components_field",
        "marketing_components_pushtemplate",
        "lms_paths_get_unified_lms_content_id_part1",
        "marketing_paths_get_unified_marketing_templates_push_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You must use **HTTP Basic authentication**, and you must include the **`x-account-id` header** with the account identifier to provide the account context.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "lms_paths_put_unified_lms_content_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part0",
        "lms_paths_post_unified_lms_content_batch",
        "marketing_paths_get_unified_marketing_templates_email_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The APIs in the provided context that support listing resources with a `filter.updated_after` parameter are:\n\n1. **Scheduled Interviews API (ATS context implied)**\n   - Parameter: `filter.updated_after`\n   - Type: string\n   - Format: Date as a string: \u201cUse a string with a date to only select results updated after that given date\u201d\n\n2. **HRIS \u2013 ShiftBreak API**\n   - Parameter: `filter.updated_after`\n   - Type: string\n   - Format: Date as a string: \u201cUse a string with a date to only select results updated after that given date\u201d\n\n3. **Learning \u2013 Completion API**\n   - Parameter: `filter.updated_after`\n   - Type: string\n   - Format: Date as a string: \u201cUse a string with a date to only select results updated after that given date\u201d\n\n4. **Application Document Categories API**\n   - Parameter: `filter.updated_after`\n   - Type: string\n   - Format: Date as a string: \u201cUse a string with a date to only select results updated after that given date\u201d\n\nIn all sampled APIs above, `filter.updated_after` is a **query** parameter of type **string**, representing a **date string** used to return only results updated after the specified date.",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part2",
        "hris_components_shiftbreak",
        "ats_paths_get_unified_ats_custom_field_definitions_applications_part1",
        "lms_components_completion_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "For both APIs, pagination is controlled with the same set of query parameters, but they\u2019re described slightly differently, and both support cursor-based pagination in the response.\n\n**IAM \u2013 List Users (`GET /unified/iam/users`)**\n\n**Request-side pagination parameters:**\n- `page` (query, optional, string): Page number of results to fetch\n- `page_size` (query, optional, string): Number of results per page (default 25)\n- `next` (query, optional, string): The unified cursor  \n  \u2192 This is the cursor token you pass back to continue from where the last page ended.\n\n**Response-side cursor / pagination representation:**\n- `next_page` (string): Indicates the next page number (or reference to a next page)\n- `next` (string): Cursor token for the next page\n- `data` (array of object, required)\n- `raw` (array of object)\n\n`next` in the response is the cursor you use in the `next` query parameter on the next request.\n\n---\n\n**CRM \u2013 List Contacts (`GET /unified/crm/contacts`)**\n\n**Request-side pagination parameters:**\n- `page` (query, optional, string): Page number of results to fetch\n- `page_size` (query, optional, string): Number of results per page (default 25)\n- `next` (query, optional, string): The unified cursor  \n  \u2192 Same role as in IAM: pass this to get the next chunk of results.\n\n**Response-side cursor / pagination representation (ContactsPaginated schema):**\n- `next_page` (string)\n- `next` (string)\n- `data` (array of object, required)\n- `raw` (array of object)\n\nAgain, `next` in the response is the cursor token you pass via the `next` query parameter on subsequent calls.\n\n---\n\n**Comparison summary**\n\n- **Controlling pagination (request)**: Both IAM and CRM use the same parameters: `page`, `page_size`, and `next`.\n- **Cursor-based pagination (response)**: Both return:\n  - `next`: the cursor token for the next page (used with the `next` query parameter)\n  - `next_page`: a page reference (typically page number), for page-based navigation.",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contactspaginated",
        "hris_paths_get_unified_hris_employees_id_employments_subresourceid_part2",
        "crm_paths_get_unified_crm_contacts_part1",
        "iam_paths_get_unified_iam_users_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "For HRIS employee document downloads:\n\n- **Response media type:**  \n  The `GET /unified/hris/employees/{id}/documents/{subResourceId}/download` endpoint returns:\n  - `data` as **binary file data** (effectively an `application/octet-stream`-style response).\n  - `headers` as a separate `headers` object in the JSON response that carries download-related HTTP headers.\n\n- **Response schema for the download:**\n  ```yaml\n  {\n    \"headers\": <unknown type, required>,  # download-related headers\n    \"data\": string (required)            # file data in binary format\n  }\n  ```\n\nFor file metadata:\n\n- The schema that exposes fields such as `remote_url` and `file_format` is the **HRIS File / Document metadata models**:\n  - `HrisDocumentResult.data` (and its inner `HrisDocumentApiModel`)\n  - Also the `File` schema (same structure)\n  \n  These contain, among others:\n  - `id`: Unique identifier\n  - `remote_id`: Provider\u2019s identifier\n  - `name`: The name of the file\n  - `category` / `category_id`\n  - `created_at`, `updated_at`\n  - `remote_url`: URL where the file content is located\n  - `file_format`: The file format of the file\n  - `type`: The content type of the document (in `HrisDocumentResult`/`HrisDocumentApiModel`)\n  - `unified_custom_fields`: Custom fields\n\nIn an IAM context, the **`File`-like schema with `remote_url` and `file_format`** is what you would use to store or query file metadata that can be correlated to HRIS document downloads (same core fields: `id`, `remote_id`, `name`, `remote_url`, `file_format`, `category_id`, timestamps).\n\n### How to combine them for auditing\n\n1. **Capture the download event from HRIS:**\n   - From the `hris_download_employee_document` response, store:\n     - Path parameters: `id` (employee identifier) and `subResourceId` (document id).\n     - Download-specific `headers` (e.g., `Content-Type`, `Content-Disposition`, size, etc.).\n     - The fact that the binary `data` was delivered, with timestamp and caller identity (from your own access logs).\n\n2. **Look up or store file metadata from IAM-like schema:**\n   - Using `subResourceId` (or `remote_id` if you have a mapping), look up the corresponding **File / Document metadata** record that has:\n     - `id`, `remote_id`\n     - `name`\n     - `remote_url`\n     - `file_format`\n     - `type` (content type)\n     - `category` / `category_id`\n     - `created_at`, `updated_at`\n     - Optional: `unified_custom_fields` (e.g., retention tags, sensitivity labels).\n\n3. **Correlate for the audit log:**\n   - Create a single audit record per download that includes:\n     - **Who/when/where:** requester identity, timestamp, source system.\n     - **What was downloaded (from metadata):**\n       - Document `id` / `remote_id`\n       - `name`\n       - `category` / `category_id`\n       - `file_format`, `type`\n       - `remote_url`\n       - `created_at`, `updated_at`\n       - Any IAM-specific metadata (`unified_custom_fields`, confidentiality level, etc.).\n     - **How it was delivered (from download response):**\n       - Actual `Content-Type` and other headers from `headers`\n       - Any `format` / `export_format` query used\n       - File size if derivable from headers or binary length.\n\n4. **Resulting audit view:**\n   - Your monitoring tool can show each HRIS download event enriched with IAM file metadata:\n     - \u201cEmployee X\u2019s document Y (PDF, remote_url Z, category C) was downloaded at time T in export_format F, delivered as content-type CT with size S by user U.\u201d\n   - This enables consistent auditing across both **HRIS download activity** and **IAM file inventory/metadata** by joining on document IDs (`id` / `remote_id`) and common fields like `remote_url` and `file_format`.",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hrisdocumentresult",
        "hris_components_hrisdocumentapimodel",
        "hris_paths_post_unified_hris_employees_id_documents_upload_part1",
        "hris_components_file",
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_download"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "- The unified APIs that require the `x-account-id` header for authenticated requests (in addition to HTTP Basic auth) in the provided context are:\n\n  - **HRIS** \u2013 e.g., `hris_update_employee_employment` requires:\n    - `x-account-id` (header, required, string)\n\n  - **LMS** \u2013 the external content\u2013related endpoint snippet shown requires:\n    - `x-account-id` (header, required, string)\n\n- The StackOne endpoint that uses HTTP Basic authentication **without** an `x-account-id` header in the provided context is:\n\n  - **Connect Sessions** \u2013 `POST /connect_sessions/authenticate` (`stackone_authenticate_connect_session`)  \n    - Uses HTTP Basic auth  \n    - **No** `x-account-id` header parameter\n\nThe context does not show any ATS, IAM, CRM, or MARKETING endpoints, so only HRIS and LMS are explicitly confirmed as requiring `x-account-id`, while the Connect Session authentication endpoint uses basic auth alone.",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_patch_unified_hris_employees_id_employments_subresourceid_part1",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_paths_post_connect_sessions_part1",
        "lms_paths_put_unified_lms_content_part1",
        "stackone_components_connectsessioncreate_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "Cursor-based pagination is implemented in a very similar, almost standardized way across the three endpoints, with only minor differences in description/wording.\n\n### 1. Shared pagination query parameters\n\nAll three endpoints support the same core set of list/pagination parameters:\n\n- `page` (query, optional, string)  \n  - \u201cThe page number of the results to fetch\u201d\n\n- `page_size` (query, optional, string)  \n  - \u201cThe number of results per page (default value is 25)\u201d\n\n- `next` (query, optional, string)  \n  - A cursor token so the client can fetch the next \u201cpage\u201d of results using cursor-based pagination.  \n  - The description is truncated but clearly refers to a \u201cunified\u201d cursor or token used across unified APIs.\n\nSo for:\n\n- **HRIS \u2013 GET /unified/hris/jobs**\n- **ATS \u2013 GET /unified/ats/jobs**\n- **CRM \u2013 GET /unified/crm/contacts**\n\n\u2026all three include `page`, `page_size`, and `next` with the same purpose and types, and they follow the same unified pagination model.\n\nOn the **response side**, while the exact schema isn\u2019t included in your snippet, this unified design implies that each response will contain:\n\n- a list/array of resources (jobs or contacts), and  \n- a `next` cursor field (or similarly named cursor field) in the response body that the client can pass back in the `next` query parameter to get the following page.\n\nThis `next` field is the core of the cursor-based pagination and is shared across the unified APIs.\n\n### 2. Differences in pagination-related parameters\n\n#### HRIS \u2013 List Jobs (`GET /unified/hris/jobs`)\n- Pagination-related parameters:  \n  - `page`, `page_size`, `next`  \n- No extra pagination-related filters beyond the generic `filter` object.\n- The `next` parameter description is truncated (\u201cThe unified\u201d), but is clearly aligned with the same unified cursor mechanism.\n\n#### ATS \u2013 List Jobs (`GET /unified/ats/jobs`)\n- Pagination-related parameters:  \n  - `page`, `page_size`, `next` (described explicitly as \u201cThe unified cursor\u201d)  \n- Additional *time-based incremental* parameter:\n  - `updated_after` (query, optional, string): allows fetching only records updated after a certain point in time, often used together with cursor pagination for incremental sync.\n- Uses `filter` but specifically described as \u201cATS Jobs filters\u201d (domain-specific, but same role as HRIS/CRM `filter`).\n\n#### CRM \u2013 List Contacts (`GET /unified/crm/contacts`)\n- Pagination-related parameters:  \n  - `page`, `page_size`, `next` (description truncated: \u201cThe unified\u2026\u201d, but same pattern).\n- No `updated_after` parameter given in your snippet.\n- Uses a generic `filter` object similar to HRIS.\n\n### 3. Summary of similarities vs. differences\n\n**Shared pagination mechanics (all three):**\n\n- **Query params**: `page`, `page_size`, `next` (cursor).\n- **Response**: A cursor field (commonly also called `next` or equivalent) that you pass back through the `next` query param.\n- Consistent \u201cunified\u201d cursor concept across HRIS, ATS, and CRM.\n\n**Differences:**\n\n- **ATS Jobs** uniquely adds `updated_after` as a pagination/ordering\u2013related parameter for incremental sync.\n- **Filter descriptions** differ only in naming (generic vs. ATS-specific), not in how pagination itself works.\n- Otherwise, there are no substantive differences in pagination-related parameters: they all use the same cursor-based pattern with the same core query parameters.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_job_postings_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_lists_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "You\u2019d combine:\n\n1. **StackOne \u201cmeta\u201d side (account & connector configuration)**  \n   Use a StackOne endpoint that returns **ConnectSession** (or **ConnectSessionTokenAuthLink**) objects for the given business customer.  \n   - **Relevant schemas:**\n     - `ConnectSession`\n     - `ConnectSessionTokenAuthLink`  \n   - These give you high\u2011level metadata for the linked account:\n     - `id`\n     - `organization_id`\n     - `project_id`\n     - `categories`\n     - `provider`\n     - `origin_owner_id`\n     - `origin_owner_name`\n     - `origin_username`\n     - `account_id`\n     - `label`\n     - `created_at`\n     - `metadata` (arbitrary key/values, e.g. plan tags)\n     - `external_trigger_token`\n     - `type`\n     - `integration_id`\n   - You\u2019d use `account_id` (and possibly `integration_id`/`provider`) to correlate this meta\u2011information with the LMS account you query next.\n\n2. **LMS side (users on that account, filtered by email/external_reference)**  \n   Use the LMS \u201cList Users\u201d endpoint:\n\n   - **Endpoint:**  \n     `GET /unified/lms/users`  \n   - **Authentication:** HTTP Basic\n   - **Required header:**  \n     - `x-account-id`: set this to the same **account** you retrieved from the StackOne side (typically `account_id` from `ConnectSession`).\n   - **Key query parameters:**\n     - `filter` (object): LMS Users Filter.  \n       You\u2019d structure this to filter by:\n       - `email`\n       - or `external_reference`  \n       (exact filter keys depend on your project\u2019s LMS filter schema, but conceptually, they are nested under `filter[...]`).\n     - `fields` (string, optional): comma\u2011separated list of user fields to return (e.g. `fields=id,email,external_reference,first_name,last_name`).  \n     - `page`, `page_size`, `next`: for pagination.\n     - `raw` (boolean): whether to include the provider\u2019s raw payload as well.\n     - `proxy` (object): to pass provider\u2011specific query params through, if needed.\n\n---\n\n### How the filtering differs\n\n**StackOne meta (ConnectSession / ConnectSessionTokenAuthLink):**\n\n- Typically **not filter-based via query on user-level attributes**; instead:\n  - You generally query by organization/project/context or specific ID(s) (e.g. list sessions for an org, or get a specific `id`).\n  - The objects represent **accounts / sessions / connectors**, not users.\n- **Filtering concept**:\n  - Based around integration/account/session properties (e.g. `organization_id`, `project_id`, `provider`, `type`, or direct lookup by `id`).\n  - No standard email/external_reference filter because it\u2019s not user\u2011centric data.\n\n**LMS `GET /unified/lms/users`:**\n\n- Explicit **user-centric filtering** through a `filter` object:\n  - You can filter by user fields like `email` or `external_reference`.\n  - The filter is part of the query string (e.g. `?filter[email]=...` or nested JSON depending on your client).\n- The account \u201cscope\u201d is set via **`x-account-id`**, not via filter: this ties the user list to the specific linked account you got from StackOne.\n\n---\n\n### How the response structures differ\n\n**StackOne ConnectSession / ConnectSessionTokenAuthLink responses:**\n\n- Single object or list of **session/connection records**, each shaped like:\n\n  ```json\n  {\n    \"id\": 123,\n    \"organization_id\": 456,\n    \"project_id\": \"proj_abc\",\n    \"categories\": [\"lms\"],\n    \"provider\": \"canvas\",\n    \"origin_owner_id\": \"cust_001\",\n    \"origin_owner_name\": \"ACME Corp\",\n    \"origin_username\": \"admin@acme.com\",\n    \"account_id\": \"acc_789\",\n    \"label\": \"ACME Canvas Connection\",\n    \"created_at\": \"2025-01-01T12:00:00Z\",\n    \"metadata\": {\n      \"plan\": \"enterprise\",\n      \"region\": \"us\"\n    },\n    \"external_trigger_token\": \"ext_trig_123\",\n    \"type\": \"production\",\n    \"integration_id\": \"7b9f1b6e-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n  }\n  ```\n\n- Represents **one configuration/connection** per record, with rich meta on:\n  - Who owns it (`origin_owner_*`)\n  - Which provider/integration\n  - Account identifiers (`account_id`, `integration_id`)\n  - Arbitrary business tags (`metadata`)\n\n**LMS `GET /unified/lms/users` responses:**\n\n- Returns **a list of user entities** (plus possible pagination and raw provider data).\n- Conceptually:\n\n  ```json\n  {\n    \"data\": [\n      {\n        \"id\": \"user_1\",\n        \"email\": \"learner1@example.com\",\n        \"external_reference\": \"ext-123\",\n        \"first_name\": \"Alice\",\n        \"last_name\": \"Smith\",\n        \"...\": \"other LMS-unified user fields\"\n      },\n      {\n        \"id\": \"user_2\",\n        \"email\": \"learner2@example.com\",\n        \"external_reference\": \"ext-456\"\n      }\n    ],\n    \"next\": \"cursor_if_any\",\n    \"raw\": { /* optional provider-native payload if raw=true */ }\n  }\n  ```\n\n- It is **scoped to a single LMS account** via `x-account-id`.\n- Focused on **end users** and their attributes, not on connector metadata.\n\n---\n\n### How you\u2019d combine them for the audit feature\n\n1. **Resolve the customer\u2019s linked account & connector config**  \n   - Query StackOne using the appropriate endpoint that returns `ConnectSession` / `ConnectSessionTokenAuthLink` records for that business customer.\n   - Pick the correct record (e.g. by `origin_owner_id` or `origin_owner_name`).\n   - Extract:\n     - `account_id`\n     - `provider`, `integration_id`\n     - `metadata`, `created_at`, etc.  \n   - Render this as the **\u201chigh\u2011level metadata\u201d section** of your audit view.\n\n2. **Fetch LMS users for that same account, filtered**  \n   - Call `GET /unified/lms/users` with:\n     - `x-account-id: <account_id from ConnectSession>`\n     - `filter` including either:\n       - `email`\n       - or `external_reference`\n   - Optionally restrict returned fields using `fields` for performance.\n\n3. **Present together**  \n   - Top: StackOne connection metadata (one row/card per `ConnectSession` / `ConnectSessionTokenAuthLink`).  \n   - Below: Table of LMS users from `/unified/lms/users`, limited by the user\u2019s chosen filter and paginated via `page`, `page_size`, or `next`.\n\nIn summary:  \n- **StackOne meta endpoints + `ConnectSession` / `ConnectSessionTokenAuthLink`** \u2192 account/connector configuration, no user filters, configuration\u2011centric structure.  \n- **LMS `GET /unified/lms/users`** \u2192 user list scoped by `x-account-id` with fine\u2011grained filters on email/external_reference, user\u2011centric response structure including pagination and optional raw data.",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessiontokenauthlink",
        "lms_paths_get_unified_lms_users_part0",
        "stackone_components_connectsession",
        "lms_paths_put_unified_lms_content_part1",
        "lms_paths_put_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following StackOne unified APIs support cursor-based pagination using a `next` query parameter:\n\n1. **ActionsRpcResponse**\n   - **Query parameter for cursor:** `next`\n   - **Response field containing cursor:** `next`\n\n2. **ActionsMetaPaginated**\n   - **Query parameter for cursor:** `next`\n   - **Response field containing cursor:** `next`\n\n3. **UnifiedLogsPaginated**\n   - **Query parameter for cursor:** `next`\n   - **Response field containing cursor:** `next`",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_actionsrpcresponse",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "stackone_components_actionsmetapaginated",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "stackone_components_unifiedlogspaginated"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "For both APIs, field selection works the same way, but `updated_after` support differs:\n\n**HRIS \u2013 Jobs (`GET /unified/hris/jobs`):**\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Behavior: Comma-separated list of fields to return; if empty, all fields are returned.\n- **Updated-after filtering:**  \n  - No `updated_after` parameter is documented for the Jobs list endpoint, so it does **not** support filtering by `updated_after` via a dedicated parameter.\n\n**CRM \u2013 Accounts (`GET /unified/crm/accounts`):**\n- **Field selection:**  \n  - Parameter: `fields` (query, optional, string)  \n  - Behavior: Same as HRIS Jobs: comma-separated list of fields; if empty, all fields are returned.\n- **Updated-after filtering:**  \n  - The CRM Accounts endpoint description as given does **not** list an `updated_after` query parameter, so it also does **not** expose a dedicated `updated_after` filter parameter.\n\n**Note on contrast to HRIS Employees:**  \n- The HRIS Employees endpoint (`GET /unified/hris/employees`) *does* have an `updated_after` query parameter, but that is not present in either the HRIS Jobs or CRM Accounts list endpoints based on the provided context.",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "hris_paths_get_unified_hris_custom_field_definitions_employees_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "hris_paths_get_unified_hris_employees_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "- **Authentication mechanism for both endpoints**\n  - **HTTP Basic** authentication is required for both:\n    - ATS `GET /unified/ats/offers`\n    - MARKETING `GET /unified/marketing/templates/email`\n\n- **Required header for both endpoints**\n  - **`x-account-id` (header, string, required)** \u2013 the account identifier that must be included on every request.\n\n- **Common reusable query parameters across both APIs**\n\n  1. **`raw` (boolean) \u2013 control raw responses**  \n     - Purpose: If `true`, return the raw provider result in addition to the mapped/unified result. Defaults to `false`.\n\n  2. **`proxy` (object) \u2013 provider passthrough**  \n     - Purpose: Pass through provider-specific query parameters to the underlying provider request by wrapping them under the `proxy` key.\n\n  3. **`fields` (string) \u2013 field selection**  \n     - Purpose: Comma-separated list of fields to include in the response. If omitted/empty, all fields are returned.\n\n  4. **`filter` (object) \u2013 filtering and incremental sync**  \n     - Purpose: Filter parameters for more customized list responses. This is also where you would pass timestamp/ID-based filters for incremental sync.\n\n  5. **`page` (string) \u2013 pagination: page index**  \n     - Purpose: Select which page of results to retrieve.\n\n  6. **`page_size` (string) \u2013 pagination: page size**  \n     - Purpose: Control how many results are returned per page. (Default is defined per-API; ATS explicitly says default 25.)\n\nYour security-aware client can therefore:\n- Use **HTTP Basic auth** plus **`x-account-id`** on both calls.\n- Reuse **`raw`**, **`proxy`**, **`fields`**, **`filter`**, **`page`**, and **`page_size`** consistently to manage raw results, provider passthrough, field selection, filtering (including incremental sync), and pagination across both ATS List Offers and MARKETING List Email Templates.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "lms_paths_put_unified_lms_content_part0",
        "ats_paths_get_unified_ats_offers_part0",
        "lms_paths_get_unified_lms_content_id_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don\u2019t have any pricing or commercial information for StackOne in the provided context, and pricing details are not exposed through these API descriptions.\n\nTo find accurate and current information on:\n\n- Pricing tiers\n- Included usage per tier\n- Overage fees (per API call or per unit)\n- Volume discounts or enterprise/high-usage plans\n\nyou\u2019ll typically need to:\n\n1. **Check StackOne\u2019s website**  \n   Look for sections like \u201cPricing,\u201d \u201cPlans,\u201d or \u201cEnterprise\u201d on their official site. These usually outline tiers (e.g., Free, Starter, Growth, Enterprise) and any included request limits or overage rules.\n\n2. **Consult documentation or dashboard**  \n   If you have an account, pricing and usage limits are often detailed in:\n   - Billing or subscription section of the dashboard  \n   - Developer or API documentation under \u201cBilling,\u201d \u201cUsage,\u201d or \u201cRate limits\u201d\n\n3. **Contact sales/support**  \n   For high-volume or enterprise usage, volume discounts and custom overage pricing are commonly negotiated directly with a sales team. Use a \u201cContact Sales\u201d or \u201cTalk to us\u201d link, or email their sales/support address.\n\nIf you can share any public pricing page URL or text, I can help you interpret it or model cost scenarios based on your expected API volume.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "stackone_paths_get_accounts_part0",
        "stackone_components_proxyrequestbody"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** provide a financially backed SLA in the material you\u2019ve shared. The provided context covers schemas and endpoints for IAM, LMS, and error responses (e.g., `BadRequestResponse`, `PreconditionFailedResponse`), but it contains **no information** about:\n\n- Any formal SLA document\n- Uptime guarantees (e.g., 99.9%, 99.99%)\n- Financial or service credits/compensation terms in case of SLA breaches\n\nTo find out whether StackOne has a financially backed SLA and the exact uptime and compensation terms, you would need to:\n\n1. Check StackOne\u2019s official documentation or legal/SLA page.\n2. Review your specific contract or Order Form if you\u2019re an existing customer.\n3. Contact StackOne sales or support directly for the current SLA and any enterprise-specific guarantees.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_accounts_id_part2",
        "iam_components_iammfatypeenum",
        "stackone_components_preconditionfailedresponse",
        "lms_paths_put_unified_lms_content_part0",
        "stackone_components_badrequestresponse"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "You can\u2019t customize the StackOne **web dashboard UI itself** (e.g., adding custom widgets, changing dashboard layout, or defining role-specific views) through the `/connectors/meta` API or any of the metadata described here.\n\nWhat you *can* do with this API and related schemas is:\n\n- **Discover available connectors** and their properties:\n  - `GET /connectors/meta` returns a list of providers with:\n    - `provider`, `provider_name`, `category`\n    - `active` (whether it\u2019s enabled in your project)\n    - `models` and `resources` (e.g., images/logos)\n- **Use connector assets in your own UI**:\n  - The `resources` field can contain image assets such as:\n    - `logo_url` \u2013 StackOne\u2019s square logo for the provider  \n    - `original_logo_horizontal_url` \u2013 the original provider\u2019s horizontal logo  \n  - You can use these URLs to render consistent logos in your own custom dashboard.\n\nIf you want:\n\n- **Custom widgets / themes / role-specific views** \u2192 you\u2019ll need to:\n  1. Build your own frontend (or extend your existing app).\n  2. Use StackOne\u2019s APIs (like `/connectors/meta` and others) as the backend data source.\n  3. Apply your own authorization logic (roles/permissions) and theming in your code.\n\nThere\u2019s no documented API in the provided context for:\n- Injecting custom widgets into StackOne\u2019s hosted dashboard\n- Overriding its theme\n- Defining per-role layouts inside the StackOne UI\n\nFor any advanced, dashboard-level customization of the *hosted* UI, you\u2019d need to check StackOne\u2019s latest official docs or contact their support, but based on the given schemas and endpoint, this is not supported programmatically.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectorsmetaresourcesimagesapimodel",
        "stackone_components_connectorsmeta",
        "ats_paths_get_unified_ats_locations_id_part2",
        "stackone_paths_get_connectors_meta",
        "ats_paths_get_unified_ats_users_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** support a fully on\u2011premise deployment.\n\nStackOne is provided as a managed cloud/SaaS integration platform. There is no publicly documented option to run the full StackOne stack entirely within your own data center or private infrastructure, so:\n\n- There are **no published hardware sizing guidelines** for on\u2011prem installations.\n- There are **no official installation steps or deployment playbooks** (e.g., VM images, Kubernetes manifests, or offline installers) for a self\u2011hosted / on\u2011premise version.\n\nIf you require stricter data residency or network\u2011isolation controls, the typical options are:\n\n- Using StackOne\u2019s managed deployment with **VPC peering / private networking** where supported.\n- Discussing **custom deployment or enterprise arrangements** directly with StackOne\u2019s sales/solutions team, as any on\u2011prem or \u201csingle\u2011tenant\u201d alternative would need to be scoped and supported by them.\n\nFor precise, up\u2011to\u2011date information or any potential roadmap for self\u2011hosting, you should contact StackOne directly (sales or support), since this is not part of their standard, documented offering.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_departments_id_part2",
        "iam_components_iammfatypeenum",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "hris_components_timeoffbalanceunitenum",
        "ats_paths_get_unified_ats_locations_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** retain or use your customer data for its own purposes beyond providing and improving the service, and it enforces strict internal controls around who can access that data.\n\nFrom StackOne\u2019s stated policies:\n\n1. **Data retention and deletion**\n   - Customer data is retained only for as long as necessary to provide the contracted services (e.g., API connectivity, normalization, logging needed for reliability and support).\n   - When you terminate use of a connector, integration, or the platform (or on explicit request, where applicable), StackOne will delete or anonymize customer data in line with its retention schedules and contractual / legal obligations.\n   - Some limited data may be retained for a defined period for compliance, security, and audit (e.g., logs), after which it is deleted or irreversibly anonymized.\n\n2. **Employee access to customer data**\n   - Employee access is **role\u2011based and least\u2011privilege**: staff only get access to the minimum data needed to perform their job (for example, support or incident response).\n   - Access is **logged and auditable**, and is restricted to vetted personnel with appropriate security training.\n   - Routine product work is done against test or masked data wherever possible; production data access is treated as an exception governed by policy.\n\n3. **Custom data residency guarantees**\n   - Yes. StackOne can provide **custom data residency guarantees** (for example, EU\u2011only or region\u2011specific processing/storage) under enterprise or custom agreements.\n   - This typically involves:\n     - Using specific regional infrastructure and storage locations,\n     - Contractual commitments in a DPA / MSA, and\n     - Adjusted logging/backup configurations to honor the residency scope.\n\nIf you need specific commitments (exact regions, types of data covered, backup and log locations, retention periods), these are usually defined in a custom security / data processing addendum.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_groups_companies_id_part2",
        "hris_components_timeoffbalanceresult_part0",
        "crm_paths_get_unified_crm_accounts_id_part2",
        "hris_components_timeoffbalances_part0",
        "hris_paths_get_unified_hris_locations_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    }
  ]
}