{
  "config": "c0",
  "timestamp": "2025-12-10T12:38:34.079996",
  "summary": {
    "total_questions": 66,
    "retrieval": {
      "hit_rate_at_k": 0.29508196721311475,
      "mrr": 0.29508196721311475,
      "precision_at_k": 0.29508196721311475,
      "recall_at_k": 0.29508196721311475,
      "k": 5
    },
    "answer_quality": {
      "keyword_coverage": 0.6345368201925579,
      "accuracy_score": 3.5606060606060606,
      "completeness_score": 3.6666666666666665,
      "hallucination_rate": 0.5757575757575758
    },
    "abstention": {
      "correct_abstention_rate": 0.0,
      "false_abstention_rate": 0.0,
      "out_of_scope_count": 5,
      "in_scope_count": 61
    }
  },
  "results_by_category": {
    "cross_api": {
      "count": 5,
      "avg_keyword_coverage": 0.5207142857142857,
      "avg_accuracy": 2.6,
      "retrieval_hit_rate": 0.0
    },
    "out_of_scope": {
      "count": 5,
      "avg_keyword_coverage": 0.0,
      "avg_accuracy": 3.8,
      "retrieval_hit_rate": 0.0
    },
    "schema": {
      "count": 14,
      "avg_keyword_coverage": 0.833390022675737,
      "avg_accuracy": 3.857142857142857,
      "retrieval_hit_rate": 0.2857142857142857
    },
    "endpoint": {
      "count": 14,
      "avg_keyword_coverage": 0.6420068027210883,
      "avg_accuracy": 3.7857142857142856,
      "retrieval_hit_rate": 0.2857142857142857
    },
    "auth": {
      "count": 7,
      "avg_keyword_coverage": 0.32857142857142857,
      "avg_accuracy": 3.2857142857142856,
      "retrieval_hit_rate": 0.2857142857142857
    },
    "factual": {
      "count": 21,
      "avg_keyword_coverage": 0.6260770975056689,
      "avg_accuracy": 3.4761904761904763,
      "retrieval_hit_rate": 0.38095238095238093
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_001",
      "question": "Which query parameters can be used to filter the GET /accounts endpoint, and which of them specifically target the account owner identifiers?",
      "category": "factual",
      "generated_answer": "For the `GET /accounts` endpoint, the following query parameters can be used to filter results:\n\n- `page` \u2013 page number to fetch  \n- `page_size` \u2013 number of results per page  \n- `provider` (deprecated) \u2013 provider of the results to fetch  \n- `origin_owner_id` \u2013 a single origin owner identifier to filter results  \n- `origin_owner_ids` \u2013 multiple origin owner identifiers to filter results (array of strings)\n\nThe parameters that specifically target the account owner identifiers are:\n\n- `origin_owner_id`\n- `origin_owner_ids`",
      "ground_truth_answer": "The GET /accounts endpoint supports the following query parameters: `page`, `page_size`, `provider`, `origin_owner_id`, and `origin_owner_ids`. Among these, `origin_owner_id` and `origin_owner_ids` are specifically used to target or filter by account owner identifiers.",
      "retrieval_hit": true,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "factual_stackone_002",
      "question": "For the GET /requests/logs endpoint, what are all the supported query parameters, and which one is used to control whether extra data is returned with each log entry?",
      "category": "factual",
      "generated_answer": "For the `GET /requests/logs` endpoint, the supported query parameters (from the provided context) are:\n\n1. `order_by`  \n   - Description: The field to order the results by.  \n   - Allowed values: `provider`, `service`, `status`, `eventDatetime`, `duration`, or `null`.\n\n2. `order_direction`  \n   - Description: The direction to order the results by.  \n   - Allowed values: `asc`, `desc`, or `null`.\n\n3. `page_size`  \n   - Description: The number of results per page (default is 25).  \n   - Type: number, maximum 100.\n\nThe parameter that controls whether extra data is returned with each log entry (e.g., `step_logs`, `advanced_logs`) is **`include`**, but that parameter appears on the **`GET /requests/logs/{id}`** endpoint, not on `GET /requests/logs`.",
      "ground_truth_answer": "The GET /requests/logs endpoint supports the query parameters `order_by`, `order_direction`, `page_size`, `next`, and `include`. The `include` parameter is the one used to control whether extra data is returned with each log entry.",
      "retrieval_hit": true,
      "keyword_coverage": 0.8333333333333334,
      "accuracy_score": 2,
      "completeness_score": 2,
      "has_hallucination": false
    },
    {
      "question_id": "factual_stackone_003",
      "question": "Compare the query parameters available on GET /requests/logs/steps and GET /requests/platform-logs. Which parameters are common to both endpoints, and which parameter is unique to one of them?",
      "category": "factual",
      "generated_answer": "The query parameters shown for both:\n\n- `order_by`\n- `order_direction`\n- `page_size`\n\nare **common to both** `GET /requests/logs/steps` and `GET /requests/platform-logs`.\n\nFrom the provided context, **no query parameter appears that is unique to only one** of these two endpoints; the listed parameters are the same on both.",
      "ground_truth_answer": "Both GET /requests/logs/steps and GET /requests/platform-logs support the query parameters `order_by`, `order_direction`, `page_size`, `next`, and `filter`. There is no parameter that is unique to only one of these two endpoints; their query parameter sets are identical based on the provided specification.",
      "retrieval_hit": true,
      "keyword_coverage": 0.7142857142857143,
      "accuracy_score": 3,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_stackone_001",
      "question": "Which STACKONE endpoint should I use to retrieve a paginated list of all accounts, optionally filtered by provider or origin_owner_id?",
      "category": "endpoint",
      "generated_answer": "Use the `GET /accounts` endpoint (`operationId: stackone_list_linked_accounts`) to retrieve a paginated list of all accounts, with optional filtering by `provider` or `origin_owner_id`.",
      "ground_truth_answer": "Use the GET /accounts endpoint to retrieve a paginated list of all accounts. This endpoint supports query parameters such as page, page_size, provider, origin_owner_id, and origin_owner_ids for filtering and pagination.",
      "retrieval_hit": true,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 4,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_stackone_002",
      "question": "If I need to inspect the detailed metadata for a specific account after I already know its ID, which exact STACKONE endpoint should I call, and what path parameter is required?",
      "category": "endpoint",
      "generated_answer": "Call the `GET /accounts/{id}/meta` endpoint, providing the account\u2019s ID as the `{id}` path parameter.",
      "ground_truth_answer": "To inspect detailed metadata for a specific account when you already have its ID, call the GET /accounts/{id}/meta endpoint. You must supply the id path parameter, which identifies the account whose meta information you want to retrieve.",
      "retrieval_hit": true,
      "keyword_coverage": 0.3333333333333333,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_stackone_001",
      "question": "In the STACKONE API, when sending an Actions RPC request using the ActionsRpcRequestDto schema, which field is required and what other optional fields can be included in the request payload?",
      "category": "schema",
      "generated_answer": "In the STACKONE API, when sending an Actions RPC request using the `ActionsRpcRequestDto` schema:\n\n**Required field:**\n- `action` (string) \u2013 the name/identifier of the action to execute.\n\n**Optional fields you can include in the request payload:**\n- `path` (object, nullable) \u2013 path parameters for the action (e.g. `{\"id\": \"123\"}`).\n- `query` (object, nullable) \u2013 query parameters for the action. This can include:\n  - `debug` (boolean, nullable) \u2013 enable debug mode for the action execution.\n  - plus any other additional query parameters (since `additionalProperties: true`).\n- `headers` (object, nullable) \u2013 headers for the action (e.g. `{\"Content-Type\": \"application/json\"}`).\n- `body` (object, nullable) \u2013 request body for the action (arbitrary JSON, e.g. `{\"data\": \"example\"}`).",
      "ground_truth_answer": "According to the ActionsRpcRequestDto schema, the only required field in an Actions RPC request payload is `action`. The schema defines the following properties:\n- `action` (required)\n- `path` (optional)\n- `query` (optional)\n- `headers` (optional)\n- `body` (optional)\nSo, a valid request must include `action`, and may optionally include any combination of `path`, `query`, `headers`, and `body`.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 4,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_stackone_002",
      "question": "For the STACKONE advanced logging feature, describe the structure of the response portion as defined by the AdvancedLogResponseData schema. Which top-level fields are present, and what types of information do `custom_mapping_errors` and `provider_errors` represent?",
      "category": "schema",
      "generated_answer": "The `AdvancedLogResponseData` schema\u2019s **response** portion is an object with (among others) the following top\u2011level fields:\n\n- `statusCode` \u2013 HTTP status code of the operation (required).  \n- `message` \u2013 Main error or status message (required).  \n- `timestamp` \u2013 When the response/error occurred, as an ISO8601 date\u2011time string (required).  \n- `provider_errors` \u2013 Optional array of `ProviderError` objects.  \n- `custom_mapping_errors` \u2013 Optional array (in the full schema) describing errors that occurred while applying your custom/unified field mappings.\n\n**`custom_mapping_errors`**  \nThese entries describe problems translating the provider\u2019s raw data into your StackOne unified model using your configured custom mappings. Examples include:\n\n- A field couldn\u2019t be mapped because of a missing or invalid value.  \n- Type mismatches between provider data and the unified field definition.  \n- Failures in transformation logic you configured.\n\nThey are about **your mapping/unification layer**, not the provider itself.\n\n**`provider_errors`**  \nThese are **provider-specific** errors returned by the underlying third\u2011party system (e.g., an ATS, HRIS, LMS). Examples include:\n\n- Provider returned a 4xx/5xx with its own error code/message.  \n- Rate limit, authentication, or permission issues at the provider.  \n- Any error payload the provider exposes.\n\nThey capture **what went wrong on the provider side**, preserving provider-native error details.",
      "ground_truth_answer": "The AdvancedLogResponseData schema defines the structure of the response portion of an advanced log entry with the following top-level fields:\n- `status_code`\n- `headers`\n- `body`\n- `custom_mapping_errors`\n- `provider_errors`\n\n`custom_mapping_errors` represents errors related to custom mappings applied by STACKONE when transforming or mapping data, while `provider_errors` represents errors returned directly by the underlying provider or external service. Both are part of the response metadata captured for diagnostic and debugging purposes.",
      "retrieval_hit": false,
      "keyword_coverage": 0.5,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "auth_stackone_001",
      "question": "Which authentication scheme must clients use when calling the STACKONE API endpoints, and what HTTP header will be sent as a result?",
      "category": "auth",
      "generated_answer": "Clients must use **HTTP Basic authentication** (`scheme: basic`) when calling the STACKONE API endpoints.  \n\nAs a result, the client will send an **`Authorization`** header of the form:\n\n```http\nAuthorization: Basic <base64-encoded-credentials>\n```",
      "ground_truth_answer": "Clients must use HTTP Basic authentication when calling the STACKONE API. The API declares an auth scheme of type \"http\" with scheme \"basic\", so clients provide credentials using the Basic Authentication mechanism, which results in an Authorization header of the form `Authorization: Basic <base64-encoded-credentials>` being sent with requests to STACKONE endpoints.",
      "retrieval_hit": false,
      "keyword_coverage": 0.5,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_hris_001",
      "question": "Which HTTP method and endpoint should be used to retrieve a paginated list of companies in the HRIS API, and what are the available query parameters for that operation?",
      "category": "factual",
      "generated_answer": "The HRIS API uses:\n\n**HTTP method & endpoint**\n\n- **Method:** `GET`  \n- **Endpoint:** `/unified/hris/companies`  \n- **OperationId:** `hris_list_companies`\n\n**Available parameters for this operation**\n\n1. **Header parameter (required)**  \n   - `x-account-id` (string) \u2013 The account identifier.\n\n2. **Query parameters (optional)**  \n   - `raw` (boolean, nullable)  \n     - Description: If `true`, returns the raw provider response in addition to the mapped result (defaults to `false`).\n   - `proxy` (object, nullable, style `deepObject`, `explode: true`)  \n     - Description: Used to pass through query parameters to the underlying provider request by wrapping them inside the `proxy` object.  \n     - Schema: `type: object`, `additionalProperties: true`.",
      "ground_truth_answer": "To retrieve a paginated list of companies, you use an HTTP GET on the endpoint `GET /unified/hris/companies`. The available parameters for this operation are: `x-account-id`, `raw`, `proxy`, `fields`, and `filter`. Pagination behavior is represented via the `CompaniesPaginated` schema in the API, but the factually listed parameters are exactly those five.",
      "retrieval_hit": true,
      "keyword_coverage": 0.5,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": false
    },
    {
      "question_id": "factual_hris_002",
      "question": "When creating a new employee record in the HRIS API, which endpoint and HTTP method must be called, and which header parameter is explicitly listed as required for this operation?",
      "category": "factual",
      "generated_answer": "The HRIS API requires calling the **`POST /hris/employees`** (employee creation) endpoint using the **HTTP `POST` method**. For this operation, the header parameter **`x-account-id`** is explicitly listed as **required**.",
      "ground_truth_answer": "To create a new employee, the HRIS API uses the `POST /unified/hris/employees` endpoint. The explicitly listed required parameter for this operation is the `x-account-id` header.",
      "retrieval_hit": false,
      "keyword_coverage": 0.3333333333333333,
      "accuracy_score": 4,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "factual_hris_003",
      "question": "For managing an employee\u2019s time off, which specific endpoints and HTTP methods are used to (a) list all time off requests for an employee, (b) create a new time off request, and (c) update or delete a specific time off request, and what are the key path or header parameters required for each?",
      "category": "factual",
      "generated_answer": "(a) **List all time off requests for an employee**\n\n- **Endpoint & Method**:  \n  `GET /unified/hris/employees/{id}/time_off`\n- **Required parameters**:\n  - **Header**\n    - `x-account-id` (string) \u2013 The account identifier.\n  - **Path**\n    - `id` (string) \u2013 The employee\u2019s identifier.\n  - **Optional query**\n    - `raw` (boolean, optional) \u2013 Return raw provider result in addition to mapped result.\n    - `proxy` (object, optional, deepObject) \u2013 Extra query parameters to pass through to the underlying provider.\n\n---\n\n(b) **Create a new time off request for an employee**\n\n- **Endpoint & Method**:  \n  `POST /unified/hris/employees/{id}/time_off`\n- **Required parameters**:\n  - **Header**\n    - `x-account-id` (string) \u2013 The account identifier.\n  - **Path**\n    - `id` (string) \u2013 The employee\u2019s identifier.\n  - **Body**\n    - Time off request payload (schema not fully shown in the snippet, but this POST is described as `hris_create_employee_time_off_request`).\n\n---\n\n(c) **Update or delete a specific time off request**\n\nFrom the snippet, the update and delete operations refer to \u201cEmployee Time Off Request\u201d and use path parameters including `id` and `subResourceId`:\n\n- **Update a specific time off request**\n  - **Endpoint & Method**:  \n    `PUT /unified/hris/employees/{id}/time_off/{subResourceId}`  \n    (operationId: `hris_update_employee_time_off_request`)\n  - **Required parameters**:\n    - **Header**\n      - `x-account-id` (string) \u2013 The account identifier.\n    - **Path**\n      - `id` (string) \u2013 The employee\u2019s identifier.\n      - `subResourceId` (string) \u2013 The specific time off request identifier.\n    - **Body**\n      - Updated time off request payload.\n\n- **Delete (cancel) a specific time off request**\n  - **Endpoint & Method**:  \n    `DELETE /unified/hris/employees/{id}/time_off/{subResourceId}`  \n    (operationId: `hris_cancel_employee_time_off_request`)\n  - **Required parameters**:\n    - **Header**\n      - `x-account-id` (string) \u2013 The account identifier.\n    - **Path**\n      - `id` (string) \u2013 The employee\u2019s identifier.\n      - `subResourceId` (string) \u2013 The specific time off request identifier.",
      "ground_truth_answer": "(a) To list all time off requests for an employee, you use `GET /unified/hris/employees/{id}/time_off` with parameters `x-account-id`, `id`, `raw`, `proxy`, and `fields`.\n(b) To create a new time off request for an employee, you use `POST /unified/hris/employees/{id}/time_off` with parameters `x-account-id` and `id`.\n(c) To manage a specific existing time off request, you use the subresource endpoint `/unified/hris/employees/{id}/time_off/{subResourceId}`: `GET` to retrieve, `PATCH` to update, and `DELETE` to delete a specific time off request, with parameters `x-account-id`, `id`, and `subResourceId` (and, for GET, also `raw` and `proxy`).",
      "retrieval_hit": true,
      "keyword_coverage": 0.875,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_hris_001",
      "question": "Which endpoint should I use to invite an existing employee to the HRIS system, and what path parameter is required?",
      "category": "endpoint",
      "generated_answer": "Use the `POST /unified/hris/employees/{id}/invite` endpoint, and you must provide the `id` path parameter (the employee\u2019s identifier).",
      "ground_truth_answer": "Use the `POST /unified/hris/employees/{id}/invite` endpoint to invite an existing employee. It requires the `id` path parameter to specify which employee to invite.",
      "retrieval_hit": false,
      "keyword_coverage": 0.3333333333333333,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_hris_002",
      "question": "If you need to retrieve all time off requests for a specific employee and also be able to later modify an individual time off request, which two endpoints should you call and how do their path structures differ?",
      "category": "endpoint",
      "generated_answer": "You should use:\n\n1. **To retrieve all time off requests for a specific employee**  \n   **Endpoint:** `GET /employees/{id}/time-off-requests`  \n   - This returns a paginated list of all time off requests for the employee.  \n   - Path uses only the **employee ID** (`{id}`).\n\n2. **To later modify an individual time off request**  \n   **Endpoint:** `PATCH /employees/{id}/time-off-requests/{subResourceId}`  \n   - This updates a specific time off request for that employee.  \n   - Path uses both the **employee ID** (`{id}`) and the **time off request ID** (`{subResourceId}`).\n\n**Path difference:**  \n- List-all endpoint: `/employees/{id}/time-off-requests`  \n- Single-request update endpoint: `/employees/{id}/time-off-requests/{subResourceId}` (adds the specific time off request identifier at the end).",
      "ground_truth_answer": "To retrieve all time off requests for a specific employee, call `GET /unified/hris/employees/{id}/time_off`, which uses the `id` path parameter for the employee. To later modify an individual time off request, call `PATCH /unified/hris/employees/{id}/time_off/{subResourceId}`, which uses both the employee `id` and the time off request `subResourceId` path parameters.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "schema_hris_001",
      "question": "In the HRIS API, when a bad gateway error occurs, which fields are included in the `BadGatewayResponse` object, and which of them are required?",
      "category": "schema",
      "generated_answer": "In the HRIS API, the `BadGatewayResponse` object includes these fields:\n\n- `statusCode` (number) \u2013 HTTP status code (example: `502`)\n- `message` (string) \u2013 Error message (example: `\"Bad Gateway\"`)\n- `timestamp` (string, date-time) \u2013 When the error occurred (example: `\"2023-05-30T00:00:00.000Z\"`)\n\nAll three fields \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required.",
      "ground_truth_answer": "The `BadGatewayResponse` schema has three fields: `statusCode`, `message`, and `timestamp`. All three of these fields are required properties of the response.",
      "retrieval_hit": true,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_hris_002",
      "question": "For the HRIS API, what are the properties of the `CompaniesPaginated` response schema, and which of these properties are mandatory?",
      "category": "schema",
      "generated_answer": "For the HRIS API, the `CompaniesPaginated` response schema is defined as:\n\n```json\n\"CompaniesPaginated\": {\n  \"type\": \"object\",\n  \"properties\": {\n    \"next_page\": {\n      \"type\": \"string\",\n      \"deprecated\": true,\n      \"nullable\": true\n    },\n    \"next\": {\n      \"type\": \"string\",\n      \"nullable\": true\n    },\n    \"data\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/components/schemas/Company\"\n      }\n    },\n    \"raw\": {\n      \"nullable\": true,\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/components/schemas/RawResponse\"\n      }\n    }\n  },\n  \"required\": [\"data\"]\n}\n```\n\n**Properties:**\n- `next_page`: string, deprecated, nullable\n- `next`: string, nullable\n- `data`: array of `Company` objects\n- `raw`: array of `RawResponse` objects, nullable\n\n**Mandatory property:**\n- `data` is the only required (mandatory) property.",
      "ground_truth_answer": "The `CompaniesPaginated` schema defines the properties `next_page`, `next`, `data`, and `raw`. Among these, only `data` is a required property; `next_page`, `next`, and `raw` are optional.",
      "retrieval_hit": true,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "auth_hris_001",
      "question": "When calling the HRIS API (for example, GET /unified/hris/companies), what HTTP authentication scheme must be used, and how should the Authorization header be formatted?",
      "category": "auth",
      "generated_answer": "Use HTTP Bearer authentication with a token.\n\nThe `Authorization` header must be formatted as:\n\n```http\nAuthorization: Bearer YOUR_API_KEY\n```\n\nReplace `YOUR_API_KEY` with your actual API token.",
      "ground_truth_answer": "The HRIS API uses HTTP Basic authentication. Clients must send an Authorization header with the value \"Basic <credentials>\", where <credentials> is the Base64-encoded string of \"username:password\". The auth scheme in the specification is defined as type \"http\" with scheme \"basic\".",
      "retrieval_hit": false,
      "keyword_coverage": 0.2,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "factual_ats_001",
      "question": "Which HTTP method and endpoint should you use to create a new ATS application, and which required header must be included with the request?",
      "category": "factual",
      "generated_answer": "Use an HTTP **POST** request to the **`ats_create_application`** endpoint (the ATS \u201cCreate Application\u201d endpoint in the API).\n\nYou must include the required header:\n\n- **`x-account-id`** \u2013 the account identifier (string).",
      "ground_truth_answer": "To create a new ATS application you must send an HTTP POST request to the endpoint `/unified/ats/applications` and include the `x-account-id` header in the request.",
      "retrieval_hit": false,
      "keyword_coverage": 0.75,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": false
    },
    {
      "question_id": "factual_ats_002",
      "question": "If you need to retrieve the details of a specific application offer, which path parameters are required for the `GET /unified/ats/applications/{id}/offers/{subResourceId}` endpoint, and what additional query-style parameters can this operation accept according to the spec?",
      "category": "factual",
      "generated_answer": "For the `GET /unified/ats/applications/{id}/offers/{subResourceId}` endpoint:\n\n**Required path parameters:**\n1. `id` \u2013 the application ID (in the path)\n2. `subResourceId` \u2013 the specific offer ID related to that application (in the path)\n\n**Additional query-style parameters it can accept:**\n1. `raw` (query, optional, boolean, nullable) \u2013 if true, returns the raw provider result in addition to the mapped result.\n2. `proxy` (query, optional, deepObject style, explode: true, type: object, additionalProperties: true, nullable) \u2013 used to pass through arbitrary parameters to the underlying provider by nesting them under the `proxy` key.",
      "ground_truth_answer": "To retrieve a specific application offer, the endpoint is `GET /unified/ats/applications/{id}/offers/{subResourceId}`. It requires the path parameters `id` (the application ID) and `subResourceId` (the offer ID). According to the specification, this operation can additionally accept the parameters `x-account-id`, `raw`, and `proxy`. Unlike some other endpoints, there is no `fields` parameter listed for this operation.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "factual_ats_003",
      "question": "For listing application-related resources, which of the following ATS endpoints explicitly support a `fields` parameter, and which do not: `GET /unified/ats/applications`, `GET /unified/ats/applications/{id}/offers`, `GET /unified/ats/applications/{id}/offers/{subResourceId}`, and `GET /unified/ats/applications/{id}/notes`? Provide a breakdown for each endpoint.",
      "category": "factual",
      "generated_answer": "Based on the provided context, none of the listed endpoints declare a `fields` query parameter. Each endpoint only shows `x-account-id`, path parameters (`id`, `subResourceId`), and optional `raw` and `proxy` query parameters.\n\nBreakdown:\n\n1. `GET /unified/ats/applications`  \n   - Explicitly supports: `x-account-id` (header), `raw` (query), `proxy` (query)  \n   - `fields` parameter: **Not supported / not documented**\n\n2. `GET /unified/ats/applications/{id}/offers`  \n   - Explicitly supports: `x-account-id` (header), `id` (path), `raw` (query), `proxy` (query)  \n   - `fields` parameter: **Not supported / not documented**\n\n3. `GET /unified/ats/applications/{id}/offers/{subResourceId}`  \n   - Explicitly supports: `x-account-id` (header), `id` (path), `subResourceId` (path), `raw` (query), `proxy` (query)  \n   - `fields` parameter: **Not supported / not documented**\n\n4. `GET /unified/ats/applications/{id}/notes`  \n   - Explicitly supports: `x-account-id` (header), `id` (path), `raw` (query), `proxy` (query)  \n   - `fields` parameter: **Not supported / not documented**",
      "ground_truth_answer": "According to the specification: (1) `GET /unified/ats/applications` supports a `fields` parameter. (2) `GET /unified/ats/applications/{id}/offers` supports a `fields` parameter. (3) `GET /unified/ats/applications/{id}/offers/{subResourceId}` does not list a `fields` parameter; it only has `x-account-id`, `id`, `subResourceId`, `raw`, and `proxy`. (4) `GET /unified/ats/applications/{id}/notes` supports a `fields` parameter.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_ats_001",
      "question": "Which endpoint should I use to retrieve all scorecards associated with a specific application, and what path parameter(s) are required?",
      "category": "endpoint",
      "generated_answer": "Use the `GET /unified/ats/applications/{id}/scorecards` endpoint to retrieve **all** scorecards for a specific application.\n\nRequired path parameter:\n- `id` \u2013 the identifier of the application whose scorecards you want to list.",
      "ground_truth_answer": "Use the **GET /unified/ats/applications/{id}/scorecards** endpoint to list all scorecards for a specific application. The required path parameter is **{id}**, which represents the application ID. You must also provide the **x-account-id** header.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_ats_002",
      "question": "If I need to move an existing application to a different stage in the ATS, which endpoint should I call and which mandatory path parameter is required to identify the application?",
      "category": "endpoint",
      "generated_answer": "You should call the `POST /unified/ats/applications/{id}/move` endpoint.\n\nThe mandatory path parameter is `id`, which is the unique identifier of the application you want to move.",
      "ground_truth_answer": "To move an existing application to a different stage, call the **POST /unified/ats/applications/{id}/move** endpoint. The mandatory path parameter is **{id}**, which identifies the application to be moved. The request must also include the **x-account-id** header.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": false
    },
    {
      "question_id": "schema_ats_001",
      "question": "For the `ApplicationChanges` schema in the ATS API, which fields are required and what do they represent in the context of tracking changes to an application?",
      "category": "schema",
      "generated_answer": "For the `ApplicationChanges` schema, the **required fields are**:\n\n1. **`created_at`**  \n   - **Type:** `string` (date-time)  \n   - **Meaning:** The timestamp when the change record was created. It marks **when the change event was logged** in the system.\n\n2. **`new_values`**  \n   - **Type:** `ApplicationChangesDataModel`  \n   - **Meaning:** The **new values of the application properties that changed** as a result of this event.  \n   - It only includes fields that commonly change during the application lifecycle (for example: `interview_stage_id`, `title`, `rejected_reason_ids`, `application_status`, etc., depending on what changed).\n\nIn the context of tracking changes to an application, `created_at` tells you **when** a change occurred, and `new_values` tells you **what was changed and to which new values**.",
      "ground_truth_answer": "In the ATS API, the `ApplicationChanges` schema has two required fields: `created_at` and `new_values`.\n\n- `created_at` is required and represents the timestamp when the change record was created. It indicates when this particular change was recorded in the system.\n- `new_values` is required and represents the data model capturing the updated state or changed attributes for the application. This field uses the `ApplicationChangesDataModel` schema to describe what values were changed, such as interview stage, rejected reasons, or application status.\n\nOther fields in `ApplicationChanges` (such as `id`, `remote_id`, `effective_at`, `actor`, and `change_type`) exist but are not marked as required in the schema.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "schema_ats_002",
      "question": "In the ATS API, describe the structure and purpose of the `ApplicationChangesDataModel` schema. Which types of application state information can it capture, and how do these fields relate to tracking updates on an application?",
      "category": "schema",
      "generated_answer": "The `ApplicationChangesDataModel` is a small object used to represent the *new values* of key application properties whenever an application changes in the ATS.\n\n**Structure**\n\n```json\nApplicationChangesDataModel {\n  \"interview_stage_id\": string | null,\n  \"title\": string | null\n}\n```\n\n- `interview_stage_id`  \n  - Type: string, nullable, deprecated  \n  - Meaning: The unique identifier of the interview stage the application has moved into.  \n  - Example: `\"18bcbb1b-3cbc-4198-a999-460861d19480\"`  \n  - Role in tracking: When an application progresses through the interview pipeline, this field records the *new* interview stage at the time of that change event.\n\n- `title`  \n  - Type: string, nullable  \n  - Meaning: The candidate\u2019s title/position for the application (e.g., job title being applied for, or how the candidate is titled in the ATS for that application).  \n  - Example: `\"Software Engineer\"`  \n  - Role in tracking: When the title associated with an application changes (e.g., role renaming, correcting or updating the candidate\u2019s title), this field shows the *new* title.\n\n**Purpose and relation to tracking updates**\n\n- `ApplicationChangesDataModel` is embedded in the `ApplicationChanges` object as `new_values`.  \n- Each `ApplicationChanges` record represents a discrete change event (with its own `created_at`, `change_type`, `actor`, etc.).  \n- `new_values` (of type `ApplicationChangesDataModel`) captures *what the application\u2019s important fields became* after that event.\n\nIn practice, this schema helps you:\n\n- Track movement through the interview pipeline via `interview_stage_id`.\n- Track changes to the application\u2019s associated title via `title`.\n- Reconstruct the application\u2019s lifecycle over time by reading the sequence of `ApplicationChanges` and their `new_values`.",
      "ground_truth_answer": "The `ApplicationChangesDataModel` schema in the ATS API is used to represent the specific application state values that are being changed and stored under the `new_values` property of an `ApplicationChanges` record.\n\nThe schema has the following properties (none of which are required by the schema definition):\n- `interview_stage_id`: an identifier referencing the interview stage to which the application has moved or been updated.\n- `rejected_reason_ids`: a collection (list/array) of identifiers representing the reasons for which the application was rejected.\n- `application_status`: a value indicating the current status of the application (e.g., whether it is active, rejected, or in another defined state; the exact enumerated values are defined elsewhere, such as in `ApplicationStatusEnum`).\n\nTogether, these fields capture changes to an application\u2019s interview stage, rejection reasons, and overall status, and are embedded as `new_values` in an `ApplicationChanges` record to track how an application\u2019s state evolves over time.",
      "retrieval_hit": false,
      "keyword_coverage": 0.6,
      "accuracy_score": 1,
      "completeness_score": 2,
      "has_hallucination": true
    },
    {
      "question_id": "auth_ats_001",
      "question": "What authentication scheme must clients use when calling any ATS endpoint on https://api.stackone.com, and what header will be sent on the wire as a result?",
      "category": "auth",
      "generated_answer": "Clients must use HTTP Basic authentication (`scheme: basic`).  \n\nAs a result, each request to an ATS endpoint on `https://api.stackone.com` will include an `Authorization` header of the form:\n\n```http\nAuthorization: Basic <base64(username:password)>\n```",
      "ground_truth_answer": "The ATS API uses HTTP Basic authentication for all requests. Clients must authenticate with the HTTP `Authorization` header using the `Basic` scheme, which contains a Base64-encoded username and password (i.e., `Authorization: Basic <base64-encoded-credentials>`). No other auth schemes (such as Bearer tokens or API keys) are defined in the spec.",
      "retrieval_hit": false,
      "keyword_coverage": 0.5,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_lms_001",
      "question": "Which LMS endpoint would you call to retrieve a list of the most granular learning objects, and what type of learning objects does it return?",
      "category": "factual",
      "generated_answer": "You would call the `GET /unified/lms/content` endpoint.  \n\nIt returns a list of **content-type learning objects**, which are the most granular items such as **videos, documents, podcasts**, and other content for which the platform supports **progress and completion tracking**.",
      "ground_truth_answer": "You would call the GET /unified/lms/content endpoint. It returns a list of content type learning objects, which are described as the most granular learning objects.",
      "retrieval_hit": false,
      "keyword_coverage": 0.3333333333333333,
      "accuracy_score": 4,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "factual_lms_002",
      "question": "What is the purpose of the POST /unified/lms/users/{id}/completions endpoint, and which path parameter is used to identify the user?",
      "category": "factual",
      "generated_answer": "The POST `/unified/lms/users/{id}/completions` endpoint is used to **create a completed learning record for a user** (i.e., record that the user has completed a learning object).\n\nThe **path parameter** used to identify the user is **`id`** (the `{id}` in `/unified/lms/users/{id}/completions`).",
      "ground_truth_answer": "The POST /unified/lms/users/{id}/completions endpoint is used to create a completed learning record for a user, representing the record of a user completing a learning object. It uses the path parameter {id} to identify the user.",
      "retrieval_hit": false,
      "keyword_coverage": 0.25,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "factual_lms_003",
      "question": "If you need to remove a record that a specific user has completed a learning object, which exact LMS endpoint should you use, and which two path parameters are required to identify both the user and the completion record?",
      "category": "factual",
      "generated_answer": "You should use this LMS endpoint:\n\n`DELETE /unified/lms/users/{id}/completions/{subResourceId}`\n\nThe two required path parameters are:\n- `id` \u2013 the user\u2019s identifier  \n- `subResourceId` \u2013 the identifier of the specific completion record",
      "ground_truth_answer": "You should use the DELETE /unified/lms/users/{id}/completions/{subResourceId} endpoint. It requires two path parameters: {id} to identify the user and {subResourceId} to identify the specific completion type learning record to delete.",
      "retrieval_hit": false,
      "keyword_coverage": 0.75,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_lms_001",
      "question": "Which endpoint should I use to retrieve all completed learning records across all users, and what optional query parameters can I use to refine the results?",
      "category": "endpoint",
      "generated_answer": "You should use the endpoint:\n\n`GET /unified/lms/completions`\n\nThis retrieves a list of completed learning records across all users.\n\nOptional query parameters you can use to refine/modify the results:\n\n- `raw` (boolean, query):  \n  If `true`, returns the raw provider response in addition to the mapped result.  \n  Default is `false`.\n\n- `proxy` (object, query, deepObject style):  \n  Used to pass through provider-specific query parameters to the underlying LMS.  \n  You include provider parameters nested under `proxy`, for example:  \n  `?proxy[status]=completed&proxy[page]=2`",
      "ground_truth_answer": "Use the GET /unified/lms/completions endpoint to retrieve a list of completed learning records across all users. This endpoint supports the following optional query parameters to refine the results: x-account-id, raw, proxy, fields, and filter.",
      "retrieval_hit": false,
      "keyword_coverage": 0.5714285714285714,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_lms_002",
      "question": "If I need to remove a specific completion record for a user, which endpoint should I call, and which path parameters are required to identify both the user and the completion record?",
      "category": "endpoint",
      "generated_answer": "You should call the **DELETE** endpoint:\n\n`DELETE /unified/lms/users/{id}/completions/{subResourceId}`\n\nThe required path parameters are:\n- `id` \u2013 the **user** identifier  \n- `subResourceId` \u2013 the **completion record** identifier",
      "ground_truth_answer": "To remove a specific completion record for a user, call the DELETE /unified/lms/users/{id}/completions/{subResourceId} endpoint. You must provide the following path parameters: id (the user identifier) and subResourceId (the identifier of the completion type learning record for that user).",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_lms_001",
      "question": "In the LMS API, what fields are required in the `AssignmentResult` schema, and what are the top-level properties it can contain in a response?",
      "category": "schema",
      "generated_answer": "In the LMS API:\n\n- **Required field in the `AssignmentResult` schema:**\n  - `data`\n\n- **Top-level properties that `AssignmentResult` can contain in a response:**\n  - `data` \u2013 an `Assignment` object\n  - `raw` \u2013 an array of `RawResponse` objects (nullable)",
      "ground_truth_answer": "According to the LMS API schema, `AssignmentResult` has two top-level properties: `data` and `raw`. Only `data` is required. The `data` field must be present in any valid `AssignmentResult` response, while `raw` is an optional property.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_lms_002",
      "question": "Describe the structure of the `BadRequestResponse` schema in the LMS API. Which fields are required, and which additional fields may be included to provide more error details?",
      "category": "schema",
      "generated_answer": "The `BadRequestResponse` schema is an object with the following structure:\n\n**Required fields:**\n- `statusCode` (number)  \n  - Description: HTTP status code  \n  - Example: `400`\n- `message` (string)  \n  - Description: Error message  \n  - Example: `\"Bad Request\"`\n- `timestamp` (string, date-time)  \n  - Description: Timestamp when the error occurred  \n  - Example: `\"2023-05-30T00:00:00.000Z\"`\n\nThese three fields are listed in the `required` array.\n\n**Optional (additional) fields for more error details:**\n- `data`  \n  - Description: Error details  \n  - Type: `UnifiedError` (via `allOf: [{\"$ref\": \"#/components/schemas/UnifiedError\"}]`)  \n  - Nullable: `true`\n- `provider_errors`  \n  - Description: List of provider-specific errors  \n  - Type: array of `ProviderError` (`items: {\"$ref\": \"#/components/schemas/ProviderError\"}`)  \n  - Nullable: `true`\n\nSo every `BadRequestResponse` must include `statusCode`, `message`, and `timestamp`, and may additionally include `data` and `provider_errors` for more granular error information.",
      "ground_truth_answer": "The `BadRequestResponse` schema in the LMS API includes the following properties: `statusCode`, `message`, `timestamp`, `data`, and `provider_errors`. Among these, `statusCode`, `message`, and `timestamp` are required fields and must always be present. The `data` and `provider_errors` properties are optional and may be included to provide additional error details from the provider or about the invalid request payload.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling the LMS endpoints (for example, GET /unified/lms/courses), what HTTP authentication scheme must be used, and how should it be provided in the request?",
      "category": "auth",
      "generated_answer": "Use **Bearer token authentication**.\n\nInclude it in the `Authorization` header of every LMS request, for example:\n\n```http\nGET /unified/lms/courses HTTP/1.1\nHost: api.your-domain.com\nAuthorization: Bearer YOUR_ACCESS_TOKEN\nx-account-id: YOUR_ACCOUNT_ID\n```\n\nSo the scheme is `Bearer`, and the token is passed as the header value `Authorization: Bearer <token>`.",
      "ground_truth_answer": "The LMS API uses HTTP Basic authentication. Clients must send credentials using the standard Authorization header with the \"Basic\" scheme, where the username and password are base64-encoded in the form `username:password`. In other words, each request (such as GET /unified/lms/courses) must include an `Authorization: Basic <base64-encoded-credentials>` header.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "factual_iam_001",
      "question": "Which HTTP method and endpoint should you use to retrieve a list of IAM users, and what is the required header parameter for account scoping?",
      "category": "factual",
      "generated_answer": "Use an HTTP **GET** request to the endpoint:\n\n`/unified/iam/users`\n\nThe required header parameter for account scoping is:\n\n`x-account-id` (type: string).",
      "ground_truth_answer": "To retrieve a list of IAM users, you must send a GET request to the /unified/iam/users endpoint. The request must include the x-account-id header parameter to scope the operation to a specific account.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "factual_iam_002",
      "question": "When updating an IAM user by ID, which endpoint and required parameters must be provided according to the specification?",
      "category": "factual",
      "generated_answer": "To update an IAM user by ID, use the following endpoint and required parameters:\n\n**HTTP method and endpoint:**\n- `PATCH /unified/iam/users/{id}`\n\n**Required parameters:**\n1. **Header parameter**\n   - `x-account-id` (string) \u2013 The account identifier.\n\n2. **Path parameter**\n   - `id` (string) \u2013 The ID of the user to update.\n\n3. **Request body**\n   - A JSON body matching the schema `IamUpdateUserRequestDto` (e.g., can include fields like `primary_email_address`, etc.), and it is required.",
      "ground_truth_answer": "To update an IAM user by ID, you must send a PATCH request to /unified/iam/users/{id}. The required parameters are the path parameter id and the header parameter x-account-id.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": false
    },
    {
      "question_id": "factual_iam_003",
      "question": "Compare the list operations for IAM users, roles, groups, and policies. Which common query parameters are supported across all four list endpoints, and which additional parameter is shared only by list endpoints that support filtering?",
      "category": "factual",
      "generated_answer": "Across the four IAM list endpoints (users, roles, groups, and policies):\n\n- **Common query parameters supported by all four list endpoints:**\n  - `raw` (query): `boolean` \u2013 whether to return the raw provider result alongside the mapped result.  \n  - `proxy` (query): `object` \u2013 deepObject-style bag for passing through provider-specific query parameters via the `proxy` key.\n\n- **Additional parameter shared only by list endpoints that support filtering:**\n  - `filter` (query): an object that allows custom filtering of the list response (e.g., by `account_ids`, `start_date`, `end_date`, etc.).",
      "ground_truth_answer": "All four list endpoints\u2014GET /unified/iam/users, GET /unified/iam/roles, GET /unified/iam/groups, and GET /unified/iam/policies\u2014support the common query parameters raw, proxy, and fields, and all require the x-account-id header. In addition, each of these list endpoints also supports the filter parameter for filtering results.",
      "retrieval_hit": false,
      "keyword_coverage": 0.3333333333333333,
      "accuracy_score": 3,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_iam_001",
      "question": "Which IAM endpoint should I use to retrieve the details of a specific role by its ID, and what path parameter is required?",
      "category": "endpoint",
      "generated_answer": "Use the `GET /unified/iam/roles/{id}` endpoint to retrieve a specific role by its ID.\n\nThe required path parameter is:\n- `id` (string) \u2013 the identifier of the role you want to retrieve.",
      "ground_truth_answer": "Use the GET /unified/iam/roles/{id} endpoint to retrieve the details of a specific role. You must provide the role identifier as the path parameter {id}.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_iam_002",
      "question": "You need to look up IAM groups that match certain criteria and return only selected fields for each group. Which endpoint supports this operation, and which query parameters enable filtering and field selection?",
      "category": "endpoint",
      "generated_answer": "The operation is supported by the **IAM Groups \u201cList\u201d endpoint** (the GET endpoint that lists IAM groups).\n\nYou would use these query parameters:\n\n- **`filter`** (in `query`, `style: deepObject`):  \n  Used to specify the criteria the IAM groups must match (e.g., by updated date, ID-like fields, etc., depending on the IAM Groups filter schema).\n\n- **`fields`** (in `query`):  \n  `\"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\"`  \n  Example:  \n  `?fields=id,remote_id,external_reference,active,email,created_at,updated_at`\n\nSo:  \n**Endpoint:** `GET /iam/groups` (or equivalent \u201cList IAM Groups\u201d route in your API)  \n**Filtering:** via `filter[...]` query parameters  \n**Field selection:** via the `fields` query parameter.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint to look up IAM groups with filtering and field selection. This endpoint supports the query parameters filter for applying criteria to the results and fields for selecting which fields are returned for each group.",
      "retrieval_hit": false,
      "keyword_coverage": 0.75,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "schema_iam_001",
      "question": "For the IAM API, what fields are always required in a BadRequestResponse object, and which additional optional fields can it include?",
      "category": "schema",
      "generated_answer": "For the IAM API, a `BadRequestResponse` object **must always** include these fields:\n\n- `statusCode`\n- `message`\n- `timestamp`\n\nIt **can additionally and optionally** include:\n\n- `data` (containing `UnifiedError` details, nullable)\n- `provider_errors` (array of `ProviderError` objects, nullable)",
      "ground_truth_answer": "In the IAM API, a BadRequestResponse object must always include the following required fields: `statusCode`, `message`, and `timestamp`. It can additionally include the optional fields `data` and `provider_errors`, which are not required but may be present in the response.",
      "retrieval_hit": true,
      "keyword_coverage": 0.875,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "schema_iam_002",
      "question": "Compare the DeleteResult schema with the ConflictResponse schema in the IAM API. Which fields are required in both, and how do their structures differ from the BadGatewayResponse and ForbiddenResponse schemas, if at all?",
      "category": "schema",
      "generated_answer": "From the snippet you provided, we can see references to these schemas:\n\n- `DeleteResult`\n- `ConflictResponse`\n- `BadGatewayResponse`\n- `ForbiddenResponse`\n- `BadRequestResponse`\n- `UnauthorizedResponse`\n- `NotFoundResponse`\n\nHowever, only their *references* appear in the `responses` section; the actual **schema definitions** of `DeleteResult`, `ConflictResponse`, `BadGatewayResponse`, and `ForbiddenResponse` (i.e., what properties they contain, which fields are required, and their types) are not included in the excerpt.\n\nBecause those schema objects (`#/components/schemas/DeleteResult`, `#/components/schemas/ConflictResponse`, etc.) are not expanded in the provided context, it\u2019s not possible to state:\n\n- which specific fields are required in both `DeleteResult` and `ConflictResponse`, or  \n- exactly how their structures differ from `BadGatewayResponse` and `ForbiddenResponse`.\n\nIn other words, the OpenAPI fragment only tells us:\n\n- **Where** these schemas are used (e.g., as the response body for 200, 400, 403, etc.),\n- **That** they exist under `#/components/schemas/...`,\n\nbut not:\n\n- The properties each schema has,\n- Which properties are required.\n\nTo answer your question accurately, we would need to see the `components.schemas` section for at least:\n\n```yaml\ncomponents:\n  schemas:\n    DeleteResult: ...\n    ConflictResponse: ...\n    BadGatewayResponse: ...\n    ForbiddenResponse: ...\n```\n\nIf you can provide that part of the spec (or the definitions of those four schemas), I can then:\n\n1. List the required fields that `DeleteResult` and `ConflictResponse` have in common.\n2. Describe how those two differ structurally from `BadGatewayResponse` and `ForbiddenResponse` (field names, types, nesting, etc.).",
      "ground_truth_answer": "In the IAM API, the DeleteResult and ConflictResponse schemas share the same set of required fields: `statusCode`, `message`, and `timestamp`. Both DeleteResult and ConflictResponse have these three properties and all three are required. The BadGatewayResponse and ForbiddenResponse schemas also have the exact same structure: properties `statusCode`, `message`, and `timestamp`, all of which are required. Therefore, DeleteResult, ConflictResponse, BadGatewayResponse, and ForbiddenResponse do not differ in structure: each consists of the same three fields (`statusCode`, `message`, `timestamp`), and all three fields are required in every one of these schemas.",
      "retrieval_hit": true,
      "keyword_coverage": 0.5555555555555556,
      "accuracy_score": 2,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "auth_iam_001",
      "question": "Which authentication scheme must be used when calling the IAM endpoints (for example, GET /unified/iam/users), and how should the credentials be sent in the HTTP request?",
      "category": "auth",
      "generated_answer": "The IAM endpoints use **HTTP Basic authentication**.\n\nYou must:\n\n1. Combine your username and password as:  \n   `username:password`\n2. Base64\u2011encode that string.\n3. Send it in the `Authorization` header as:  \n   `Authorization: Basic <base64(username:password)>`\n\nFor example:\n```http\nGET /unified/iam/users HTTP/1.1\nHost: api.example.com\nAuthorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\nx-account-id: your-account-id\n```",
      "ground_truth_answer": "The IAM API uses HTTP Basic authentication. Clients must send their credentials in the Authorization header using the Basic scheme, i.e., an `Authorization: Basic <base64-encoded-credentials>` header must be included with each request to endpoints such as `/unified/iam/users` or `/unified/iam/roles`.",
      "retrieval_hit": true,
      "keyword_coverage": 0.6,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_crm_001",
      "question": "Which HTTP method and endpoint should be used to create a new CRM contact, and what is the required header parameter that must be included with this request?",
      "category": "factual",
      "generated_answer": "Use the **POST** method on the endpoint:\n\n`/unified/crm/contacts`\n\nThe request must include the required header parameter:\n\n`x-account-id` (the account identifier).",
      "ground_truth_answer": "To create a new CRM contact, you must send a POST request to the endpoint `/unified/crm/contacts`. This request must include the `x-account-id` header parameter.",
      "retrieval_hit": true,
      "keyword_coverage": 0.75,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_crm_002",
      "question": "When retrieving a specific CRM contact by ID, which endpoint should be called, which HTTP method is used, and what are two optional query or header parameters (other than `id`) that can modify how the contact data is returned?",
      "category": "factual",
      "generated_answer": "To retrieve a specific CRM contact by ID:\n\n- **Endpoint:** `GET /unified/crm/contacts/{id}`\n- **HTTP method:** `GET`\n- **Two optional parameters (other than `id`):**\n  - Query parameter: **`raw`** \u2013 if `true`, returns the raw provider result in addition to the mapped result.\n  - Header parameter: **`x-account-id`** \u2013 identifies which account\u2019s data to access (required overall, but it modifies *which* contact data is returned).  \n\nAnother optional query parameter that can modify behavior is:\n  - **`proxy`** \u2013 used to pass through query params to the underlying provider request.",
      "ground_truth_answer": "To retrieve a specific CRM contact by ID, you call the `GET /unified/crm/contacts/{id}` endpoint. In addition to the required `id` path parameter, the request can include optional parameters such as the `x-account-id` header and the `fields`, `raw`, or `proxy` query parameters to modify how the contact data is returned.",
      "retrieval_hit": true,
      "keyword_coverage": 0.8333333333333334,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_crm_003",
      "question": "For listing CRM contact custom field definitions, which exact endpoint and HTTP method must be used, and which filter-related parameter can be applied to narrow down the returned definitions?",
      "category": "factual",
      "generated_answer": "For listing CRM contact custom field definitions, use:\n\n- **Endpoint:** `GET /unified/crm/custom_field_definitions/contacts`  \n- **HTTP method:** `GET`  \n- **Filter-related parameter:** the **`proxy`** query parameter, which lets you pass through filter parameters to the underlying provider request.",
      "ground_truth_answer": "To list CRM contact custom field definitions, you must send a GET request to the endpoint `/unified/crm/custom_field_definitions/contacts`. You can use the `filter` parameter to narrow down the returned custom field definitions.",
      "retrieval_hit": true,
      "keyword_coverage": 0.75,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_crm_001",
      "question": "Which endpoint should I use to retrieve a paginated list of all CRM contacts, and what is the required header I must include with the request?",
      "category": "endpoint",
      "generated_answer": "Use the endpoint that returns `ContactsPaginated` in its 200-response schema\u2014that is, the **\u201clist contacts\u201d** CRM endpoint (typically something like `GET /crm/contacts` in this API).\n\nYou must include the **authorization header** with the request, generally:\n\n- `Authorization: Bearer <your_access_token>`",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint to retrieve a paginated list of all CRM contacts. You must include the x-account-id header in the request, as it is a required parameter for this endpoint.",
      "retrieval_hit": true,
      "keyword_coverage": 0.6,
      "accuracy_score": 2,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_crm_002",
      "question": "If I want to modify an existing CRM contact\u2019s details, which exact endpoint and HTTP method should I call, and which path parameter is required to identify the contact?",
      "category": "endpoint",
      "generated_answer": "You should call the endpoint:\n\n- **HTTP method:** `PUT`  \n- **Endpoint:** `/unified/crm/contacts/{id}`  \n- **Required path parameter:** `id` (the identifier of the contact you want to update)",
      "ground_truth_answer": "To modify an existing CRM contact\u2019s details, call the PATCH /unified/crm/contacts/{id} endpoint. The required path parameter is id, which identifies the contact to update. This endpoint is marked as early access and also requires the x-account-id header.",
      "retrieval_hit": true,
      "keyword_coverage": 0.0,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "schema_crm_001",
      "question": "In the CRM API, which fields are required in the `AccountsPaginated` schema, and what is the purpose of the `next_page` and `data` properties in this response object?",
      "category": "schema",
      "generated_answer": "In the `AccountsPaginated` schema, the only required field is:\n\n- `data`\n\nThe purpose of the properties is:\n\n- `next_page` (deprecated, nullable string): Contains a cursor or token for fetching the next page of results in older pagination implementations. It may be omitted or `null` if there is no next page.  \n- `data` (required array of `Account` objects): Contains the actual list of account records returned for the current page of the paginated response.",
      "ground_truth_answer": "In the `AccountsPaginated` schema, the only required field is `data`. The schema includes the properties `next_page`, `next`, `data`, and `raw`, but only `data` is mandatory. The `data` property contains the actual collection of account records returned for the current page and must always be present. The `next_page` property is an optional field that indicates the token, cursor, or reference needed to request the next page of account results, allowing the client to paginate through additional accounts if more data is available.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8333333333333334,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "schema_crm_002",
      "question": "Compare the `BadRequestResponse` and `BadGatewayResponse` error schemas in the CRM API. Which fields are required in each, and what additional fields does `BadRequestResponse` define that are not present in `BadGatewayResponse`?",
      "category": "schema",
      "generated_answer": "In the CRM API:\n\n**BadGatewayResponse** schema  \n- **Required fields:**\n  - `statusCode`\n  - `message`\n  - `timestamp`\n- **Defined fields:**\n  - `statusCode` (number) \u2013 HTTP status code (example: 502)  \n  - `message` (string) \u2013 Error message (example: \"Bad Gateway\")  \n  - `timestamp` (string, date-time) \u2013 When the error occurred  \n\n**BadRequestResponse** schema  \n- **Required fields:**\n  - `statusCode`\n  - `message`\n  - `timestamp`\n- **Defined fields (in addition to the above three):**\n  - `data` \u2013 Error details (nullable, `UnifiedError`)  \n  - `provider_errors` \u2013 List of provider-specific errors (nullable, array of `ProviderError`)  \n\n**Comparison / extra fields**  \nBoth schemas require the same three fields: `statusCode`, `message`, and `timestamp`.  \n`BadRequestResponse` includes two additional, non-required fields that `BadGatewayResponse` does not have:\n\n1. `data`  \n2. `provider_errors`",
      "ground_truth_answer": "Both `BadRequestResponse` and `BadGatewayResponse` in the CRM API share the required fields `statusCode`, `message`, and `timestamp`. In `BadGatewayResponse`, these three properties are the only defined fields, and all of them are required. In contrast, `BadRequestResponse` also defines two additional properties: `data` and `provider_errors`. These extra fields are not present in `BadGatewayResponse`. However, in `BadRequestResponse` only `statusCode`, `message`, and `timestamp` are required; `data` and `provider_errors` are optional.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "auth_crm_001",
      "question": "What authentication scheme must be used when calling any of the CRM endpoints (for example, GET /unified/crm/contacts), and how should it be included in the HTTP request?",
      "category": "auth",
      "generated_answer": "The CRM endpoints use **HTTP Basic authentication**.\n\nInclude it in the request\u2019s `Authorization` header like this:\n\n```http\nGET /unified/crm/contacts HTTP/1.1\nHost: api.example.com\nAuthorization: Basic <base64(username:password)>\nx-account-id: <your-account-id>\n```\n\nWhere `<base64(username:password)>` is the Base64-encoded string of `username:password`.",
      "ground_truth_answer": "The CRM API uses HTTP Basic authentication. Clients must send credentials using the standard Authorization header with the \"Basic\" scheme (i.e., an Authorization: Basic <base64-encoded-credentials> header) on requests to endpoints such as /unified/crm/contacts and the other CRM paths.",
      "retrieval_hit": true,
      "keyword_coverage": 0.5,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "factual_marketing_001",
      "question": "Which HTTP methods are supported by the `/unified/marketing/templates/email` endpoint, and what is the purpose of each method?",
      "category": "factual",
      "generated_answer": "The `/unified/marketing/templates/email` endpoint supports at least two HTTP methods:\n\n1. **POST**  \n   - **Purpose:** Create a new email template.  \n   - **Behavior:**  \n     - Expects a JSON body matching `MarketingCreateEmailTemplateRequestDto`.  \n     - On success, returns **201** \u201cRecord created successfully.\u201d with a `CreateResult` object.  \n     - May return 400, 401, 403, or 404 on error.\n\n2. **PUT** (or PATCH-like update; shown as \u201cRecord updated successfully\u201d)  \n   - **Purpose:** Update an existing email template.  \n   - **Behavior:**  \n     - Expects a JSON body matching `MarketingCreateEmailTemplateRequestDto` (same schema as create).  \n     - On success, returns **200** \u201cRecord updated successfully\u201d with a `CreateResult` object.  \n     - May return 400, 401, 403, or 404 on error.",
      "ground_truth_answer": "The `/unified/marketing/templates/email` endpoint supports two HTTP methods:\n- `GET /unified/marketing/templates/email`: Lists Email Templates. It is used to retrieve a collection of email templates and accepts the parameters `x-account-id`, `raw`, `proxy`, `fields`, and `filter`.\n- `POST /unified/marketing/templates/email`: Creates Email Templates. It is used to create a new email template and accepts the `x-account-id` parameter.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "factual_marketing_002",
      "question": "When retrieving a specific SMS template using the MARKETING API, which endpoint and HTTP method should be used, and what are all the parameters supported by that operation?",
      "category": "factual",
      "generated_answer": "Use the **GET** method on the **`/marketing/sms/templates/{id}`** endpoint.\n\n**Endpoint:**\n- `GET /marketing/sms/templates/{id}`\n\n**Supported parameters:**\n\n1. **Path parameter**\n   - `id`  \n     - Location: path  \n     - Type: string (typically the template identifier)  \n     - Required: yes  \n\n2. **Standard error/timeout behavior (not explicit parameters but relevant to the operation)**\n   - The operation may return:\n     - `400` \u2013 BadRequestResponse (invalid request)\n     - `401` \u2013 UnauthorizedResponse\n     - `403` \u2013 ForbiddenResponse\n     - `404` \u2013 NotFoundResponse\n     - `408` \u2013 Request timeout, with a `Retry-After` response header (time in seconds after which the request can be retried)\n\nNo additional query or body parameters are defined for this specific retrieval operation.",
      "ground_truth_answer": "To retrieve a specific SMS template, you use the `GET /unified/marketing/templates/sms/{id}` endpoint. This operation supports the following parameters: `x-account-id`, `id`, `raw`, `proxy`, and `fields`.",
      "retrieval_hit": false,
      "keyword_coverage": 0.16666666666666666,
      "accuracy_score": 2,
      "completeness_score": 2,
      "has_hallucination": false
    },
    {
      "question_id": "factual_marketing_003",
      "question": "Compare the list operations for In-App, Omni-Channel, and Push templates in the MARKETING API. For each of these three template types, specify the full list endpoint path, HTTP method, and all supported query or header parameters for listing templates. Highlight any similarities in their parameter sets.",
      "category": "factual",
      "generated_answer": "Here\u2019s a structured comparison of the three list operations in the MARKETING API based on the provided context.\n\n---\n\n## 1. In-App Templates\n\n**Endpoint path**  \n`/unified/marketing/templates/in_app`\n\n**HTTP method**  \n`GET`\n\n**Parameters**\n\n- **Header**\n  - `x-account-id` (required, string)  \n    Description: The account identifier.\n\n- **Query**\n  - `raw` (optional, boolean, nullable)  \n    Description: Indicates that the raw request result should be returned in addition to the mapped result (default is `false`).\n  - `proxy` (optional, object, nullable, `style: deepObject`, `explode: true`, `additionalProperties: true`)  \n    Description: Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with the `proxy` key.\n\n*(The snippet shows the same parameter structure pattern as the other list endpoints, so this mirrors them.)*\n\n---\n\n## 2. Omni-Channel Templates\n\n**Endpoint path**  \n`/unified/marketing/templates/omni_channel`\n\n**HTTP method**  \n`GET`\n\n**Notes**  \n- Marked as **deprecated**:\n  - `\"deprecated\": true`\n  - OperationId: `marketing_list_omni_channel_templates`\n\n**Parameters**\n\n- **Header**\n  - `x-account-id` (required, string)  \n    Description: The account identifier.\n\n- **Query**\n  - `raw` (optional, boolean, nullable)  \n    Description: Indicates that the raw request result should be returned in addition to the mapped result (default is `false`).\n  - `proxy` (optional, object, nullable, `style: deepObject`, `explode: true`, `additionalProperties: true`)  \n    Description: Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with the `proxy` key.\n\n---\n\n## 3. Push Templates\n\n**Endpoint path**  \n`/unified/marketing/templates/push`\n\n**HTTP method**  \n`GET`\n\n**Notes**  \n- OperationId: `marketing_list_push_templates`\n\n**Parameters**\n\n- **Header**\n  - `x-account-id` (required, string)  \n    Description: The account identifier.\n\n- **Query**\n  - `raw` (optional, boolean, nullable)  \n    Description: Indicates that the raw request result should be returned in addition to the mapped result (default is `false`).\n  - `proxy` (optional, object, nullable, `style: deepObject`, `explode: true`, `additionalProperties: true`)  \n    Description: Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with the `proxy` key.\n\n---\n\n## Similarities in Parameter Sets\n\nAcross **In-App**, **Omni-Channel**, and **Push** template list operations:\n\n- All use `GET` on a `/unified/marketing/templates/{type}` path.  \n- All require the **same header parameter**:\n  - `x-account-id` (required, string).\n- All support the **same query parameters**:\n  - `raw` (optional boolean, controls inclusion of raw provider result).\n  - `proxy` (optional object, deepObject style, used for pass-through query parameters to the underlying provider).\n- They share the same general behavior regarding \u201craw result\u201d and \u201cproxy\u201d passthrough.\n\nThe primary difference from the context provided is that the **Omni-Channel list endpoint is deprecated**, while the Push and In-App list endpoints are not indicated as deprecated.",
      "ground_truth_answer": "All three template types\u2014In-App, Omni-Channel, and Push\u2014use `GET` list endpoints with the same parameter set.\n\n1. In-App templates:\n- Endpoint and method: `GET /unified/marketing/templates/in_app`\n- Parameters: `x-account-id`, `raw`, `proxy`, `fields`, `filter`\n\n2. Omni-Channel templates:\n- Endpoint and method: `GET /unified/marketing/templates/omni_channel`\n- Parameters: `x-account-id`, `raw`, `proxy`, `fields`, `filter`\n\n3. Push templates:\n- Endpoint and method: `GET /unified/marketing/templates/push`\n- Parameters: `x-account-id`, `raw`, `proxy`, `fields`, `filter`\n\nSimilarity: All three list operations use the `GET` method and share the same parameter set: `x-account-id`, `raw`, `proxy`, `fields`, and `filter`.",
      "retrieval_hit": false,
      "keyword_coverage": 0.375,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "endpoint_marketing_001",
      "question": "Which endpoint should I use to list all SMS templates for an account, and what required header parameter must I include?",
      "category": "endpoint",
      "generated_answer": "You should use the `GET /unified/marketing/templates/sms` endpoint to list all SMS templates for an account.\n\nThe required header parameter you must include is:\n\n- `x-account-id` (The account identifier)",
      "ground_truth_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to list all SMS templates. You must include the `x-account-id` header as a required parameter.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "endpoint_marketing_002",
      "question": "I need to update an existing in-app template\u2019s content for a specific tenant. Which exact endpoint and parameters (including path and header fields) are required to perform this update?",
      "category": "endpoint",
      "generated_answer": "To update an existing in-app template\u2019s content for a specific tenant, you must call the **Update In-App Template** endpoint (the `PATCH` operation).\n\n**Endpoint (method + path)**  \n```http\nPATCH /marketing/in-app/templates/{id}\n```\n> Note: The exact base path (`/marketing/in-app/templates`) is inferred from the operation context; `{id}` is the template ID path parameter.\n\n**Required parameters**\n\n1. **Path parameter**\n   - `id` (in `path`, required)  \n     - Type: `string`  \n     - Description: The unique identifier of the in-app template you want to update.\n\n2. **Header parameter**\n   - `x-account-id` (in `header`, required)  \n     - Type: `string`  \n     - Description: The account/tenant identifier for which the template content should be updated.\n\n**Request body (key field for content)**\n- You send a JSON body containing the template fields to update, including:\n  - `message_content` (nullable, object of type `InAppMessageContents`) \u2013 this is where you provide the new in-app template content.\n\n**Example request (schematic)**\n\n```http\nPATCH /marketing/in-app/templates/8187e5da-dc77-475e-9949-af0f1fa4e4e3 HTTP/1.1\nHost: api.yourdomain.com\nx-account-id: your-tenant-id\nContent-Type: application/json\n\n{\n  \"message_content\": {\n    /* InAppMessageContents fields here */\n  }\n}\n```\n\nSo, to update the template\u2019s content for a specific tenant, you must use:\n- `PATCH /marketing/in-app/templates/{id}`\n- with `x-account-id` in the header,\n- and `id` in the path, plus a body including `message_content`.",
      "ground_truth_answer": "To update an existing in-app template, call the `PATCH /unified/marketing/templates/in_app/{id}` endpoint. You must provide the `id` path parameter for the template you want to update and include the `x-account-id` header parameter for the tenant/account context.",
      "retrieval_hit": false,
      "keyword_coverage": 0.8,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "schema_marketing_001",
      "question": "For the `BadRequestResponse` schema in the MARKETING API, which fields are required, and what additional (optional) fields can it include beyond those required ones?",
      "category": "schema",
      "generated_answer": "For the `BadRequestResponse` schema in the MARKETING API:\n\n**Required fields:**\n- `type`\n- `title`\n- `status`\n\nThese three form the minimal structure that a `BadRequestResponse` must have.\n\n**Optional (additional) fields it can include:**\n- `detail` \u2013 a human-readable explanation of the error\n- `errors` \u2013 a structured collection of validation or field-level errors (often a map/dictionary where keys are field names and values are error messages or arrays of messages)\n\nSo: `type`, `title`, and `status` are required; `detail` and `errors` are optional extras that may be present in the response.",
      "ground_truth_answer": "In the MARKETING API, the `BadRequestResponse` schema has three required fields: `statusCode`, `message`, and `timestamp`. In addition to these required fields, the schema can also include two optional fields: `data` and `provider_errors`. All five properties (`statusCode`, `message`, `timestamp`, `data`, and `provider_errors`) are defined on the schema, but only the first three are required.",
      "retrieval_hit": false,
      "keyword_coverage": 0.42857142857142855,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "schema_marketing_002",
      "question": "In the MARKETING API, compare the `CampaignsPaginated` and `ContentBlocksPaginated` schemas: what common fields do they share, and which field in each schema contains the primary list of returned entities?",
      "category": "schema",
      "generated_answer": "Both `CampaignsPaginated` and `ContentBlocksPaginated` share these common fields:\n\n- `next_page` (string, nullable, deprecated)\n- `next` (string, nullable)\n- `data` (array)\n- `raw` (array of `RawResponse`, nullable)\n\nIn each schema, the **primary list of returned entities** is held in the `data` field:\n- In `CampaignsPaginated`, `data` is an array of `Campaign`.\n- In `ContentBlocksPaginated`, `data` is an array of `ContentBlock`.",
      "ground_truth_answer": "Both `CampaignsPaginated` and `ContentBlocksPaginated` are pagination wrapper schemas in the MARKETING API. They share the same four properties: `next_page`, `next`, `data`, and `raw`. In both schemas, the `data` field is the primary field that contains the list of returned entities (campaigns for `CampaignsPaginated` and content blocks for `ContentBlocksPaginated`). The `data` field is required in both schemas, while `next_page`, `next`, and `raw` are additional properties that provide pagination or raw-response metadata.",
      "retrieval_hit": false,
      "keyword_coverage": 0.875,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": false
    },
    {
      "question_id": "auth_marketing_001",
      "question": "What authentication scheme does the MARKETING API use, and how should it be included in requests to the /unified/marketing/templates/email endpoint?",
      "category": "auth",
      "generated_answer": "The MARKETING API uses **API key authentication** via the `Authorization` header.\n\nFor calls to `/unified/marketing/templates/email`, include your key like this:\n\n```http\nPOST /unified/marketing/templates/email HTTP/1.1\nHost: api.your-provider.com\nAuthorization: Apideck-Api-Key YOUR_API_KEY_HERE\nContent-Type: application/json\n```\n\nReplace `YOUR_API_KEY_HERE` with your actual MARKETING API key.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication. Clients must include an Authorization header on requests to endpoints such as /unified/marketing/templates/email. The header must use the \"Basic\" scheme and contain a base64-encoded string of the API credentials in the format username:password (e.g., Authorization: Basic <base64-encoded-credentials>).",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "cross_api_001",
      "question": "How would you move a successful job applicant from the ATS system into the HRIS as a new employee, and which endpoints in both APIs would you use to fetch the application data and then create the corresponding employee record?",
      "category": "cross_api",
      "generated_answer": "You would:\n\n1. **Get the successful applicant\u2019s data from the ATS**, then  \n2. **Create a new employee in the HRIS** using that data (and optionally create related employment / work-eligibility records).\n\nBased on the schema fragments you provided, you\u2019d use:\n\n---\n\n### 1. Fetch the application / candidate data from the ATS\n\nTypical flow (names inferred from the `AtsJobResult`/`AtsJob` schema in your snippet):\n\n- **Get the job posting** (if needed, to confirm the role, code, etc.):\n  - `GET /ats/jobs/{job_id}`  \n  - Response type: `AtsJobResult` \u2192 `.data` is an `AtsJob`.\n\n- **Get the application / candidate record associated with the successful applicant**:\n  - Commonly something like:\n    - `GET /ats/applications/{application_id}`  \n      or  \n    - `GET /ats/jobs/{job_id}/applications` then filter by status = \"hired\"/\"offer accepted\".\n  - From this, you extract:\n    - Name (first, last)\n    - Email\n    - Start date\n    - Role / job title\n    - Compensation, department, manager, etc., as available\n\n(Exact ATS endpoint names may vary, but the key point is: a `GET` on the ATS \u201capplications\u201d or \u201ccandidates\u201d resource to retrieve the accepted application.)\n\n---\n\n### 2. Create the employee in the HRIS\n\n#### 2.1. Create the base employee record\n\nUse the HRIS \u201ccreate employee\u201d endpoint with `HrisCreateEmployeeRequestDto`:\n\n- **Endpoint**:  \n  `POST /hris/employees`  \n  **Headers**:  \n  - `x-account-id: {your-account-id}`\n\n- **Body (HrisCreateEmployeeRequestDto)** \u2013 map ATS fields into it, e.g.:\n\n```json\n{\n  \"title\": \"Mr\",\n  \"first_name\": \"Isaac\",\n  \"last_name\": \"Doe\",\n  \"email\": \"isaac.doe@example.com\",\n  \"passthrough\": {\n    \"ats_application_id\": \"abc123\",\n    \"other_known_names\": \"Isaac J. Doe\"\n  }\n}\n```\n\nThe response will include the new HRIS employee `id` you\u2019ll need for subsequent calls.\n\n---\n\n#### 2.2. (Optional) Create the employee\u2019s employment record\n\nOnce you have the employee `id`, create an employment entry (job, start date, etc.):\n\n- **Endpoint**:  \n  `POST /hris/employees/{id}/employments`  \n  **Headers**:  \n  - `x-account-id: {your-account-id}`\n\nYou would map, for example, job title, start date, and compensation from the ATS application into this request body (schema not fully shown, but it will be the employment DTO associated with this endpoint).\n\nYou can later list/check it with:\n\n- `GET /hris/employees/{id}/employments`  \n  (operationId: `hris_list_employee_employments`)\n\n---\n\n#### 2.3. (Optional) Create work eligibility for the employee\n\nIf your flow includes right\u2011to\u2011work / visa / work authorization data:\n\n- **Endpoint**:  \n  `POST /hris/employees/{id}/work-eligibility`  \n  (operationId: `hris_create_employee_work_eligibility_request`)  \n  **Headers**:  \n  - `x-account-id: {your-account-id}`\n\nYou can later list/check with:\n\n- `GET /hris/employees/{id}/work-eligibility`  \n  (operationId: `hris_list_employee_work_eligibility`)\n\n---\n\n### Summary of key endpoints\n\n**ATS side (read):**\n\n- `GET /ats/jobs/{job_id}` \u2192 job info (`AtsJobResult` / `AtsJob`)\n- `GET /ats/applications/{application_id}` (or similar) \u2192 successful application data\n\n**HRIS side (create):**\n\n- `POST /hris/employees`  \n  - Body: `HrisCreateEmployeeRequestDto`\n- `POST /hris/employees/{id}/employments`  \n  - Use new employee `id` and map job/offer details from ATS\n- `POST /hris/employees/{id}/work-eligibility` (optional)  \n\nThis sequence moves the successful applicant from ATS into HRIS as a fully\u2011onboarded employee.",
      "ground_truth_answer": "To move a successful applicant from ATS into HRIS, you would first use the ATS unified applications endpoints to read the candidate\u2019s data, then use the HRIS unified employees endpoints to create the employee.\n\n1. From ATS, retrieve the application and candidate details:\n- List or locate the application via `GET /unified/ats/applications` (using filters if available in the full spec) or fetch directly by ID via `GET /unified/ats/applications/{id}`.\n- The `Application` schema (and related models like `ApplicationCandidate`, `ApplicationResult`, `ApplicationsPaginated`) define fields such as candidate name, contact info, status, associated offers, and stage, which you\u2019ll map into HRIS fields.\n\n2. Optionally, if offer or stage data is needed (e.g., salary, position):\n- Use `GET /unified/ats/applications/{id}/offers` or `GET /unified/ats/applications/{id}/offers/{subResourceId}` to read offer details from ATS.\n\n3. In HRIS, create the employee:\n- Use `POST /unified/hris/employees` to create a new employee record. The `Company` and `Employee`-related schemas (e.g., `Company`, `CompanyResult`, `CompaniesPaginated`, and enums like `ContractTypeEnum`, `BenefitsTypeEnum`) describe how to represent employment data such as contract type, benefits, and possibly bank/clearing details.\n\n4. After creation, you can:\n- Retrieve the new employee using `GET /unified/hris/employees` (with filters) or `GET /unified/hris/employees/{id}` to confirm the mapping.\n\nThe workflow is: read from ATS (`/unified/ats/applications` and child resources) \u2192 transform/map fields \u2192 create in HRIS via `/unified/hris/employees`.",
      "retrieval_hit": false,
      "keyword_coverage": 0.4,
      "accuracy_score": 2,
      "completeness_score": 2,
      "has_hallucination": true
    },
    {
      "question_id": "cross_api_002",
      "question": "If I want to ensure that IAM user identities are consistent with HRIS employee records, which endpoints from the IAM and HRIS APIs should I use to list users and employees and then link them together by a shared identifier such as email?",
      "category": "cross_api",
      "generated_answer": "Use these two \u201clist\u201d endpoints, then join the records client\u2011side on a shared identifier (e.g., email):\n\n**From the IAM API (to list IAM users)**  \n- An endpoint that lists IAM users, e.g.:  \n  `GET /unified/iam/users`  \n  (Name may vary in your spec, but you want the collection endpoint that returns all IAM user identities with their emails.)\n\n**From the HRIS API (to list HRIS employees)**  \n- An endpoint that lists employees, e.g.:  \n  `GET /unified/hris/employees`  \n  (Again, the exact path may differ, but it\u2019s the collection endpoint that returns employee records, including `work_email` / `personal_email`.)\n\n**Linking them together**\n\n1. Call `GET /unified/iam/users` and obtain each user\u2019s email field.\n2. Call `GET /unified/hris/employees` and obtain each employee\u2019s `work_email` (and/or `personal_email`).\n3. In your application, match records where the IAM user\u2019s email equals the HRIS employee\u2019s email.\n4. Store or maintain the mapping (e.g., IAM `user_id` \u2194 HRIS `employee_id`) for ongoing synchronization.\n\nThe HRIS endpoints shown in your context (such as `/unified/hris/employees/{id}/invite`, `/unified/hris/employees/{id}/employments`) are per\u2011employee and not for listing; use the top\u2011level HRIS employees \u201clist\u201d endpoint instead.",
      "ground_truth_answer": "To keep IAM users consistent with HRIS employees, you would read from both APIs and link records by a common identifier such as email, external ID, or employee ID.\n\nFrom the HRIS API:\n- Use `GET /unified/hris/employees` to list employees. This endpoint returns a paginated collection of employee records (full details are defined in the HRIS schemas such as `CompaniesPaginated`, `Company`, and employee-related models in the full spec). The records typically include fields like name, email, and employment details.\n- You can also fetch a single employee by `GET /unified/hris/employees/{id}` when you know the HRIS employee ID.\n\nFrom the IAM API:\n- Use `GET /unified/iam/users` to list IAM users. The IAM schemas (`IamGroup`, `IamPermission`, `IamGroupsPaginated`, etc.) define how users, groups, and permissions are structured; the user list will include user identifiers such as username, email, and possibly external IDs.\n- Use `GET /unified/iam/users/{id}` to fetch details of a specific IAM user.\n\nIntegration approach:\n1. Page through HRIS employees via `GET /unified/hris/employees` and IAM users via `GET /unified/iam/users`.\n2. For each IAM user, match to an HRIS employee based on shared fields (e.g., email address or external employee ID).\n3. Optionally, use IAM role and group endpoints (`GET /unified/iam/roles`, `GET /unified/iam/groups`) to ensure that access rights reflect the employee\u2019s HRIS job or organizational data.\n\nThus, the key cross-API endpoints are `/unified/hris/employees` (and `/unified/hris/employees/{id}`) from HRIS and `/unified/iam/users` (and `/unified/iam/users/{id}`) from IAM.",
      "retrieval_hit": false,
      "keyword_coverage": 1.0,
      "accuracy_score": 4,
      "completeness_score": 4,
      "has_hallucination": true
    },
    {
      "question_id": "cross_api_003",
      "question": "How can I synchronize CRM contacts with ATS applications so that when a CRM contact applies for a job, you can find their CRM record and attach its data to the ATS application? Which endpoints from the CRM and ATS APIs would be involved?",
      "category": "cross_api",
      "generated_answer": "You\u2019d use the CRM \u201ccontacts\u201d endpoints together with the ATS \u201ccandidates/applications\u201d endpoints, roughly in this flow:\n\n1. **Identify / look up the CRM contact when an application is created**\n   - Use the CRM Contacts API to search or list contacts by email (or other identifier) from the job application:\n     - `GET /crm/contacts`  \n       (or if available in your spec: `GET /crm/contacts?email={candidate_email}` or a dedicated search endpoint such as `POST /crm/contacts/search`)\n\n2. **Read the CRM contact\u2019s details**\n   - Once you\u2019ve found a match, fetch the full CRM contact record to get all fields you want to attach:\n     - `GET /crm/contacts/{contact_id}`\n\n3. **Create or update the ATS candidate and application with CRM data**\n   - When the job application is received, create or update the candidate in the ATS, including mapped CRM fields in `unified_custom_fields` or similar:\n     - `POST /ats/candidates` (or equivalent candidate create endpoint)\n     - `PATCH /ats/candidates/{candidate_id}` (if updating)\n   - Then create or update the ATS application for that job, referencing the candidate and injecting any CRM-related data you want to persist on the application:\n     - `POST /ats/applications`\n     - `PATCH /ats/applications/{application_id}`\n\n4. **Attach CRM data explicitly to the ATS application (if supported)**\n   - If your ATS model allows custom fields on the application itself, include CRM contact identifiers (e.g. `crm_contact_id`) in:\n     - `AtsCreateApplicationRequestDto` via `POST /ats/applications`\n     - `AtsUpdateApplicationRequestDto` via `PATCH /ats/applications/{application_id}`\n\nSo in summary, the integration will mainly involve:\n\n- **CRM API:**  \n  - `GET /crm/contacts` (and/or search endpoint)  \n  - `GET /crm/contacts/{id}`  \n\n- **ATS API:**  \n  - Candidate endpoints: `POST /ats/candidates`, `PATCH /ats/candidates/{id}`  \n  - Application endpoints: `POST /ats/applications`, `PATCH /ats/applications/{id}`  \n\nThese allow you to find the CRM contact, read their data, and then store a reference and mapped fields on the ATS candidate/application.",
      "ground_truth_answer": "To synchronize CRM contacts with ATS applications, you use CRM endpoints to manage and look up contacts, and ATS endpoints to create or update applications that reference those contacts.\n\nFrom the CRM API:\n- `GET /unified/crm/contacts` \u2014 list existing contacts. The `Contact`, `ContactResult`, and `ContactsPaginated` schemas define contact fields such as name, email, phone, and possibly custom fields.\n- `GET /unified/crm/contacts/{id}` \u2014 fetch a single contact by its CRM ID.\n- `POST /unified/crm/contacts` \u2014 create a new CRM contact when an applicant is not yet in the CRM. The `CrmCreateContactRequestDto` schema describes the required and optional fields to create a contact.\n- `PATCH /unified/crm/contacts/{id}` \u2014 update the existing CRM contact record (e.g., to add an \"is_candidate\" custom flag or link to an ATS application ID).\n\nFrom the ATS API:\n- `POST /unified/ats/applications` \u2014 create a new application for a candidate. The `Application`-related schemas (e.g., `Application`, `ApplicationCandidate`, `ApplicationResult`, `ApplicationsPaginated`) describe how to represent the candidate details and any external references.\n- `GET /unified/ats/applications` or `GET /unified/ats/applications/{id}` \u2014 retrieve applications to find the associated candidate and any CRM link you\u2019ve stored.\n- Optionally, use `PATCH /unified/ats/applications/{id}` to update the application with a reference to the CRM contact ID if you add this link after the initial creation.\n\nWorkflow:\n1. When a person applies, look them up in CRM via `GET /unified/crm/contacts` (filtering by email) or `GET /unified/crm/contacts/{id}` if you already know their ID.\n2. If not found, create the contact with `POST /unified/crm/contacts`.\n3. Create an ATS application using `POST /unified/ats/applications`, including the candidate\u2019s data and optionally storing the CRM contact ID in a field or custom attribute.\n4. Use `PATCH /unified/crm/contacts/{id}` or `PATCH /unified/ats/applications/{id}` to keep cross-references current as the application progresses.\n\nThus, the main cross-API endpoints are `/unified/crm/contacts` (GET/POST/PATCH) on CRM and `/unified/ats/applications` (GET/POST/PATCH) on ATS.",
      "retrieval_hit": false,
      "keyword_coverage": 0.4,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "cross_api_004",
      "question": "Describe how you would onboard a new employee from HRIS into the LMS and IAM systems so they get the right training assignments and access permissions. Which endpoints in HRIS, LMS, and IAM would you call, and in what general order?",
      "category": "cross_api",
      "generated_answer": "Here\u2019s a high\u2011level onboarding flow that stitches HRIS \u2192 LMS \u2192 IAM together, plus which types of endpoints you\u2019d typically call and in what order.\n\n---\n\n## 1. Create / sync the employee in HRIS\n\n**Goal:** Make sure the person exists in HRIS with core attributes (name, email, job, department, manager, groups, etc.), because HRIS is your \u201csource of truth\u201d.\n\n**Typical steps & endpoints (HRIS):**\n\n1. **Create or update the employee record**\n   - `POST /hris/employees` (or `PUT /hris/employees/{id}`)\n   - Payload includes:\n     - Personal / employment info: `first_name`, `last_name`, `email`, `employee_number`\n     - Org / role context: `job_title`, `department_id` or `department`, `manager_id` or `remote_manager_id`\n     - Grouping & cost information: `groups`, `cost_centers`\n     - Compliance/identity data if needed: `national_identity_numbers`, `bank_details` (if your HRIS uses these)\n   - Response gives you the **HRIS employee id** (e.g. `employee_id`), which you\u2019ll use as a key in other systems.\n\n2. (Optional) Fetch full user details to confirm / enrich\n   - `GET /hris/employees/{id}`\n   - Ensures you have all attributes accurately (skills, groups, etc.) to drive training and access rules.\n\nAt this point you have a canonical employee profile in HRIS.\n\n---\n\n## 2. Provision or update the user in IAM\n\n**Goal:** Create a digital identity with correct roles/groups so they get the right system access.\n\n**Typical steps & endpoints (IAM):**\n\n3. **Create user account in IAM**\n   - `POST /iam/users`\n   - Map HRIS fields:\n     - `username` (maybe `employee_number` or corporate email)\n     - `email`\n     - `first_name`, `last_name`\n     - `external_reference`/`hris_id` (store HRIS employee id here for correlation)\n   - Save the **IAM user id**.\n\n4. **Assign IAM groups / roles based on HRIS data**\n   - Logic: derive roles and groups from:\n     - `department` / `department_id`\n     - `job_title`\n     - `manager_id`\n     - `groups` or `cost_centers`\n   - Endpoints:\n     - `POST /iam/users/{iam_user_id}/groups`  \n       or `POST /iam/users/{iam_user_id}/roles`\n   - Example:\n     - Add to group `Engineering`, role `Engineer-Level-1`\n     - Add to location or cost center groups if relevant.\n\n5. (Optional) Configure initial access policies\n   - `POST /iam/users/{iam_user_id}/policies` or similar\n   - Grant access to:\n     - LMS application\n     - Other business apps needed by role\n\nNow the user can authenticate and will have correct access entitlements.\n\n---\n\n## 3. Create / sync the user in the LMS\n\n**Goal:** Have an LMS user linked (directly or indirectly) to the HRIS/IAM identity so we can assign training based on HR attributes.\n\n**Typical steps & endpoints (LMS):**\n\n6. **Create or update the LMS user**\n   - `POST /lms/users` (or `PUT /lms/users/{id}`)\n   - Include:\n     - `email`, `first_name`, `last_name`\n     - `external_reference` (e.g. HRIS `employee_number` or employee id from HRIS)\n     - Org info mirrored from HRIS: `department`, `groups`, `manager_id`\n   - Response gives you the **LMS user id**.\n\n7. (Optional) Link LMS user to IAM identity\n   - If LMS supports SSO / SCIM, you might:\n     - Store IAM user id in an LMS `external_id`, or\n     - Store LMS user id in IAM user metadata.\n   - Example endpoint:\n     - `PUT /iam/users/{iam_user_id}` with `lms_user_id` in custom attributes\n     - or `PUT /lms/users/{lms_user_id}` with `iam_user_id`.\n\n---\n\n## 4. Assign the right training in the LMS\n\n**Goal:** Use HR context to automatically create assignments so this user sees mandatory/compliance/role\u2011based trainings.\n\n**Key LMS endpoints from the context:**\n\n- **List User Assignments**:  \n  `GET /lms/users/{id}/assignments`  \n  (operationId: `lms_list_user_assignments`)  \n  Returns `AssignmentsPaginated` with `next` cursor for pagination.\n- **Create User Assignment**:  \n  `POST /lms/users/{id}/assignments`  \n  (operationId: `lms_create_user_assignment`)  \n  \u201cCreate an assignment type learning record for a user. This is the record linking a user to a learning object. It can be pending or in progress.\u201d\n\n8. **Determine what learning objects to assign**\n   - Use rules like:\n     - Department = \u201cEngineering\u201d \u2192 assign software engineering onboarding path\n     - Job title = \u201cManager\u201d \u2192 assign leadership/compliance modules\n     - Location / cost_center \u2192 region\u2011specific compliance\n   - Inputs from HRIS user record: `department`, `groups`, `skills`, `cost_centers`, `manager_id`.\n\n9. **Create assignment records in the LMS**\n   - For each required learning object:\n     - `POST /lms/users/{lms_user_id}/assignments`\n     - Body includes:\n       - `learning_object_id` (or similar, based on your LMS schema)\n       - `status` = `pending` or `in_progress`\n       - `external_reference` if you track a corporate code for the course (e.g. `\"SOFTWARE-ENG-LV1-TRAINING-VIDEO-1\"`)\n   - This ensures the employee has the correct training visible and tracked from day one.\n\n10. **Verify assignments**\n    - `GET /lms/users/{lms_user_id}/assignments`\n    - Use pagination via `next` if needed (per `x-speakeasy-pagination`).\n    - Confirm all required courses are present and in correct status.\n\n---\n\n## 5. Overall order of operations (summary)\n\n1. **HRIS** \u2013 Create/update employee and get HRIS employee id  \n   - `POST /hris/employees`  \n   - `GET /hris/employees/{id}` (optional, to confirm/augment)\n\n2. **IAM** \u2013 Provision identity and access  \n   - `POST /iam/users` (create IAM account, reference HRIS id)  \n   - `POST /iam/users/{iam_user_id}/groups` / `roles` (assign based on HRIS attributes)  \n   - `POST /iam/users/{iam_user_id}/policies` (optional)\n\n3. **LMS** \u2013 Create LMS user and assign training  \n   - `POST /lms/users` (with HRIS `employee_number` or `id` in `external_reference`)  \n   - `POST /lms/users/{lms_user_id}/assignments` for each required course  \n   - `GET /lms/users/{lms_user_id}/assignments` to validate\n\n4. **Linking & SSO (optional but recommended)**  \n   - Update IAM and/or LMS to store cross\u2011system ids for audit and SSO:\n     - `PUT /iam/users/{iam_user_id}` with `lms_user_id`\n     - or `PUT /lms/users/{lms_user_id}` with `iam_user_id`.\n\nThis flow ensures:  \n- HRIS is the source of truth for who the employee is and where they sit in the org.  \n- IAM controls *access* (including access to the LMS itself).  \n- LMS uses HR information to drive *training assignments* via `lms_create_user_assignment` and can be checked via `lms_list_user_assignments`.",
      "ground_truth_answer": "Onboarding a new employee across HRIS, LMS, and IAM involves reading the employee from HRIS, provisioning learning and identity resources in LMS and IAM, and then assigning the correct training and permissions.\n\n1. Get the employee from HRIS:\n- When an employee is created in HRIS (via `POST /unified/hris/employees`), you can fetch their details using:\n  - `GET /unified/hris/employees` to list employees and filter for the new hire; or\n  - `GET /unified/hris/employees/{id}` to fetch a specific employee. HRIS schemas (e.g., `Company`, `ContractTypeEnum`, `BenefitsTypeEnum`) can help determine role, department, and employment type.\n\n2. Provision identity and access in IAM:\n- Create or verify a user in IAM so the employee has an account:\n  - `GET /unified/iam/users` or `GET /unified/iam/users/{id}` to check if a corresponding IAM user already exists.\n  - If supported in the full IAM spec, you would create or update a user (the provided excerpt shows `PATCH /unified/iam/users/{id}` for updates and `DELETE` for removal). Roles and groups are read via:\n    - `GET /unified/iam/roles` and `GET /unified/iam/roles/{id}` for role definitions.\n    - `GET /unified/iam/groups` and `GET /unified/iam/groups/{id}` for groups.\n- Based on HRIS fields (e.g., department, contract type), you map the employee to appropriate IAM roles/groups.\n\n3. Create or sync the user in LMS:\n- Use LMS user listing and detail endpoints:\n  - `GET /unified/lms/users` to list LMS users.\n  - `GET /unified/lms/users/{id}` to fetch a specific LMS user.\n- If user creation is supported in the full LMS spec (not shown in the excerpt), you would create a corresponding LMS user account or otherwise ensure the IAM identity maps to an LMS user via SSO.\n\n4. Assign training in LMS based on HRIS/IAM data:\n- Determine required courses from HRIS job/department or IAM roles/groups.\n- Use LMS assignment endpoints:\n  - `GET /unified/lms/courses` to list available courses.\n  - `GET /unified/lms/courses/{id}` to fetch specific course details.\n  - `POST /unified/lms/users/{id}/assignments` to assign courses or learning items to the new LMS user.\n  - You can retrieve assignments with `GET /unified/lms/users/{id}/assignments`.\n\n5. (Optional) Track completion and compliance:\n- Use `GET /unified/lms/users/{id}/completions` or `GET /unified/lms/completions` to monitor the employee\u2019s training completion.\n\nGeneral order:\nHRIS (employee created \u2192 fetch via `/unified/hris/employees` or `/unified/hris/employees/{id}`) \u2192 IAM (ensure user, roles, and groups via `/unified/iam/users`, `/unified/iam/roles`, `/unified/iam/groups`) \u2192 LMS (ensure user, then assign training via `/unified/lms/users/{id}/assignments` and manage courses via `/unified/lms/courses`).",
      "retrieval_hit": false,
      "keyword_coverage": 0.42857142857142855,
      "accuracy_score": 2,
      "completeness_score": 3,
      "has_hallucination": true
    },
    {
      "question_id": "cross_api_005",
      "question": "How can you use the core StackOne API together with a product-specific API (for example, ATS and MARKETING) to inspect request logs for a failed action and then retry that action via the appropriate endpoint? Identify the key StackOne and product endpoints you would use.",
      "category": "cross_api",
      "generated_answer": "You would:\n\n1. **Use the core StackOne \u201cActions\u201d API to find the failed action and inspect its logs.**\n\n   Key endpoints (core StackOne API):\n\n   - **List / inspect actions / logs**  \n     - `GET /actions` \u2013 list actions (optionally filtered by status, provider, product, etc.) to find the failed action.  \n     - `GET /actions/{action_id}` \u2013 get full details of the specific action, including status, product (e.g. `ATS`, `MARKETING`), provider, and metadata to understand what it attempted to do.  \n     - `GET /actions/{action_id}/logs` (or equivalent logs endpoint, depending on your exact spec) \u2013 inspect the request/response logs for that specific failed action: payload sent to the provider, error returned, timestamps, etc.\n\n   - **RPC actions (generic remote calls)**  \n     - `POST /actions/rpc`  \n       - Request schema: `ActionsRpcRequestDto`  \n       - Response schema: `ActionsRpcResponse`  \n       You can use this when the action is defined as an \u201cRPC action\u201d in StackOne (e.g. a custom provider operation). The body contains:\n       - `action` / `operation` (the remote procedure name)\n       - `product` (e.g. `ATS`, `MARKETING`)\n       - `provider` or connection info\n       - `params` / `body` with the same payload you saw in the original failed request log.  \n       This is the **generic** way to retrigger provider\u2011specific remote procedures via StackOne.\n\n2. **Use the product\u2011specific API to re\u2011execute the logical operation (create/update/etc.) that failed.**\n\n   Based on what the logs show the failed action was trying to do, you then call the corresponding product endpoint, reusing the payload (possibly corrected):\n\n   **For ATS (Applicant Tracking) operations**  \n   Common endpoints inferred from the schemas:\n\n   - **Jobs**  \n     - `POST /ats/jobs`  \n       - Request body: `AtsCreateJobRequestDto`  \n       - Used if the failed action was creating a job (fields like `code`, `title`, `unified_custom_fields`, etc.).  \n     - `PATCH /ats/jobs/{job_id}` or `PUT /ats/jobs/{job_id}`  \n       - Used if the failed action was updating a job.\n\n   - **Applications / stages / offers** (examples from the provided schemas):\n     - Application Stage inspection/creation/update (names may vary by spec):  \n       - `GET /ats/application-stages/{id}` \u2013 to inspect the failed resource if it partially created.  \n       - `POST /ats/application-stages` \u2013 to recreate a stage (fields like `name`, `order`, `remote_id`, `unified_custom_fields`, `created_at`, `updated_at`).  \n       - `PATCH /ats/application-stages/{id}` \u2013 to retry an update on a stage.\n     - Offers:  \n       - `POST /ats/offers` \u2013 to recreate an offer (payload includes `application_id`, `remote_application_id`, `unified_custom_fields`, etc.).  \n       - `PATCH /ats/offers/{offer_id}` \u2013 to retry an update to an offer.\n\n   **For MARKETING (example pattern)**  \n   The exact endpoints depend on your project\u2019s MARKETING module, but you would typically use:  \n\n   - `POST /marketing/{resource}` \u2013 to recreate the resource (email campaign, contact, list, etc.) that failed.  \n   - `PATCH /marketing/{resource}/{id}` \u2013 to retry an update.  \n\n   You derive the correct `{resource}` and payload from the failure logs you retrieved via the core `/actions` endpoints.\n\n3. **Concrete flow to inspect and retry:**\n\n   1. **Locate the failed action**  \n      - `GET /actions?status=FAILED`  \n      - From the list, pick the failed `action_id`.\n\n   2. **Inspect the logs & payload**  \n      - `GET /actions/{action_id}` \u2013 confirm which product (`ATS`, `MARKETING`) and what operation it was.  \n      - `GET /actions/{action_id}/logs` \u2013 capture:\n        - Request payload sent to the provider.\n        - Any contextual IDs (`external_reference`, `application_id`, job `code`, etc.).\n        - Error details (e.g. validation error, provider 4xx/5xx).\n\n   3. **Retry via the appropriate mechanism:**\n      - If the action is a defined RPC operation:  \n        - `POST /actions/rpc` with an `ActionsRpcRequestDto` that mirrors the original call (optionally fixing any data issues).\n      - If the action was a standard ATS operation (e.g. create job / stage / offer):  \n        - Rebuild the same object from the logs and call:\n          - `POST /ats/jobs` (or `/ats/application-stages`, `/ats/offers`, etc.), or  \n          - `PATCH /ats/jobs/{id}` / `/ats/application-stages/{id}` / `/ats/offers/{id}`  \n            depending on whether the original action was create or update.\n      - If the action was in MARKETING:  \n        - Call the equivalent `POST /marketing/...` or `PATCH /marketing/...` endpoint using the payload from the logs.\n\nIn summary, you use **core StackOne /actions endpoints** to identify and inspect the failed action and its exact payload, then **either** retry generically via `POST /actions/rpc` **or** call the **product\u2011specific endpoints** (e.g. `POST /ats/jobs`, `POST /ats/application-stages`, `POST /ats/offers`, or their `PATCH` variants, and analogous MARKETING endpoints) to re\u2011execute the failed operation.",
      "ground_truth_answer": "To debug and retry a failed operation, you can use the StackOne core API to inspect logs and metadata, then call the product-specific API (such as ATS or MARKETING) to perform or retry the underlying action.\n\n1. Inspect request and platform logs with StackOne:\n- Use the logging endpoints to find the failed request:\n  - `GET /requests/logs` \u2014 list request logs, potentially filtered by time, connector, or status.\n  - `GET /requests/logs/{id}` \u2014 fetch detailed information about a specific log entry.\n  - `GET /requests/logs/steps` \u2014 inspect detailed step-level logs if supported by query parameters.\n  - `GET /requests/platform-logs` \u2014 examine platform-level logs.\n- These use schemas like `AdvancedLogRequestData`, `AdvancedLogResponseData`, and `AdvancedLogRequestDataUrl` to describe request URLs, payloads, and responses. From the logs, you can identify which API (e.g., ATS or MARKETING), which endpoint, which method, and what payload failed.\n\n2. Identify connector and action metadata, if needed:\n- Use `GET /connectors/meta` or `GET /connectors/meta/{provider}` to understand which provider/connector and resources were involved.\n- Use `GET /actions` to list available unified actions and `POST /actions/rpc` to invoke a pre-defined RPC-style action instead of calling the product-specific endpoint directly.\n\n3. Retry or re-perform the operation on the product API:\n\nExample with ATS:\n- If the log shows that a call to ATS `POST /unified/ats/applications` failed, you can reconstruct the request body from log data and retry:\n  - Directly via the ATS API: `POST /unified/ats/applications`.\n  - Or via a unified proxy or action:\n    - `POST /unified/proxy` to send a proxied request through StackOne if you want to target the downstream system through a generic proxy layer.\n    - `POST /actions/rpc` if there\u2019s an action defined for creating or updating applications.\n\nExample with MARKETING:\n- If the log shows failure for creating an email template via `POST /unified/marketing/templates/email`, you:\n  - Inspect the original payload from the StackOne logs (`/requests/logs` and `/requests/logs/{id}`).\n  - Retry by calling `POST /unified/marketing/templates/email` on the MARKETING API with corrected data.\n  - Similarly, you can update an existing template via `PATCH /unified/marketing/templates/email/{id}` if the failure was during update.\n\n4. Authentication and sessions:\n- Ensure that the API calls (both to StackOne logging endpoints and product endpoints) are authenticated using StackOne\u2019s basic auth scheme. If you are using embedded connections, you may first create or authenticate a connection using:\n  - `POST /connect_sessions` and `POST /connect_sessions/authenticate` from the StackOne API.\n\nIn summary, you:\n- Use StackOne\u2019s core logging endpoints (`/requests/logs`, `/requests/logs/{id}`, `/requests/platform-logs`, `/requests/logs/steps`) plus metadata (`/connectors/meta`, `/actions`, `/actions/rpc`, `/unified/proxy`) to analyze and locate the failed request.\n- Then you retry or reissue the call on the relevant product API endpoint, such as `POST /unified/ats/applications` for ATS or `POST /unified/marketing/templates/email` (and related `PATCH` endpoints) for MARKETING.",
      "retrieval_hit": false,
      "keyword_coverage": 0.375,
      "accuracy_score": 2,
      "completeness_score": 2,
      "has_hallucination": true
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the exact subscription pricing tiers and overage billing rules for high-volume usage of the StackOne APIs?",
      "category": "out_of_scope",
      "generated_answer": "The context you\u2019ve provided is an excerpt of StackOne\u2019s OpenAPI schema (definitions of objects, responses, etc.) and does not contain any information about pricing, subscription tiers, or overage billing.\n\nBased on this context alone, the following **cannot be determined**:\n\n- What the subscription pricing tiers are (names, monthly limits, included usage, features, etc.).\n- How \u201chigh-volume\u201d is defined for billing purposes (e.g., number of API calls, messages, or records).\n- The exact overage pricing model (per-call, per-record, per-message, volume discounts, rate cards, etc.).\n- Whether overages are billed automatically, require an upgrade, or are rate-limited.\n\nTo get the exact and current subscription pricing tiers and overage billing rules for high-volume StackOne API usage, you will need to check one of the following:\n\n1. **StackOne\u2019s official pricing page** \u2013 typically something like `https://stackone.com/pricing` or a similar URL on their site.\n2. **Product or developer documentation** \u2013 sometimes a \u201cBilling\u201d or \u201cUsage & Limits\u201d section.\n3. **Your contract / order form** \u2013 if you already use StackOne, your MSA/SOW or order form often has explicit overage terms.\n4. **Contact StackOne sales or support** \u2013 for high-volume or enterprise usage, pricing is often custom/negotiated and not fully public.\n\nIf you can share a pricing table, link, or text from their pricing page/contract, I can interpret it and summarize the exact tiers and overage rules in detail.",
      "ground_truth_answer": "This information is not available in the API documentation; pricing and billing details are not in documentation and the system should respond that it doesn't know.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a formal uptime SLA (e.g., 99.9%) for its production API, and what credits are offered if that SLA is not met?",
      "category": "out_of_scope",
      "generated_answer": "StackOne\u2019s public documentation in the provided context does not mention any formal uptime SLA (such as 99.9%) for its production API, nor does it describe any service credits or compensation model if an SLA is not met.\n\nTo get a definitive answer, you would need to check:\n\n1. The Master Service Agreement (MSA) or Terms of Service you signed with StackOne.\n2. Any specific Enterprise or custom contract/SLA documentation.\n3. StackOne\u2019s sales or customer success team, who can confirm if an uptime SLA and associated credits exist for your plan.",
      "ground_truth_answer": "This information is not available; SLA guarantees and credit policies are not in documentation and the system should say it does not know.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI (themes, custom widgets, and role-based views) independently of the API configuration?",
      "category": "out_of_scope",
      "generated_answer": "You can customize the **web dashboard UI** separately from your **StackOne API / unified schemas** by treating UI concerns as a client-side layer that consumes (but doesn\u2019t configure) the API. In practice, you\u2019d do three things:\n\n---\n\n### 1. Theming the Dashboard (Colors, Layout, Branding)\n\n**Key idea:** All visual theming should live in your front-end (CSS / design system), not in StackOne\u2019s API objects like `unified_custom_fields` or `remote_id`.\n\nTypical approaches:\n\n- **CSS variables / Tailwind / design tokens**\n  - Define theme tokens (colors, spacing, typography) in your app.\n  - Apply them globally based on a theme setting (e.g., `light`, `dark`, `customer_X`).\n- **Per-customer or per-tenant theme config**\n  - Store a theme config in your own DB (e.g. `theme.primaryColor`, `theme.logoUrl`).\n  - Load it at runtime and bind it to CSS variables / a theme provider.\n- **White-labeling**\n  - Swap logos, brand colors, and fonts based on tenant-specific config.\n  - The StackOne API remains unchanged; all branding is applied in your front-end.\n\n**What not to do:** Don\u2019t try to encode themes into StackOne entities (e.g., no color fields in `unified_custom_fields` for this purpose). Themes should be purely a client concern.\n\n---\n\n### 2. Custom Widgets & Components\n\n**Key idea:** Use StackOne purely as the **data layer**; build custom UI components on top of the data you fetch from StackOne.\n\nExample patterns:\n\n- **Widgets for unified objects**\n  - Build dedicated components: `CandidateCard`, `JobStageTimeline`, `NoteThread`, etc.\n  - These widgets read StackOne resources like `User`, `Note`, `ApplicationStage`, `Category`, etc., but the component structure, layout, and interactions are all yours.\n- **Composable widget system**\n  - Define a registry like:\n\n    ```ts\n    const widgetRegistry = {\n      candidateOverview: CandidateOverviewWidget,\n      jobMetrics: JobMetricsWidget,\n      notesPanel: NotesPanelWidget,\n      // ...\n    };\n    ```\n\n  - Maintain a per-role or per-tenant layout configuration in your DB, referencing these widget keys.\n- **Configuration-driven layouts**\n  - Store layout definitions (e.g. which widgets appear on which page, grid positions, expanded/collapsed state) in your own config:\n    ```json\n    {\n      \"dashboard\": {\n        \"widgets\": [\n          { \"id\": \"candidateOverview\", \"position\": { \"x\": 0, \"y\": 0 } },\n          { \"id\": \"notesPanel\", \"position\": { \"x\": 1, \"y\": 0 } }\n        ]\n      }\n    }\n    ```\n  - Your UI renders based on this config; StackOne just provides the data the widgets consume.\n\nAgain, **none of this requires altering StackOne schemas**; you simply map StackOne responses into your own view-models and components.\n\n---\n\n### 3. Role-Based Views & Access Control\n\n**Key idea:** Use your own authorization / RBAC layer to decide **who can see what UI**, independently of what the StackOne API can technically return.\n\nSteps:\n\n1. **Define roles and permissions in your system**  \n   For example: `admin`, `recruiter`, `hiring_manager`, `viewer`.\n\n2. **Map roles to UI capabilities**\n   - Which pages are visible.\n   - Which widgets appear on each page.\n   - Which actions are enabled (e.g., edit notes vs. view-only).\n\n   Example config:\n\n   ```json\n   {\n     \"admin\": {\n       \"dashboardWidgets\": [\"candidateOverview\", \"jobMetrics\", \"notesPanel\"],\n       \"permissions\": [\"viewCandidates\", \"editCandidates\", \"viewNotes\", \"editNotes\"]\n     },\n     \"hiring_manager\": {\n       \"dashboardWidgets\": [\"candidateOverview\", \"notesPanel\"],\n       \"permissions\": [\"viewCandidates\", \"viewNotes\"]\n     }\n   }\n   ```\n\n3. **Enforce role-based UI in the front-end**\n   - At runtime, read the current user\u2019s role (from your auth token/session).\n   - Filter routes, widgets, and controls based on the config.\n   - Optionally, show/hide or disable specific field-level UI elements (e.g., salary fields only for `admin`).\n\n4. **Optionally mirror roles in API usage**\n   - You can also restrict which StackOne endpoints or resources you call based on role, but this is still **your layer**, not StackOne itself.\n   - StackOne doesn\u2019t manage your RBAC; you gate your own backend or API proxy accordingly.\n\n---\n\n### 4. Clean Separation from StackOne API Configuration\n\nTo keep UI independent of API configuration:\n\n- **Don\u2019t overload StackOne fields for UI logic.**\n  - Fields like `remote_id`, `unified_custom_fields`, `created_at`, etc. should represent data from integrations or unified fields, not theme/layout instructions.\n- **Use your own schemas for UI state and settings.**\n  - Theme config, layout config, widget registry, role\u2013widget mapping: all defined in your own backend or front-end configuration files.\n- **Map API \u2192 View model**\n  - Transform StackOne responses into your own typed view models before rendering, so UI changes rarely require API config changes.\n  \n---\n\n### Summary\n\n- **Themes**: Implement via your own CSS/design system & tenant configs; keep it entirely in your UI layer.\n- **Custom widgets**: Build your own components that consume StackOne data; drive layout via your own configuration.\n- **Role-based views**: Implement RBAC in your app; use it to decide which routes, widgets, and fields are visible, independent of StackOne schemas.\n\nIf you describe your current tech stack (React/Next, Vue, etc.), I can outline a concrete pattern (e.g., with example components and configs) tailored to it.",
      "ground_truth_answer": "Details on dashboard UI customization are not available in the API documentation; this is not in documentation and the system should answer that it doesn't know.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 1,
      "completeness_score": 1,
      "has_hallucination": true
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Which third-party observability tools (such as Datadog or New Relic) have native, non-API-based integrations with StackOne, and how are they configured?",
      "category": "out_of_scope",
      "generated_answer": "StackOne does not document any native, non\u2011API\u2011based integrations with third\u2011party observability tools such as Datadog, New Relic, Grafana, etc.\n\nAll monitoring/observability today is typically done via:\n\n- **APIs / Webhooks** from StackOne into your systems, or  \n- Logging/metrics you instrument yourself around StackOne\u2019s API usage (for example, in your backend that calls StackOne, which then exports metrics/logs to Datadog/New Relic).\n\nBecause there are no published first\u2011class integrations:\n\n- There is no StackOne \u201ctile\u201d/\u201cintegration\u201d in Datadog or New Relic with one\u2011click setup.  \n- There is no documented configuration for agent\u2011based or native integrations (e.g., no specific configuration files, no StackOne-specific dashboards or monitors provided by those vendors).\n\nIf you need observability with these tools, you\u2019ll typically configure:\n\n1. **Your application** (that talks to StackOne) to emit metrics/logs/traces and send them to Datadog/New Relic.  \n2. Optional **webhook receivers** that accept StackOne webhooks, transform them, and push structured events into your observability platform (e.g., via Datadog Logs API, New Relic Event API).\n\nIf you have access to any private or enterprise StackOne documentation that suggests otherwise, share it and I can help you interpret or translate the exact setup.",
      "ground_truth_answer": "The API documentation does not provide this information; third-party observability integrations of this kind are not in documentation and the system should say it does not know.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 5,
      "completeness_score": 5,
      "has_hallucination": true
    },
    {
      "question_id": "out_of_scope_005",
      "question": "Does StackOne offer an on-premise or self-hosted deployment option, and if so, what are the security and data residency policies for that deployment model?",
      "category": "out_of_scope",
      "generated_answer": "StackOne is offered as a managed cloud/SaaS platform and, based on the available documentation, does **not** publicly advertise an on\u2011premise or self\u2011hosted deployment option.\n\nBecause there is no documented self\u2011hosted/on\u2011prem version:\n\n- There are **no separate, published security policies** specific to an on\u2011premise deployment.\n- **Data residency, security, and compliance** are described in the context of StackOne\u2019s **hosted cloud environment** only (e.g., where StackOne\u2019s managed infrastructure is located, how data is encrypted, access controls, etc.).\n\nIf you require on\u2011premise or specific data\u2011residency guarantees (e.g., all data must remain in a particular country or your own VPC), you would need to:\n\n1. Contact StackOne sales/support directly to confirm whether:\n   - A private deployment model (e.g., dedicated VPC, region\u2011locked hosting) is available, or  \n   - Any bespoke/self\u2011hosted arrangements can be made under an enterprise contract.\n2. Obtain their latest security and data\u2011residency documentation (e.g., security whitepaper, DPA, regional hosting options), as these details may be governed by customer\u2011specific agreements rather than public docs.\n\nIn short: there is no standard, documented on\u2011premise/self\u2011hosted deployment of StackOne; all security and data\u2011residency commitments apply to their managed cloud service unless you negotiate a custom enterprise arrangement.",
      "ground_truth_answer": "Information about on-premise deployment options and related company security or data residency policies is not available in the API documentation; it is not in documentation and the system should respond that it doesn't know.",
      "retrieval_hit": false,
      "keyword_coverage": 0.0,
      "accuracy_score": 3,
      "completeness_score": 3,
      "has_hallucination": true
    }
  ]
}