{
  "config": "c0",
  "timestamp": "2025-12-10T21:36:37.636987",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.6582278481012658,
      "mrr": 0.5088607594936709,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.4166666666666665,
      "abstention_accuracy": 0.2
    }
  },
  "results_by_category": {
    "schema": {
      "count": 21,
      "avg_accuracy": 3.8095238095238093,
      "retrieval_hit_rate": 0.38095238095238093
    },
    "auth": {
      "count": 7,
      "avg_accuracy": 1.7142857142857142,
      "retrieval_hit_rate": 1.0
    },
    "factual": {
      "count": 21,
      "avg_accuracy": 3.9523809523809526,
      "retrieval_hit_rate": 0.7142857142857143
    },
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.5555555555555554,
      "retrieval_hit_rate": 0.5555555555555556
    },
    "endpoint": {
      "count": 21,
      "avg_accuracy": 3.4285714285714284,
      "retrieval_hit_rate": 0.8095238095238095
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 3.4,
      "retrieval_hit_rate": 0.0
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The `expires_in` field in the `ConnectSessionCreate` request body defaults to **1,800** and this duration is expressed in **seconds** (i.e., 30 minutes).",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_connect_sessions_part0",
        "stackone_components_schemas_part16",
        "stackone_paths_connect_sessions_authenticate_part0",
        "stackone_paths_connect_sessions_part3",
        "stackone_components_schemas_part18"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "When listing platform logs with `GET /requests/platform-logs`, you can control the sort order using two query parameters:\n\n1. **`order_by`** \u2013 which field to sort on  \n   Allowed values:\n   - `\"provider\"`\n   - `\"service\"`\n   - `\"status\"`\n   - `\"eventDatetime\"`\n   - `\"duration\"`\n   - `null` (or omitted)\n\n2. **`order_direction`** \u2013 the sort direction  \n   Allowed values:\n   - `\"asc\"` (ascending)\n   - `\"desc\"` (descending)\n   - `null` (or omitted)",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_requests_platform_logs_part0",
        "stackone_paths_requests_logs_part0",
        "stackone_paths_requests_logs_steps_part0",
        "stackone_paths_requests_platform_logs_part6",
        "stackone_components_schemas_part28"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The target provider account identifier should be passed in the `x-account-id` HTTP header.  \n\nIf you omit the header, you can alternatively provide the same value as an `x-account-id` query parameter in the request URL (e.g., `POST /mcp?x-account-id=...`).",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_mcp_part0",
        "stackone_paths_mcp_part5",
        "stackone_paths_mcp_part9",
        "stackone_paths_unified_proxy_part0",
        "crm_components_schemas_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Call the `GET /requests/logs` endpoint (operationId `stackone_list_logs`) to retrieve a **paginated list of unified request logs**.\n\nYou can use these query parameters:\n\n- **Pagination / ordering**\n  - `order_by`: one of `provider`, `service`, `status`, `eventDatetime`, `duration`, or `null`\n  - `order_direction`: `asc` or `desc`\n  - `page_size`: number of results per page (max 100)\n\n- **Filtering**\n  - `method`: HTTP method (e.g. `GET`, `POST`, etc.) \u2013 used to filter by HTTP method  \n  - `provider`: provider identifier \u2013 used to filter by provider  \n\n- **Includes**\n  - `include=step_logs` to include step logs in each log item in the response.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_requests_logs_steps_part0",
        "stackone_paths_requests_logs_id_part0",
        "stackone_paths_requests_logs_part0",
        "stackone_components_schemas_part50",
        "stackone_paths_requests_platform_logs_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Use the `GET /requests/logs` endpoint (operationId: `stackone_list_logs`) to retrieve a **paginated list of request logs**.\n\nFrom the wider StackOne API (beyond the clipped snippet), this endpoint supports query parameters that let you filter logs by:\n\n- **Account IDs** \u2013 e.g. `account_id` or `account_ids` (array)  \n- **HTTP methods** \u2013 e.g. `method` (GET, POST, etc.)  \n- **Providers** \u2013 e.g. `provider` (or a list such as `providers[]`)  \n- **Success status** \u2013 e.g. `success` (boolean) or `status` (HTTP status code / category)\n\nIn addition, as shown in your context, it supports:\n\n- `order_by` \u2013 one of `provider`, `service`, `status`, `eventDatetime`, `duration`, or `null`\n- `order_direction` \u2013 `asc` or `desc`\n- `page_size` \u2013 number of results per page (max 100; default 25)\n\nSo to retrieve a paginated, filtered list of request logs, call:\n\n`GET /requests/logs`\n\n\u2026with the appropriate combination of:\n\n- `page` / `page_size`\n- `order_by` / `order_direction`\n- filters such as `account_id` / `account_ids`, `method`, `provider`, and `success` (or `status`) depending on which of those your specific StackOne deployment exposes.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_requests_logs_id_part0",
        "stackone_paths_requests_logs_part0",
        "stackone_paths_requests_logs_steps_part0",
        "stackone_paths_accounts_part0",
        "stackone_paths_requests_platform_logs_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should use the **`GET /actions`** endpoint to list all actions metadata.\n\n**Available query parameters:**\n\n1. **Pagination**\n   - `page_size` (string, optional)  \n     - Description: Number of results per page.  \n     - Default: `25`\n   - `next` (string, optional)  \n     - Description: Unified cursor for fetching the next page of results (used for cursor-based pagination).\n\n2. **Grouping**\n   - `group_by` (string, optional)  \n     - Description: Relation to group the results by.  \n     - Default: `\"connector\"`  \n     - Example: `group_by=connector`\n\nThese are the parameters you can use to filter and paginate when calling `GET /actions` to retrieve the actions metadata.",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_actions_part0",
        "stackone_paths_actions_part6",
        "stackone_paths_requests_logs_steps_part4",
        "stackone_paths_actions_rpc_part0",
        "stackone_paths_actions_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "- **Type:** `string`  \n- **Description:** `\"The method of the request\"`  \n- **Allowed values (enum):** `[\"get\", \"post\", \"put\", \"delete\", \"patch\", null]`  \n- **Default value:** `\"get\"`  \n- **Nullable:** Yes (`nullable: true`)",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_schemas_part33",
        "stackone_paths_unified_proxy_part0",
        "ats_paths_unified_ats_applications_id_scheduled_interviews_subresourceid_part1",
        "lms_paths_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_unified_lms_assignments_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The allowed values for the `method` field in the `ProxyRequestBody` schema are:\n\n- `\"get\"`\n- `\"post\"`\n- `\"put\"`\n- `\"delete\"`\n- `\"patch\"`\n- `null`\n\nIf `method` is omitted, the default value is `\"get\"`.",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_schemas_part33",
        "stackone_paths_unified_proxy_part0",
        "stackone_paths_unified_proxy_part1",
        "ats_paths_unified_ats_applications_id_scheduled_interviews_subresourceid_part1",
        "lms_paths_unified_lms_assignments_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "In the StackOne API:\n\n- **Required fields in `ConnectSessionCreate`**:  \n  The schema excerpt only marks `origin_owner_id` and `origin_owner_name` as required (shown under the `required` array associated with the connect session creation context). No other fields are indicated as required in `ConnectSessionCreate`.\n\n- **Allowed values for its `type` property**:  \n  The `ConnectSessionCreate` schema does **not** define a `type` property. Instead, it defines a `categories` array whose items may be one of:\n\n  - `\"ats\"`  \n  - `\"hris\"`  \n  - `\"hris-legacy\"`  \n  - `\"crm\"`  \n  - `\"iam\"`  \n  - `\"marketing\"`  \n  - `\"lms\"`  \n  - `\"stackone\"`  \n  - `\"documents\"`  \n  - `\"ticketing\"`  \n  - `\"screening\"`  \n  - `\"messaging\"`  \n  - `\"accounting\"`  \n  - `\"scheduling\"`  \n  - `null`  \n\nSo there is no `type` field to constrain; the controlled values instead apply to the `categories` items.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_connect_sessions_part0",
        "stackone_paths_connect_sessions_authenticate_part0",
        "stackone_components_schemas_part16",
        "stackone_components_schemas_part14",
        "stackone_components_schemas_part19"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the `/mcp` endpoints (POST, GET, DELETE), the spec implies two layers of context/security:\n\n1. **API-level authentication scheme (global)**  \n   The excerpt doesn\u2019t show the top-level `security` section, but in this kind of OpenAPI it is typically one or more of:\n   - API key (e.g., `Authorization: Bearer <token>` or `x-api-key: <key>`)\n   - OAuth2 bearer token  \n   \n   Whatever global scheme the StackOne API defines applies equally to all `/mcp` endpoints. In other words, you authenticate to the API in the same way you do for other StackOne endpoints; `/mcp` does not define a special or different auth mechanism of its own.\n\n2. **Account and session context headers (per-request)**  \n\n   For the MCP operations under `/mcp`, the following headers/parameters are relevant:\n\n   ### a. `x-account-id`\n   - **Location**: can be provided either as:\n     - Header: `x-account-id: <account secure id>`\n     - Query parameter: `?x-account-id=<account secure id>`\n   - **Required**:  \n     - For all `/mcp` methods it is **optional** per the spec, but in practice you provide it when you need to target a specific provider account.\n   - **Purpose**: identifies the **target provider account** (the \u201caccount secure id\u201d) on whose behalf the MCP session or JSON-RPC call should operate.\n\n   ### b. `mcp-session-id`\n   - **POST `/mcp` (Send MCP JSON-RPC message)**:\n     - Header: `mcp-session-id`\n     - **Required**:  \n       - **Omit** for the `initialize` call (to start a new MCP session).  \n       - **Include** for subsequent JSON-RPC messages to the same session.\n   - **GET `/mcp` (Open MCP SSE stream)**:\n     - Header: `mcp-session-id`\n     - **Required**: **Yes** \u2013 you must include the session id to open the SSE stream for that specific MCP session.\n   - **DELETE `/mcp` (Delete MCP session)**:\n     - Header: `mcp-session-id`\n     - **Required**: **Yes** \u2013 you must specify which MCP session to close.\n\n   ### c. `Accept` (for SSE)\n   - **GET `/mcp`**:\n     - Header: `Accept: text/event-stream`\n     - **Required**: **Yes** \u2013 this tells the server you are opening a Server-Sent Events stream for MCP notifications.\n\n---\n\n**Summary**\n\n- **Supported authentication scheme**: whatever global API auth the StackOne API defines (e.g., bearer token, API key); `/mcp` does not introduce a different scheme.\n- **Account context**:\n  - `x-account-id` (header or query): optional, identifies the target provider account.\n- **Session context**:\n  - `mcp-session-id` (header):\n    - POST `/mcp`: required for all JSON-RPC calls **except** the initial `initialize` call.\n    - GET `/mcp`: required to open the SSE stream for that session.\n    - DELETE `/mcp`: required to close that session.\n- **SSE header**:\n  - `Accept: text/event-stream` is required on GET `/mcp`.",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_mcp_part0",
        "stackone_paths_mcp_part5",
        "stackone_paths_mcp_part9",
        "stackone_paths_mcp_part13",
        "stackone_components_schemas_part23"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The filter field is `type`.\n\nIts allowed values are defined by the enum schema:\n\n`\"enum\": [\"sick\", \"unmapped_value\", \"vacation\", \"long_term_disability\", \"short_term_disability\", \"absent\", \"comp_time\", \"training\", \"annual_leave\", \"leave_of_absence\", \"break\", \"child_care_leave\", \"maternity_leave\", \"jury_duty\", \"sabbatical\", \"accident\", \"paid\", \"unpaid\", \"holiday\", \"personal\", \"in_lieu\", \"bereavement\", \"other\", null]`",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_unified_hris_time_off_policies_part2",
        "hris_paths_unified_hris_employees_id_time_off_policies_part0",
        "hris_paths_unified_hris_employees_id_time_off_part2",
        "hris_paths_unified_hris_time_off_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You can use the `type` query parameter to filter employee time off policies by their type.\n\nThree valid values for the `type` filter are:\n- `sick`  \n- `vacation`  \n- `bereavement`",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_policies_part0",
        "hris_paths_unified_hris_employees_id_time_off_part2",
        "hris_paths_unified_hris_time_off_part2",
        "hris_paths_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_unified_hris_time_off_policies_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The default status value is `completed` if the `status` field is omitted in the `UpdateTaskRequestDto` payload.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_schemas_part197",
        "hris_paths_unified_hris_employees_id_tasks_subresourceid_part5",
        "hris_components_schemas_part224",
        "hris_paths_unified_hris_employees_id_tasks_subresourceid_part6",
        "hris_paths_unified_hris_employees_id_tasks_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You should use the **GET** endpoint:\n\n`GET /unified/hris/employees/{id}/time_off_policies`\n\n**Required parameters:**\n\n1. **Path parameter**\n   - `id` \u2013 the identifier of the employee whose assigned time off policies you want to list.\n\n2. **Header parameter**\n   - `x-account-id` \u2013 the account identifier.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_policies_part0",
        "hris_paths_unified_hris_employees_id_time_off_policies_part7",
        "hris_paths_unified_hris_employees_id_time_off_policies_part4",
        "hris_paths_unified_hris_time_off_policies_part4",
        "hris_paths_unified_hris_employees_id_time_off_part7"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint to list requests:** `GET /unified/hris/employees/{id}/time_off`  \n  (operationId: `hris_list_employee_time_off_requests`)\n\nTo filter the results by a specific time off policy ID, use the **`policy_ids`** query parameter, passing the ID in the array (e.g. `?policy_ids[]=<policy_id>`).",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_policies_part0",
        "hris_paths_unified_hris_employees_id_time_off_part2",
        "hris_paths_unified_hris_time_off_part2",
        "hris_paths_unified_hris_employees_id_time_off_part0",
        "hris_paths_unified_hris_employees_id_time_off_policies_part4"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **`POST /unified/hris/employees/{id}/time_off`** endpoint.\n\n**HTTP method:**  \n- `POST`\n\n**Required parameters:**\n\n- **Path parameter:**\n  - `id` (string) \u2013 the identifier of the specific employee.\n\n- **Header:**\n  - `x-account-id` (string) \u2013 the account identifier.\n\n(You\u2019ll also include the appropriate request body for the time off details as defined by the API\u2019s `create_employee_time_off_request` schema.)",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_part7",
        "hris_paths_unified_hris_employees_id_time_off_part11",
        "hris_paths_unified_hris_employees_id_time_off_part0",
        "hris_paths_unified_hris_employees_id_time_off_subresourceid_part2",
        "hris_paths_unified_hris_employees_id_time_off_subresourceid_part9"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Based on the provided snippet, the `Employment` objects that appear in an employee\u2019s `employments` array are instances of `CreateEmploymentApiModel` (or a closely related employment schema), and they expose the following **top\u2011level properties**. Below is the full list visible from the context, along with:\n\n- whether a property is **deprecated**,  \n- whether it **references another schema** (e.g., enums or complex models), and  \n- whether that reference is an **enum wrapper** like `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`, or `EmploymentStatusEnum`.\n\n---\n\n### Top\u2011level properties on an `Employment` object\n\n1. **employee_number**\n   - **Type:** `string`\n   - **Description:** \"The assigned employee number\"\n   - **Example:** `\"125\"`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** No (plain string)\n\n2. **national_identity_number**\n   - **Description:** \"The national identity number\"\n   - **Nullable:** `true`\n   - **Deprecated:** **true**\n   - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/NationalIdentityNumberApiModel\" }]`\n   - **References other schema:** Yes \u2013 `NationalIdentityNumberApiModel` (wrapper/complex type)\n\n3. **employment_status**\n   - **Description:** \"The employee employment status\"\n   - **Example:** `\"active\"`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated in the snippet\n   - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/EmploymentStatusEnum\" }]`\n   - **References other schema:** Yes \u2013 `EmploymentStatusEnum`\n   - **Enum wrapper:** Yes \u2013 this is an enum-wrapper schema\n\n4. **termination_date**\n   - **Type:** `string`\n   - **Format:** `date-time`\n   - **Description:** \"The employee termination date\"\n   - **Example:** `\"2021-01-01T00:00:00Z\"`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** No (plain date-time string)\n\n5. **company_name**\n   - **Type:** `string`\n   - **Description:** \"The employee company name\"\n   - **Example:** `\"Example Corp\"`\n   - **Nullable:** `true`\n   - **Deprecated:** **true**\n   - **References other schema:** No (plain string)\n\n6. **company_id**\n   - **Type:** `string`\n   - **Description:** \"The employee company id\"\n   - **Example:** `\"1234567890\"`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** No (plain string)\n\n7. **citizenships**\n   - **Description:** \"The citizenships of the Employee\"\n   - **Type:** `array`\n   - **Items:** `{ \"$ref\": \"#/components/schemas/CountryCodeEnum\" }`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** Yes \u2013 `CountryCodeEnum` (enum wrapper for country codes)\n   - **Enum wrapper:** Yes \u2013 `CountryCodeEnum` is an enum schema\n\n8. **home_location**\n   - **Description:** \"The employee home location\"\n   - **Nullable:** `true`\n   - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/HRISLocation\" }]`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** Yes \u2013 `HRISLocation` (complex type)\n\n9. **hire_date**\n   - **Type:** `string`\n   - **Format:** `date-time`\n   - **Description:** \"The employee hire date\"\n   - **Example:** `\"2021-01-01T00:00:00.000Z\"`\n   - **Nullable:** `true`\n   - **Deprecated:** not marked as deprecated\n   - **References other schema:** No\n\n10. **start_date**\n    - **Type:** `string`\n    - **Format:** `date-time`\n    - **Description:** \"The employee start date\"\n    - **Example:** `\"2021-01-01T00:00:00.000Z\"`\n    - **Nullable:** `true`\n    - **Deprecated:** not marked as deprecated\n    - **References other schema:** No\n\n11. **effective_date**\n    - **Type:** `string`\n    - **Format:** `date-time`\n    - **Description:** \"The effective date of the employment contract\"\n    - **Example:** `\"2021-01-01T01:01:01.000Z\"`\n    - **Nullable:** `true`\n    - **Deprecated:** not marked as deprecated\n    - **References other schema:** No\n\n12. **end_date**\n    - **Type:** `string`\n    - **Format:** `date-time`\n    - **Description:** \"The end date of employment\"\n    - **Example:** `\"2021-01-01T01:01:01.000Z\"`\n    - **Nullable:** `true`\n    - **Deprecated:** not marked as deprecated\n    - **References other schema:** No\n\n13. **grade**\n    - **Description:** \"Represents the employee\u2019s position within the organizational hierarchy.\"\n    - **Nullable:** `true`\n    - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/EmploymentGradeApiModel\" }]`\n    - **Deprecated:** not marked as deprecated\n    - **References other schema:** Yes \u2013 `EmploymentGradeApiModel` (complex type)\n    - **Enum wrapper:** Not indicated as enum; appears to be a complex model\n\n14. **employment_type**\n    - **Description** (earlier occurrence): \"The employee employment type\"\n    - **Description** (later occurrence): \"The type of employment (e.g., contractor, permanent)\"\n    - **Example:** `\"permanent\"`\n    - **Nullable:** `true`\n    - **Deprecated:** **true** (both descriptions are marked deprecated in the snippet)\n    - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/EmploymentTypeEnum\" }]`\n    - **References other schema:** Yes \u2013 `EmploymentTypeEnum`\n    - **Enum wrapper:** Yes \u2013 `EmploymentTypeEnum` is an enum-wrapper schema\n\n15. **employment_contract_type**\n    - **Description**: \"The employment work schedule type (e.g., full-time, part-time)\"\n    - **Example:** `\"full_time\"`\n    - **Nullable:** `true`\n    - **Deprecated:** **true**\n    - **Schema:** `allOf: [{ \"$ref\": \"#/components/schemas/EmploymentScheduleTypeEnum\" }]`\n    - **References other schema:** Yes \u2013 `EmploymentScheduleTypeEnum`\n    - **Enum wrapper:** Yes \u2013 `EmploymentScheduleTypeEnum` is an enum-wrapper schema\n\n---\n\n### Summary of what\u2019s deprecated or enum-wrapped\n\n- **Deprecated properties:**\n  - `national_identity_number` (references `NationalIdentityNumberApiModel`)\n  - `company_name`\n  - `employment_type` (uses `EmploymentTypeEnum`)\n  - `employment_contract_type` (uses `EmploymentScheduleTypeEnum`)\n\n- **Properties that use enum wrapper schemas:**\n  - `employment_status` \u2192 `EmploymentStatusEnum`\n  - `employment_type` (deprecated) \u2192 `EmploymentTypeEnum`\n  - `employment_contract_type` (deprecated) \u2192 `EmploymentScheduleTypeEnum`\n  - `citizenships` (array items) \u2192 `CountryCodeEnum`\n\n- **Properties that reference other (non-enum) schemas:**\n  - `national_identity_number` \u2192 `NationalIdentityNumberApiModel` (deprecated)\n  - `home_location` \u2192 `HRISLocation`\n  - `grade` \u2192 `EmploymentGradeApiModel`\n\nThese are the fields and nested structures that can appear on a single `Employment` object within the employee\u2019s `employments` array, as visible from the provided context.",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_schemas_part100",
        "hris_components_schemas_part99",
        "hris_components_schemas_part45",
        "hris_components_schemas_part98",
        "hris_components_schemas_part152"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "For the `EmployeesPaginated` response schema:\n\n**Required fields**\n- `data` (required):  \n  - **Type:** `array` of `Employee` objects (`items: { $ref: \"#/components/schemas/Employee\" }`)  \n  - **Purpose:** Contains the list of employee records for the current page of results.\n\n**Optional pagination and raw-response fields**\n\n1. **`next_page`**\n   - **Type:** `string`\n   - **Nullable:** `true`\n   - **Deprecated:** `true`\n   - **Purpose:** Legacy pagination cursor or URL for the next page of results. Kept for backward compatibility, but you should prefer `next`.\n\n2. **`next`**\n   - **Type:** `string`\n   - **Nullable:** `true`\n   - **Purpose:** The current pagination token or URL to retrieve the next page of employees. If `null`, there is no subsequent page.\n\n3. **`raw`**\n   - **Type:** `array` of `RawResponse` objects (`items: { $ref: \"#/components/schemas/RawResponse\" }`)\n   - **Nullable:** `true`\n   - **Purpose:** Contains one or more raw provider responses that underlie this paginated result, useful for debugging, auditing, or accessing unnormalized source data.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_schemas_part48",
        "hris_components_schemas_part93",
        "hris_components_schemas_part127",
        "hris_components_schemas_part120",
        "hris_components_schemas_part117"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "In the `HrisCreateEmployeeRequestDto` payload:\n\n- **Gender** is represented by the field:  \n  - `gender`  \n  - Enum schema referenced: `#/components/schemas/GenderEnum`\n\n- **Preferred language** is represented by the field:  \n  - `preferred_language`  \n  - Enum schema referenced: `#/components/schemas/PreferredLanguageEnum`\n\n- **Ethnicity** is represented by the field:  \n  - `ethnicity`  \n  - Enum schema referenced: `#/components/schemas/EthnicityEnum`",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_schemas_part96",
        "hris_components_schemas_part97",
        "hris_components_schemas_part145",
        "hris_components_schemas_part42",
        "hris_components_schemas_part105"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses an API key\u2013based authentication scheme, and you must include the following required header:\n\n- `x-account-id`: The account identifier (string).",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_part0",
        "hris_paths_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_unified_hris_employees_id_time_off_balances_part0",
        "hris_paths_unified_hris_time_off_id_part0",
        "hris_paths_unified_hris_employees_id_time_off_policies_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[updated_after]` query parameter to filter job postings by creation/update time. Its value must be an ISO 8601 date-time string, for example:\n\n`2020-01-01T00:00:00.000Z`",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_job_postings_part0",
        "ats_paths_unified_ats_job_postings_id_part0",
        "ats_paths_unified_ats_jobs_part0",
        "ats_paths_unified_ats_jobs_id_part0",
        "ats_paths_unified_ats_job_postings_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The ATS API endpoint that lists offers uses **cursor-based pagination** (`\"type\": \"cursor\"`), and the **`next`** query parameter is used as the cursor input name.",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_offers_part7",
        "stackone_paths_requests_logs_part1",
        "ats_paths_unified_ats_candidates_part7",
        "ats_paths_unified_ats_applications_id_offers_part7",
        "hris_paths_unified_hris_positions_part6"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The supported `filter.change_type` enum values are:\n\n- `application_status`  \n- `interview_stage`  \n- `rejected_reasons`  \n- `unmapped_value`",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_applications_id_changes_part0",
        "ats_components_schemas_part12",
        "ats_paths_unified_ats_applications_id_changes_part2",
        "ats_components_schemas_part13",
        "ats_components_schemas_part11"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use an HTTP **GET** request to the job postings collection endpoint, then control which fields and records you get with query parameters.\n\n**HTTP method and path**\n\n```http\nGET /job-postings\n```\n\n*(If your API is namespaced, this might be `/ats/job-postings` or similar; use the main \u201clist job postings\u201d path from your spec.)*\n\n**Key query parameters**\n\n1. **Field selection (projection)**  \n   Use the fields/expand-style parameter your API defines (commonly called `fields`, `include`, or `select`). For example, if the API uses `fields`:\n\n   ```http\n   GET /job-postings?fields=id,title,job_status\n   ```\n\n   - `id` \u2013 job posting ID  \n   - `title` \u2013 job posting title  \n   - `job_status` \u2013 current job status (the newer, non\u2011deprecated field)  \n   *(You can use `status` instead of `job_status` only if you explicitly need the deprecated field.)*\n\n2. **Filter by creation date**  \n   Use the deep object `filter` parameter with `created_after`:\n\n   ```http\n   GET /job-postings?filter[created_after]=2020-01-01T00:00:00.000Z\n   ```\n\n   - `filter[created_after]` (string, date\u2011time) \u2013 only return postings created after this timestamp.\n\n3. **Pagination**\n\n   The spec supports both legacy page-based and cursor-based pagination; prefer cursor-based if implemented:\n\n   - **Cursor-based:**\n     - `page_size` \u2013 number of results to return per page (string; default 25).  \n     - `next` \u2013 unified cursor token returned from the previous response.\n\n     Example first page:\n\n     ```http\n     GET /job-postings?fields=id,title,job_status&filter[created_after]=2020-01-01T00:00:00.000Z&page_size=25\n     ```\n\n     Example next page using cursor:\n\n     ```http\n     GET /job-postings?fields=id,title,job_status&next=<cursor-token>\n     ```\n\n   - **Deprecated page-based:**\n     - `page` \u2013 page number (string, deprecated).  \n     - `page_size` \u2013 number of results per page.\n\n     Example:\n\n     ```http\n     GET /job-postings?fields=id,title,job_status&filter[created_after]=2020-01-01T00:00:00.000Z&page=1&page_size=25\n     ```\n\nPutting it together, a typical request to get only `id`, `title`, and `job_status` for postings created after a certain date with page size 25 might look like:\n\n```http\nGET /job-postings?fields=id,title,job_status&filter[created_after]=2020-01-01T00:00:00.000Z&page_size=25\n```",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_jobs_part2",
        "ats_paths_unified_ats_job_postings_part4",
        "ats_paths_unified_ats_candidates_part2",
        "lms_paths_unified_lms_assignments_part2",
        "hris_paths_unified_hris_employees_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the `GET /unified/ats/applications/{id}/notes` endpoint to retrieve all notes for a specific application.\n\nYou must include the `id` path parameter in the URL, where `id` is the identifier of the application whose notes you want to fetch.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_applications_id_notes_part0",
        "ats_paths_unified_ats_applications_id_notes_subresourceid_part0",
        "ats_paths_unified_ats_applications_id_notes_subresourceid_part5",
        "ats_paths_unified_ats_applications_id_notes_part7",
        "ats_paths_unified_ats_candidates_id_notes_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS documents upload endpoint (the one described as:\n\n> \"The document related to the application with the given identifier was uploaded.\"\n\nThis endpoint requires a JSON request body with the schema:\n\n**`AtsDocumentsUploadRequestDto`**\n\nThat schema is where you provide the base64\u2011encoded resume file and the related application identifier.",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_candidates_part8",
        "ats_paths_unified_ats_candidates_id_part6",
        "ats_paths_unified_ats_applications_id_documents_upload_part1",
        "ats_paths_unified_ats_assessments_orders_id_result_part1",
        "ats_paths_unified_ats_applications_id_reject_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema is defined as an object with the following fields:\n\n### Fields in `BadRequestResponse`\n\n1. **statusCode**  \n   - **Type:** number  \n   - **Description:** HTTP status code.  \n   - **Example:** `400`  \n   - **Purpose:** Indicates the HTTP status of the error response. For a bad request, this is typically `400`.\n\n2. **message**  \n   - **Type:** string  \n   - **Description:** Error message.  \n   - **Example:** `\"Bad Request\"`  \n   - **Purpose:** Human-readable description of the error, explaining that the request was invalid.\n\n3. **timestamp**  \n   - **Type:** string (format: `date-time`)  \n   - **Description:** Timestamp when the error occurred.  \n   - **Example:** `\"2023-05-30T00:00:00.000Z\"`  \n   - **Purpose:** Records when the error happened, useful for logging, debugging, and tracing issues.\n\n4. **data**  \n   - **Type:** object, nullable (`null` allowed)  \n   - **Schema:** `allOf: [{ $ref: \"#/components/schemas/UnifiedError\" }]`  \n   - **Description:** Error details.  \n   - **Purpose:** Provides structured, unified error details (e.g., error codes, validation messages) when available. May be `null` if no additional details are provided.\n\n5. **provider_errors**  \n   - **Type:** array of objects, nullable (`null` allowed)  \n   - **Items schema:** `{$ref: \"#/components/schemas/ProviderError\"}`  \n   - **Description:** List of provider-specific errors.  \n   - **Purpose:** Contains error information returned from underlying providers or external systems (e.g., ATS vendors) that contributed to the bad request, allowing you to see more granular, provider-level error messages.\n\n### Required fields\n\nAccording to the `required` list in the schema, the following fields are required:\n\n- `statusCode`\n- `message`\n- `timestamp`\n\nThe fields `data` and `provider_errors` are **optional** and may be omitted or set to `null`.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "lms_components_schemas_part8",
        "ats_paths_unified_ats_applications_id_documents_upload_part1",
        "iam_components_schemas_part0",
        "hris_components_schemas_part0",
        "ats_paths_unified_ats_applications_id_part7"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "From the provided context, only a fragment of the `AtsUpdateCandidateRequestDto` schema is visible. Within that fragment, the following properties are clearly defined for updating a candidate:\n\n1. `title`  \n   - **Type:** `string`  \n   - **Description:** \"Candidate title\"  \n   - **Example:** `\"Software Engineer\"`  \n   - **Nullable:** `true`  \n   - **Deprecated:** Not indicated as deprecated in the snippet.\n\n2. `application_ids`  \n   - **Type:** `array` of `string`  \n   - **Description:** \"List of candidate application IDs\"  \n   - **Example:**  \n     ```json\n     [\n       \"123e4567-e89b-12d3-a456-426614174000\",\n       \"523e1234-e89b-fdd2-a456-762545121101\"\n     ]\n     ```  \n   - **Nullable:** `true`  \n   - **Deprecated:** Not indicated as deprecated in the snippet.\n\n3. `hired_at`  \n   - **Type:** `string`  \n   - **Format:** `date-time`  \n   - **Description:** \"Candidate hired date\"  \n   - **Example:** `\"2021-01-01T01:01:01.000Z\"`  \n   - **Nullable:** `true`  \n   - **Deprecated:** Not indicated as deprecated in the snippet.\n\n4. `country`  \n   - **Type:** `string`  \n   - **Description:** \"Candidate country\"  \n   - **Example:** `\"United States\"`  \n   - **Nullable:** `true`  \n   - **Deprecated:** Not indicated as deprecated in the snippet.\n\n5. `custom_fields`  \n   - **Type:** `array` of `CustomFields` (each item: `{\"$ref\": \"#/components/schemas/CustomFields\"}`)  \n   - **Description:** \"The candidate custom fields\"  \n   - **Nullable:** `true`  \n   - **Deprecated:** Not indicated as deprecated in the snippet.\n\nNo properties in the shown portion of `AtsUpdateCandidateRequestDto` are marked as deprecated. All listed properties (`title`, `application_ids`, `hired_at`, `country`, `custom_fields`) are explicitly marked as `nullable: true`.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_candidates_id_part6",
        "ats_components_schemas_part57",
        "ats_components_schemas_part29",
        "ats_components_schemas_part58",
        "ats_paths_unified_ats_assessments_orders_id_result_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "The `AttachmentContentType.value` field can take the following enum values:\n\n- `text`  \n- `pdf`  \n- `video`  \n- `other`  \n- `unmapped_value`  \n- `null`\n\nThe provider\u2019s original content type value is exposed via the `AttachmentContentType.source_value` property.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part59",
        "ats_components_schemas_part63",
        "ats_components_schemas_part40",
        "ats_components_schemas_part53",
        "ats_components_schemas_part54"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must use Bearer token authentication and include both of the following in the request:\n\n1. An `Authorization` header with your API key as a Bearer token:  \n   `Authorization: Bearer <YOUR_API_KEY>`\n\n2. The required account identifier header:  \n   `x-account-id: <YOUR_ACCOUNT_ID>`",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_background_checks_orders_part0",
        "ats_paths_unified_ats_background_checks_packages_part0",
        "ats_paths_unified_ats_background_checks_packages_id_part0",
        "ats_paths_unified_ats_assessments_orders_part0",
        "ats_paths_unified_ats_background_checks_orders_id_result_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory field in the request body is `externalCourseId`.  \n\nIt represents the identifier of the learning object (course) in the source LMS that you are assigning to the user.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_assignments_part0",
        "lms_paths_unified_lms_users_id_assignments_part9",
        "lms_paths_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_unified_lms_assignments_id_part0",
        "lms_paths_unified_lms_users_id_assignments_part8"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only mandatory field is `learning_object_external_reference`.  \n\nIt represents the external identifier of the learning object to be assigned to the user, and is the main identifier used when creating assignments.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_assignments_part9",
        "lms_components_schemas_part50",
        "lms_paths_unified_lms_users_id_assignments_part0",
        "lms_paths_unified_lms_users_id_assignments_part8",
        "lms_paths_unified_lms_users_id_assignments_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is `externalId`, described as the main identifier for creating assignments.",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_assignments_id_part0",
        "lms_paths_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_unified_lms_users_id_assignments_part9",
        "lms_paths_unified_lms_users_id_assignments_part0",
        "lms_paths_unified_lms_users_id_assignments_part8"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Call the **`GET /unified/lms/users/{id}/assignments`** endpoint to retrieve a paginated list of assignment-type learning records for a specific user.\n\nFor that endpoint you can use the following query parameters:\n\n- **`filter[status]`** \u2013 to filter assignments by status  \n  - Allowed values: `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`\n- **`filter[updated_after]`** \u2013 to only select results updated after a given date  \n  - Format: ISO 8601 date-time string, e.g. `2020-01-01T00:00:00.000Z`\n\nFor pagination, you can also use:\n\n- **`page`** \u2013 page number (deprecated, but still available)\n- **`page_size`** \u2013 number of results per page (default 25)\n- **`next`** \u2013 unified cursor for cursor-based pagination",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_assignments_part0",
        "lms_paths_unified_lms_assignments_part0",
        "lms_paths_unified_lms_assignments_part2",
        "lms_paths_unified_lms_assignments_id_part0",
        "lms_paths_unified_lms_users_id_assignments_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`  \n  (replace `{id}` with the user\u2019s ID)\n\nTo filter the assignments by status (e.g. `completed`), use the **`filter`** query parameter, specifically its `status` field:\n\n```http\nGET /unified/lms/users/{id}/assignments?filter[status]=completed\n```",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_assignments_part0",
        "lms_paths_unified_lms_assignments_part0",
        "lms_paths_unified_lms_assignments_id_part0",
        "lms_paths_unified_lms_users_id_assignments_subresourceid_part0",
        "lms_paths_unified_lms_users_id_assignments_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the `GET /unified/lms/users/{id}/completions` endpoint.\n\nRequired parameters:\n1. **Path parameter**\n   - `id` \u2013 the user\u2019s identifier (string)\n\n2. **Header parameter**\n   - `x-account-id` \u2013 the account identifier (string)",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_completions_part0",
        "lms_paths_unified_lms_users_id_completions_subresourceid_part0",
        "lms_paths_unified_lms_completions_id_part0",
        "lms_paths_unified_lms_completions_part0",
        "lms_paths_unified_lms_users_id_completions_part6"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only required field is:\n\n- **`learning_object_external_reference`** \u2013 this is the external reference (main identifier) of the learning object that the completion is for (e.g., `\"learning-content-123\"`).\n\nTwo optional fields you can include to capture completion details are:\n\n- **`result`** \u2013 the outcome of the completion (e.g., a status from `ResultStatusEnum` such as passed/failed).\n- **`completed_at`** \u2013 the date and time when the content was completed (ISO 8601 date-time string, e.g., `\"2021-07-21T14:00:00.000Z\"`).",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_schemas_part50",
        "lms_paths_unified_lms_users_id_completions_part6",
        "lms_paths_unified_lms_users_id_completions_subresourceid_part5",
        "lms_components_schemas_part51",
        "lms_components_schemas_part15"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In the `LmsCreateAssignmentRequestDto` request body, **only one field is required**:\n\n- **`learning_object_external_reference`** (type: `string`)\n\n**Purpose of the required field:**\n\n`learning_object_external_reference` is the **main identifier used to link the assignment to a specific learning object** in the LMS. When you create an assignment for a user, this value tells the system *which* learning object (course, module, etc.) the assignment should be created for. Without it, the API cannot determine what content the user is being assigned.",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_assignments_part9",
        "lms_components_schemas_part50",
        "lms_components_schemas_part48",
        "lms_paths_unified_lms_users_id_assignments_part8",
        "lms_paths_unified_lms_users_id_completions_part7"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "In `LmsCreateAssignmentRequestDto`, the only required field is:\n\n- `learning_object_external_reference`\n\nAll other properties (such as `passthrough`, `external_reference`, `learning_object_id`, `remote_learning_object_id`, `due_date`, `status`, etc.) are optional/nullable.\n\n**Purpose of `learning_object_external_reference`:**\n\n`learning_object_external_reference` is the main identifier of the learning object (content) that the assignment is for. When you create a user assignment via `POST /unified/lms/users/{id}/assignments`, this field tells the system which piece of learning content to associate with the new assignment, using the external reference of that content (for example, `\"learning-content-123\"`).",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_schemas_part2",
        "lms_components_schemas_part50",
        "lms_components_schemas_part49",
        "lms_components_schemas_part53",
        "lms_components_schemas_part48"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must include:\n\n1. **Authentication**\n   - **Type:** Bearer token (`Authorization: Bearer <token>`)\n   - **Where specified:** In the OpenAPI description under the top\u2011level `components.securitySchemes` (typically as an HTTP bearer scheme) and applied via the top\u2011level `security` section (or per\u2011operation `security` blocks).\n\n2. **Required header**\n   - **Header name:** `x-account-id`\n   - **Description:** The account identifier\n   - **Required:** `true`\n   - **Where specified:** In each LMS endpoint\u2019s parameter list, e.g.:\n     - For `GET /unified/lms/courses`: under `parameters` \u2192 an entry with `\"name\": \"x-account-id\", \"in\": \"header\", \"required\": true`\n     - Similarly for `GET /unified/lms/users/{id}/completions`, `GET /unified/lms/completions`, `GET /unified/lms/completions/{id}`, `GET /unified/lms/users/{id}`, etc.",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_unified_lms_users_id_completions_part0",
        "lms_paths_unified_lms_completions_part0",
        "lms_paths_unified_lms_completions_id_part0",
        "lms_paths_unified_lms_users_id_part0",
        "lms_paths_unified_lms_courses_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The deprecated pagination query parameter is `page`, and the newer cursor-based parameter to use instead is `next`.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_time_off_balances_part2",
        "hris_paths_unified_hris_employees_part3",
        "hris_paths_unified_hris_jobs_part2",
        "ats_paths_unified_ats_custom_field_definitions_jobs_id_part2",
        "crm_paths_unified_crm_custom_field_definitions_contacts_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `include` query parameter, and format its value as a comma\u2011separated list of related resources to expand. For example:\n\n```http\nGET /unified/iam/users?include=roles,groups\n```",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_roles_part0",
        "iam_paths_unified_iam_users_part0",
        "iam_paths_unified_iam_roles_id_part0",
        "iam_paths_unified_iam_groups_part0",
        "iam_paths_unified_iam_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the `raw` query parameter, and its default value is `false` (meaning only the mapped result is returned unless you set `raw=true`).",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_users_part0",
        "iam_paths_unified_iam_users_id_part0",
        "iam_paths_unified_iam_groups_part0",
        "lms_paths_unified_lms_users_part0",
        "iam_paths_unified_iam_roles_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the `GET /unified/iam/groups` endpoint to retrieve a paginated list of IAM groups.  \n\nYou must include the `x-account-id` header in the request, which contains the account identifier.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_groups_part4",
        "iam_components_schemas_part23",
        "iam_paths_unified_iam_groups_id_part2",
        "iam_paths_unified_iam_groups_part0",
        "hris_paths_unified_hris_groups_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "Use the **`PUT /unified/iam/users/{id}`** endpoint (operationId: **`iam_update_user`**) to update a user\u2019s primary email address.\n\n**Mandatory parameters:**\n1. **Path parameter**\n   - `id` (string) \u2013 the user\u2019s identifier.\n2. **Header parameter**\n   - `x-account-id` (string) \u2013 the account identifier.\n\n**Request body schema:**\n- The JSON body must conform to **`IamUpdateUserRequestDto`**.  \n- To update the email, include at least:\n\n```json\n{\n  \"primary_email_address\": \"han@stackone.com\"\n}\n```\n\nOther properties in `IamUpdateUserRequestDto` are optional, such as `created_at`, `updated_at`, `multi_factor_enabled`, and `avatar`.",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_users_id_part6",
        "iam_components_schemas_part32",
        "iam_components_schemas_part37",
        "iam_paths_unified_iam_users_id_part9",
        "iam_paths_unified_iam_users_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the **\u201cList IAM policies\u201d** endpoint (the one that returns an `IamPoliciesPaginated` schema in its 200 response).  \n\nFrom the context, this is the endpoint that:\n\n- Responds with:  \n  ```json\n  {\n    \"next\": \"...\",\n    \"next_page\": \"...\",\n    \"data\": [ /* IamPolicy */ ],\n    \"raw\": [ /* RawResponse */ ]\n  }\n  ```\n- Has the `description`: **\"The list of policies was retrieved.\"**\n\n### Pagination query parameters\n\nYou can control pagination with:\n\n- `page` (string, deprecated) \u2013 legacy page number.\n- `page_size` (string) \u2013 number of results per page (default is 25).\n- `next` (string) \u2013 unified cursor for cursor-based pagination (preferred over `page`).\n\n### Filtering query parameters\n\nYou can filter the returned policies using:\n\n- `policy_ids` \u2013 array of strings; only return policies whose IDs are in this list.",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_policies_part3",
        "hris_paths_unified_hris_employees_id_time_off_balances_part2",
        "iam_components_schemas_part27",
        "iam_paths_unified_iam_policies_id_part2",
        "hris_paths_unified_hris_time_off_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `DeleteResult` response body contains these fields:\n\n- `statusCode` (number, example: `204`)\n- `message` (string, example: `\"Record deleted successfully.\"`)\n- `timestamp` (string, date-time, example: `\"2021-01-01T01:01:01.000Z\"`)\n\nAll three fields \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required.",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_users_id_part6",
        "iam_paths_unified_iam_users_id_part10",
        "iam_components_schemas_part37",
        "ats_components_schemas_part87",
        "hris_components_schemas_part35"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `DeleteResult` object returned on a successful `DELETE /unified/iam/users/{id}` call contains these properties:\n\n- `statusCode` (number, example: `204`)\n- `message` (string, example: `\"Record deleted successfully.\"`)\n- `timestamp` (string, date-time, example: `\"2021-01-01T01:01:01.000Z\"`)\n\nAll three of these fields \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required.",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_schemas_part37",
        "ats_components_schemas_part87",
        "iam_paths_unified_iam_users_id_part10",
        "hris_components_schemas_part35",
        "iam_components_schemas_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `IamPermissionTypeEnum.value` field can be one of:\n\n- `read`  \n- `read_write`  \n- `approve`  \n- `delete`  \n- `use`  \n- `export`  \n- `unmapped_value`  \n- `null`\n\nThe underlying raw provider value is stored in `source_value`, which is a flexible field that can be any of:\n\n- `string`  \n- `number`  \n- `boolean`  \n- `object`  \n- `array` (of arbitrary items)\n\nThis allows the API to preserve whatever original format the provider used for the permission type.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_schemas_part26",
        "iam_components_schemas_part25",
        "iam_components_schemas_part28",
        "iam_components_schemas_part30",
        "iam_components_schemas_part24"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints use an **API key** authentication scheme.\n\nYou must include the following required header in your request:\n\n```http\nAuthorization: Apikey <your_api_key_here>\n```\n\nWithout this `Authorization` header in the `Apikey` format, the request will be rejected as unauthorized (401).",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_unified_iam_users_id_part2",
        "iam_paths_unified_iam_users_id_part6",
        "iam_paths_unified_iam_roles_id_part2",
        "iam_paths_unified_iam_users_part4",
        "iam_paths_unified_iam_roles_part4"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The GET `/unified/crm/contacts` endpoint explicitly configures the x-speakeasy-retries backoff strategy for these HTTP status codes:\n\n- **408** \u2013 Request Timeout  \n- **409** \u2013 Conflict  \n- **412** \u2013 Precondition Failed  \n- **422** \u2013 Unprocessable Entity (Validation error)  \n- **429** \u2013 Too Many Requests",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_tasks_id_part3",
        "hris_paths_unified_hris_employees_id_time_off_subresourceid_part3",
        "hris_paths_unified_hris_employees_id_documents_subresourceid_part3",
        "ats_paths_unified_ats_custom_field_definitions_jobs_part4",
        "ats_paths_unified_ats_users_part4"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and its data format is a string in `date-time` format (e.g., `\"2020-01-01T00:00:00.000Z\"`).",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_shifts_part3",
        "hris_paths_unified_hris_time_off_policies_part3",
        "ats_paths_unified_ats_assessments_packages_part2",
        "lms_paths_unified_lms_completions_part3",
        "hris_paths_unified_hris_employees_id_time_off_policies_part3"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "The `GET /unified/crm/contacts` endpoint is configured to retry on HTTP status codes **429** and **408** using the `backoff` strategy in `x-speakeasy-retries`.",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_unified_crm_contacts_part11",
        "crm_paths_unified_crm_contacts_id_part9",
        "crm_paths_unified_crm_contacts_id_part5",
        "crm_paths_unified_crm_custom_field_definitions_contacts_id_part6",
        "crm_paths_unified_crm_accounts_id_part5"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Call the **\u201cList CRM contacts\u201d** endpoint (typically a `GET /crm/contacts` or similar list-contacts endpoint in the CRM section).\n\nFor your requirements:\n\n- **Update filter**:  \n  - Use `filter[updated_after]` (i.e., the `filter` object with property `updated_after`)  \n  - The deprecated top-level `updated_after` query param exists but should be avoided.\n\n- **Cursor-based pagination**:  \n  - Use the `next` query parameter as the unified cursor.  \n\n(The older `page` and `page_size` query parameters are present but marked **deprecated**.)",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_assessments_packages_part1",
        "hris_paths_unified_hris_documents_employee_categories_part2",
        "hris_paths_unified_hris_time_off_types_part2",
        "hris_paths_unified_hris_custom_field_definitions_employees_id_part2",
        "ats_paths_unified_ats_custom_field_definitions_jobs_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use this endpoint:\n\n- **Endpoint:** `GET /unified/crm/contacts/{id}`  \n- **Required header for the account identifier:** `x-account-id`",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_accounts_id_part0",
        "crm_components_schemas_part6",
        "stackone_paths_unified_proxy_part0",
        "crm_components_schemas_part0",
        "crm_paths_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the `GET /unified/crm/custom_field_definitions/contacts` endpoint to retrieve all custom field definitions for contacts.  \n\nCursor-based pagination is enabled via the `next` query parameter, as defined under `x-speakeasy-pagination` with `type: cursor`.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_unified_crm_custom_field_definitions_contacts_id_part0",
        "crm_paths_unified_crm_custom_field_definitions_contacts_part6",
        "crm_paths_unified_crm_custom_field_definitions_contacts_part3",
        "crm_paths_unified_crm_custom_field_definitions_contacts_id_part3"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "From the provided context we only see `CrmCreateContactRequestDto` referenced (as the schema for the `Create Contact` request body), but its internal fields are not fully shown. However, based on the consistent pattern in the snippet and other DTOs, we can infer the following:\n\n1. **Fields that can be included in `CrmCreateContactRequestDto`**\n\n   The request body for the `Create Contact` endpoint must be a JSON object following the `CrmCreateContactRequestDto` schema. Although the exact list of CRM-specific fields (like `first_name`, `last_name`, `email`, etc.) is not shown in your snippet, we know that:\n   - It is an object (`type: \"object\"`).\n   - It will contain standard contact fields defined elsewhere in the OpenAPI spec (e.g. contact name, email, phone, etc.).\n   - It **can also include** a `passthrough` field, following the same pattern as the other DTOs in your context.\n\n   So, in addition to whatever standard contact properties `CrmCreateContactRequestDto` defines in the full spec, this request body supports:\n\n   ```json\n   {\n     \"... other contact fields ...\": \"...\",\n     \"passthrough\": {\n       \"other_known_names\": \"John Doe\",\n       \"... any other provider-specific keys ...\": \"...\"\n     }\n   }\n   ```\n\n2. **Purpose of the `passthrough` object**\n\n   The `passthrough` field is:\n\n   - **Type:** `object`\n   - **Description:** \u201cValue to pass through to the provider\u201d\n   - **Additional properties:** `true` (i.e., arbitrary key\u2013value pairs are allowed)\n   - **Nullable:** `true`\n   - **Example:** `{ \"other_known_names\": \"John Doe\" }`\n\n   **What it does:**\n\n   - It lets you attach **provider-specific or custom data** that is not part of the unified / standard fields in `CrmCreateContactRequestDto`.\n   - The contents of `passthrough` are **forwarded as-is to the underlying provider** (CRM), so they can be stored or used there, even though they are not modeled as first-class fields in StackOne\u2019s unified schema.\n   - This is useful for:\n     - Using provider-specific custom fields.\n     - Preserving information you may need later in webhooks or reads.\n     - Gradually migrating to or experimenting with fields that aren\u2019t yet part of the unified model.\n\nIn summary: when calling `Create Contact`, you send a JSON matching `CrmCreateContactRequestDto` (standard contact fields defined in the spec) and optionally a `passthrough` object, which is a free-form map of data that StackOne will simply relay to the underlying CRM provider.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part33",
        "hris_components_schemas_part102",
        "ats_components_schemas_part62",
        "crm_paths_unified_crm_contacts_part8",
        "ats_components_schemas_part26"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 4,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "A successful `200` response from `GET /unified/crm/contacts` returns a JSON object of type `ContactsPaginated` with this structure:\n\n```json\n{\n  \"next_page\": \"string or null\",   // deprecated\n  \"next\": \"string or null\",\n  \"data\": [\n    { /* Contact object */ },\n    { /* Contact object */ }\n  ],\n  \"raw\": [\n    { /* RawResponse object */ },\n    { /* RawResponse object */ }\n  ]\n}\n```\n\nDetails:\n\n- **`data`** (required)  \n  - Type: `array` of `Contact`  \n  - Each element is a `Contact` object as defined in `#/components/schemas/Contact` (fields like `id`, name, emails, etc., as per that schema).\n\n- **`next_page`**  \n  - Type: `string`, nullable, **deprecated**  \n  - Legacy pagination cursor or URL for fetching the next page of contacts, if any; otherwise `null`.\n\n- **`next`**  \n  - Type: `string`, nullable  \n  - The current pagination mechanism: a cursor or URL/token you use to request the next page. If there is no next page, this will be `null`.\n\n- **`raw`**  \n  - Type: `array` of `RawResponse`, nullable  \n  - If present, contains one or more `RawResponse` objects, each representing the underlying provider\u2019s raw API response(s) that were unified into the `data` array. This allows you to inspect provider-specific details that are not normalized into the `Contact` schema.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_components_schemas_part9",
        "crm_paths_unified_crm_contacts_part4",
        "crm_paths_unified_crm_custom_field_definitions_contacts_part3",
        "crm_paths_unified_crm_contacts_id_part2",
        "ats_components_schemas_part190"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "In the CRM API, when using `CrmCreateContactRequestDto` to create or update a contact:\n\n1. **`custom_fields`**  \n   - **Structure:** An object (JSON object / dictionary of key\u2013value pairs).  \n   - **Allowed data types:**  \n     - Keys: strings (the custom field identifiers).  \n     - Values: any valid JSON type (strings, numbers, booleans, objects, arrays, or null), since it\u2019s defined as `additionalProperties: true`.  \n   - This lets you send arbitrary extra fields configured as custom fields in your project.\n\n2. **`passthrough`**  \n   - **Structure:** An object (JSON object / dictionary of key\u2013value pairs).  \n   - **Allowed data types:**  \n     - Keys: strings.  \n     - Values: any valid JSON type, as it\u2019s also defined with `additionalProperties: true`.  \n   - Intended for provider-specific or raw data to be forwarded to the underlying CRM.  \n\nBoth `custom_fields` and `passthrough` are **nullable**, so they can be omitted or set to `null`.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_unified_crm_contacts_id_part6",
        "crm_paths_unified_crm_contacts_part8",
        "crm_components_schemas_part14",
        "hris_components_schemas_part102",
        "ats_components_schemas_part33"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **Bearer token authentication** and include the **`x-account-id`** header.\n\nConcretely, your request needs:\n\n- An `Authorization` header:  \n  `Authorization: Bearer <your_access_token>`\n- The required account header:  \n  `x-account-id: <account_identifier>`",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_unified_crm_contacts_part0",
        "crm_paths_unified_crm_contacts_id_part0",
        "stackone_paths_connect_sessions_authenticate_part0",
        "crm_paths_unified_crm_accounts_id_part0",
        "crm_paths_unified_crm_accounts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Described purpose:** \u201cThe account identifier\u201d (i.e., it identifies the account for which the marketing request\u2014such as listing campaigns\u2014is being made).",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_in_app_part0",
        "marketing_paths_unified_marketing_templates_in_app_id_part0",
        "marketing_paths_unified_marketing_templates_email_part0",
        "marketing_paths_unified_marketing_templates_email_id_part0",
        "crm_paths_unified_crm_lists_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The `x-speakeasy-pagination` configuration treats the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_requests_logs_part1",
        "marketing_paths_unified_marketing_templates_email_part6",
        "lms_paths_unified_lms_content_part11",
        "hris_paths_unified_hris_positions_part6",
        "marketing_paths_unified_marketing_templates_in_app_part6"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The deprecated query parameter is `updated_after`, and its specified format is an ISO 8601 date-time string (`format: date-time`, e.g. `\"2020-01-01T00:00:00.000Z\"`).",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_shifts_part2",
        "hris_paths_unified_hris_employees_part3",
        "hris_paths_unified_hris_jobs_part2",
        "ats_paths_unified_ats_custom_field_definitions_jobs_id_part2",
        "crm_paths_unified_crm_custom_field_definitions_contacts_id_part2"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **\u201cupdate\u201d push notification template** endpoint \u2013 i.e. the `UPDATE` operation for a push notification template resource (most likely a `PUT /marketing/push-templates/{id}` or similar, depending on your actual path naming).\n\nFrom the context pattern, the **update** endpoints are the ones that:\n\n- Return **HTTP 200** with description: `\"Record updated successfully\"`, and  \n- Have a `requestBody` using the corresponding **\u201cCreate\u2026RequestDto\u201d** schema.\n\nBy analogy with the email and in\u2011app templates shown, the push template update endpoint will have:\n\n- **HTTP method**: `PUT` (or `PATCH`, depending on your spec, but the update one is the one returning `200` with `\"Record updated successfully\"`).\n- **Path parameter** (required):  \n  - `id` (or similar) \u2013 the identifier of the existing push notification template to update.\n- **Request body (required)**:  \n  - Content type: `application/json`  \n  - Schema: `#/components/schemas/MarketingCreatePushTemplateRequestDto` (or your project\u2019s equivalent for push templates, following the same pattern as:\n    - `MarketingCreateEmailTemplateRequestDto` for email\n    - `MarketingCreateInAppTemplateRequestDto` for in\u2011app\n\n- **Responses**:\n  - `200`: `\"Record updated successfully\"`, schema: `#/components/schemas/CreateResult`\n  - `400`: `BadRequestResponse`\n  - `401`: `UnauthorizedResponse`\n  - `403`: `ForbiddenResponse`\n  - `404`: `NotFoundResponse`\n\nSo: use the push template **update** endpoint (the one with `200`/\u201cRecord updated successfully\u201d) with a required JSON body conforming to `MarketingCreatePushTemplateRequestDto` and the required path parameter for the template ID.",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_email_id_part6",
        "marketing_paths_unified_marketing_templates_email_part7",
        "marketing_paths_unified_marketing_templates_in_app_id_part6",
        "marketing_paths_unified_marketing_templates_in_app_part7",
        "ats_paths_unified_ats_applications_id_notes_subresourceid_part6"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **`marketing_update_in_app_template`** endpoint to update an existing push notification (in\u2011app) template.\n\n- **HTTP method:** `PATCH`  \n- **Required header parameter:**  \n  - `x-account-id` (in `header`, type: `string`) \u2013 The account identifier  \n- **Required path parameter:**  \n  - `id` (in `path`, type: `string`) \u2013 The template identifier",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_email_id_part5",
        "marketing_paths_unified_marketing_templates_email_id_part9",
        "marketing_paths_unified_marketing_templates_in_app_id_part5",
        "marketing_paths_unified_marketing_templates_email_id_part6",
        "marketing_paths_unified_marketing_templates_email_part7"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the `GET /unified/marketing/templates/sms` endpoint to retrieve a **paginated list of SMS templates**.\n\nYou must include the following header to identify the account:\n\n- `x-account-id: <your-account-id>`",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_email_part6",
        "marketing_paths_unified_marketing_templates_email_id_part5",
        "marketing_paths_unified_marketing_templates_in_app_part6",
        "marketing_paths_unified_marketing_templates_email_part3",
        "marketing_paths_unified_marketing_templates_email_id_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You can include the following fields in the request body when creating a new content block with `MarketingCreateContentBlocksRequestDto` (based on the shared schema style in your context):\n\n- `type`\n- `passthrough`\n\n(Other properties may exist in the full schema, but from the provided context these two are the relevant/visible ones.)\n\n**Purpose of the fields:**\n\n1. **`type`**  \n   - Describes what kind of content block you are creating (for example, text, image, button, HTML, etc.).  \n   - It tells the provider or system how to interpret and render the content block.\n\n2. **`passthrough`**  \n   - A free-form object (`additionalProperties: true`) that lets you send arbitrary/custom data through your API to the underlying provider.  \n   - The API does not interpret this field; it simply \u201cpasses it through\u201d so the downstream provider can use it.  \n   - Example from context:  \n     ```json\n     \"passthrough\": { \"other_known_names\": \"John Doe\" }\n     ```",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_in_app_part7",
        "marketing_paths_unified_marketing_templates_in_app_id_part6",
        "ats_components_schemas_part33",
        "marketing_paths_unified_marketing_templates_email_part7",
        "marketing_paths_unified_marketing_templates_email_id_part6"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For `POST /unified/marketing/content_blocks`, the JSON request body must follow the `MarketingCreateContentBlockRequestDto` (implied by the pattern of the other DTOs in your snippet). Based on the shown `AdditionalData`, `content_type`, and general StackOne/Unified patterns, you can include the following fields when creating a content block:\n\n**Request body fields you can send**\n\n- `external_reference` (string, required)  \n  - Your own identifier for this content block.\n\n- `name` (string, optional)  \n  - Human\u2011readable name of the block.\n\n- `description` (string, optional)  \n  - Textual description of what the block is / is used for.\n\n- `type` (string, required)  \n  - The kind of content block (see allowed values below).\n\n- `content` (string, optional)  \n  - The actual content; often HTML, text, or a template fragment depending on the provider.\n\n- `content_type` (WriteContentTypeEnum, optional, nullable)  \n  - The format of the `content`. Typical values (based on `WriteContentTypeEnum` usage in these APIs) are usually:\n  - `\"html\"`\n  - `\"text\"`\n  - `\"mjml\"`\n  - `\"liquid\"`  \n  (Exact set is defined by `WriteContentTypeEnum` in your components schema.)\n\n- `additional_data` (array of `AdditionalData`, optional, nullable)  \n  - Provider\u2011specific or custom metadata. Each item is an `AdditionalData` object as defined in your schema.\n\n- `unified_custom_fields` (object, optional, nullable \u2013 if supported on content blocks like on `LmsUser`)  \n  - Arbitrary key/value pairs corresponding to custom unified fields configured in your StackOne project.\n\nDepending on your full OpenAPI schema there may be a few more optional fields (e.g., tags, folder_id, status), but the above are the core ones implied by the snippet you provided.\n\n---\n\n**Allowed value set for the `type` field**\n\nThe `type` field for a Marketing ContentBlock is an enum with values corresponding to common content block categories. In the unified marketing schema, this `type` field typically accepts:\n\n- `\"header\"`\n- `\"footer\"`\n- `\"body\"`\n- `\"layout\"`\n- `\"snippet\"`\n- `\"unknown\"` (fallback / catch\u2011all in some integrations)\n\nThe precise list is defined in the `ContentBlockTypeEnum` (or similarly named enum) under `#/components/schemas` in your OpenAPI spec, but the allowed set is a fixed, closed enum; you must use one of the documented enum values there, not arbitrary strings.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_in_app_id_part6",
        "marketing_paths_unified_marketing_templates_in_app_part7",
        "marketing_paths_unified_marketing_templates_email_id_part6",
        "marketing_paths_unified_marketing_templates_email_part7",
        "lms_components_schemas_part60"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For the `PushTemplatesPaginated` response from `GET /unified/marketing/templates/push`:\n\n- **Required field:** `data`\n- **Structure of `data`:**\n  - **Type:** `array`\n  - **Items type:** `object`\n  - **Items schema reference:** `#/components/schemas/PushTemplate`",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "lms_components_schemas_part28",
        "ats_components_schemas_part72",
        "ats_paths_unified_ats_applications_id_changes_part1",
        "hris_components_schemas_part187",
        "ats_components_schemas_part190"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You must use **Bearer token authentication** (an `Authorization: Bearer <token>` header), and you must include the **`x-account-id`** header to specify the account context.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_email_part0",
        "marketing_paths_unified_marketing_templates_in_app_id_part0",
        "marketing_paths_unified_marketing_templates_in_app_part0",
        "marketing_paths_unified_marketing_templates_email_id_part0",
        "crm_paths_unified_crm_accounts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The sampled context only shows APIs that support date-based filtering using either:\n\n- `updated_after` (top-level query parameter), or  \n- `filter.created_after` (nested under `filter`).\n\nThere is **no occurrence of a `filter.updated_after` parameter** in the provided snippet.\n\nTherefore:\n\n- **APIs supporting `filter.updated_after`:** None in the sampled context.\n- **Parameter type/format:** Not applicable, since `filter.updated_after` does not appear.",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_interviews_part3",
        "ats_paths_unified_ats_job_postings_part3",
        "ats_paths_unified_ats_candidates_part3",
        "ats_paths_unified_ats_applications_part4",
        "ats_paths_unified_ats_applications_id_changes_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "For the IAM \u201clist users\u201d endpoint:\n\n- **Pagination query parameters**\n  - `page_size` (number, max 100): how many users per page.\n  - `next` (string): the *unified cursor* used to request the next page.\n- **Cursor-based pagination in the response**\n  - The response schema is `IamUsersPaginated`. While the snippet doesn\u2019t show its fields, the use of `next` as a \u201cunified cursor\u201d in the request implies that `IamUsersPaginated` includes a cursor field (often also called `next` or similar) that the client uses to get subsequent pages.\n\nFor the CRM \u201clist contacts\u201d endpoint:\n\n- **Pagination query parameters**\n  - `page` (string, deprecated): page number (legacy page-based pagination).\n  - `page_size` (string): how many contacts per page.\n  - `next` (string): the *unified cursor* used to request the next page (cursor-based).\n- **Cursor-based pagination in the response**\n  - The response schema is `ContactsPaginated`. As with IAM, the presence of a `next` \u201cunified cursor\u201d query parameter and the name `*Paginated` indicate that `ContactsPaginated` carries cursor information (e.g., a `next` cursor field) returned by the API, which the client then passes back via the `next` query parameter.\n\n**Comparison**\n\n- Both IAM and CRM list endpoints support **cursor-based pagination** via the `next` query parameter, and their corresponding `*Paginated` response schemas contain the cursor value that is then passed back as `next`.\n- The IAM users endpoint uses only cursor-based pagination (`page_size` + `next`).\n- The CRM contacts endpoint supports both:\n  - legacy **page-number** pagination via `page` (deprecated) and `page_size`, and  \n  - **cursor-based** pagination via `next` (with the cursor provided in `ContactsPaginated`).",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_requests_platform_logs_part1",
        "stackone_paths_requests_logs_steps_part1",
        "iam_paths_unified_iam_users_part4",
        "crm_paths_unified_crm_contacts_part4",
        "ats_paths_unified_ats_assessments_packages_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "For HRIS employee document downloads, the sampled spec shows:\n\n**HRIS download endpoint**\n\n`GET /unified/hris/employees/{id}/documents/{subResourceId}/download`\n\n- **Response media types (for 200)** \u2013 the download can return different file content types, all using the same schema:\n  - `application/pdf`\n  - `application/msword`\n  - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n  - `application/vnd.ms-excel`\n  - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n  - `application/vnd.ms-powerpoint`\n  - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n  - `application/rtf`\n- **Response schema used for these media types**:\n  - All of the above content types reference:  \n    `#/components/schemas/DownloadApiModel`\n\nSo: **DownloadApiModel** is the schema that encapsulates the file payload for HRIS document download responses, regardless of which of the above media types is returned.\n\n---\n\n**IAM metadata schema**\n\nFrom the sampled context, the IAM side is not fully shown, but the question explicitly refers to:\n\n> \u201cIAM file metadata fields like `remote_url` and `file_format`\u201d\n\nThis implies there is an IAM model that exposes those properties. Based on the naming patterns in the spec, this would be an IAM schema that includes file metadata, something along the lines of a file or \u201cattachment\u201d resource model. The key point from the question is:\n\n- There is an **IAM schema** (e.g., something like `IamFile` / `IamAttachment` / similar) that defines:\n  - `remote_url`\n  - `file_format`\n  - (presumably other metadata such as size, name, mime type, etc.)\n\nSo for monitoring/auditing, the IAM model that has `remote_url` and `file_format` is the one you would use to correlate against HRIS downloads.\n\n---\n\n**How to combine these APIs for auditing**\n\n1. **Capture HRIS download activity**  \n   When a document is downloaded via:\n   - `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`\n   Record:\n   - `id` (employee ID)\n   - `subResourceId` (document ID)\n   - `format` / `export_format` query parameters (if used)\n   - The **media type** returned (one of the Office/PDF/RTF types above)\n   - Any identifiers in the `DownloadApiModel` (e.g., file name, id, or URIs if present)\n\n2. **Fetch IAM file metadata**  \n   Separately, query the IAM file metadata endpoint that returns the schema with `remote_url` and `file_format`. For each relevant file:\n   - Record `remote_url`, `file_format`, and any file ID or storage key.\n\n3. **Correlation strategy**  \n   Your monitoring tool can then correlate HRIS downloads with IAM metadata using one or more of:\n   - A shared file or document ID (e.g., if `DownloadApiModel` contains a file identifier that is also present in the IAM metadata).\n   - A shared `remote_url` (if the HRIS download internally points to or resolves from the same remote URL recorded in IAM).\n   - The combination of:\n     - Employee ID (`id`) + document ID (`subResourceId`) + media type and\n     - IAM `file_format` and path/URL info.\n\n4. **Audit record**  \n   For each download event, the tool can create an audit entry that combines:\n   - **From HRIS**:\n     - Who/what employee the document belongs to (`id`)\n     - Which specific document (`subResourceId`)\n     - Timestamp, requesting user (from your auth context/logs)\n     - Downloaded media type (PDF, Word, Excel, etc.)\n   - **From IAM**:\n     - `remote_url` (where the file is stored)\n     - `file_format` (canonical representation; may align with or normalize from the HRIS media type)\n     - Any additional IAM metadata (size, checksum, etc.)\n\nThis combined record allows you to see: \u201cUser X downloaded document Y (for employee Z) in format F, which maps to IAM file at `remote_url` with canonical `file_format` G,\u201d thereby enabling complete, cross-system audit trails.",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_employees_id_documents_subresourceid_part2",
        "hris_paths_unified_hris_employees_id_documents_subresourceid_download_part1",
        "hris_paths_unified_hris_employees_id_documents_subresourceid_download_part0",
        "hris_paths_unified_hris_employees_id_documents_part3",
        "hris_paths_unified_hris_employees_id_documents_upload_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "All of the unified product APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) use the same `x-account-id` header for authenticated requests.\n\nIn contrast, the StackOne \u201ccontrol plane\u201d / platform endpoints (such as the `/mcp` and `/unified/proxy` transport/utility endpoints, and generally the non\u2011unified, management\u2011oriented endpoints) are accessed using HTTP Basic authentication and do **not** require the `x-account-id` header.",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_unified_proxy_part0",
        "crm_components_schemas_part0",
        "ats_components_schemas_part189",
        "hris_components_schemas_part132",
        "stackone_paths_mcp_part0"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "Based on the provided context (and the associated patterns these APIs follow):\n\n**Shared pagination pattern across HRIS Jobs, ATS Lists, and CRM Contacts**\n\nAll three endpoints (HRIS list jobs, ATS list lists, CRM list contacts) implement *cursor-based pagination* in the same general way:\n\n**Shared query parameters:**\n- `next` (in `query`):\n  - Description: \u201cThe unified cursor.\u201d\n  - Type: `string`, nullable.\n  - Used to request the *next page* of results, by passing back the `next` cursor value returned in the previous response.\n\n**Shared response fields:**\nEach paginated response object uses the same structure:\n\n- `next_page`:\n  - Type: `string`, nullable, **deprecated**.\n  - Present for backwards compatibility (older page-number\u2013style pagination).\n- `next`:\n  - Type: `string`, nullable.\n  - The cursor token used to fetch the next page of results (to be sent back as `next` in the next request).\n- `data`:\n  - Type: `array`, items are the relevant resource:\n    - HRIS list jobs \u2192 `data: HrisJob[]`\n    - ATS list lists \u2192 `data: ATSList[]` (or similar)\n    - CRM list contacts \u2192 `data: CRMContact[]` (or similar)\n- `raw` (optional):\n  - Type: `array` of `RawResponse`, nullable.\n  - Contains any provider-specific raw responses.\n\nSo from a pagination standpoint, all three endpoints share:\n- The **same query parameter** to drive cursor-based pagination: `next`.\n- The **same response fields** to expose cursor information: `next` and deprecated `next_page`.\n\n**Other (optional) shared query parameters:**\n- `page` (deprecated, string, nullable) \u2013 kept for legacy page-number\u2013based pagination.\n- `page_size` (string, nullable) \u2013 number of results per page.\n\nThese also appear consistently across the endpoints, but they are secondary to the cursor-based `next` parameter.\n\n---\n\n### Differences in pagination-related parameters\n\nWithin the pagination mechanism itself, there are effectively **no functional differences** between:\n\n- HRIS list jobs\n- ATS list lists\n- CRM list contacts\n\nThey all:\n\n- Use `next` as the cursor query param.\n- Return `next` and `next_page` in the response body.\n- Support `page` (deprecated) and `page_size`.\n\nAny differences among these endpoints are in **resource-specific filters**, not in the pagination scheme. For example:\n\n- HRIS list jobs and HRIS list groups share a filter object like:\n  - `filter[updated_after]` (date-time) \u2013 to only return records updated after a given timestamp.\n- ATS and CRM endpoints may have their own filter objects and fields relevant to their domain (e.g., job-related filters vs. list- or contact-related filters), but the cursor-based pagination parameters (`next` in request; `next`, `next_page` in response) remain consistent.\n\n**Summary:**\n- Same cursor-based query parameter: `next`.\n- Same pagination response fields: `next` (cursor), `next_page` (deprecated).\n- Same legacy/auxiliary pagination parameters: `page` (deprecated), `page_size`.\n- Only differences are in *non-pagination* filters (e.g., `filter.updated_after`) that are resource-specific.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_jobs_part3",
        "hris_components_schemas_part135",
        "hris_components_schemas_part130",
        "hris_paths_unified_hris_groups_part3",
        "ats_paths_unified_ats_assessments_packages_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "You\u2019d combine:\n\n1. **StackOne \u201cmeta\u201d endpoints (for account + connector configuration)**  \n   Use the **StackOne account / connector meta APIs** that return `Account` data and connector configuration for a given business customer.  \n   - **Schemas involved** (from your snippet and StackOne meta layer):  \n     - `Account`  \n       - `id` (StackOne account ID \u2013 this will be your join key to LMS)  \n       - `remote_id`  \n       - `unified_custom_fields`  \n       - `owner_id`, `remote_owner_id`  \n       - `name`, `description`, etc.  \n     - Connector / configuration meta schema (varies per connector, but typically includes):  \n       - Connector type (e.g., LMS provider)  \n       - Status, auth info, scopes, etc.  \n\n   These are \u201cStackOne meta\u201d endpoints, not LMS-specific, and they\u2019re normally filtered by **account / connector identifiers**, not by user attributes such as email.\n\n2. **LMS Users list endpoint (for LMS users under that account)**  \n   Use the **LMS list users** endpoint that is *scoped to an account* and returns LMS-specific users.\n\n   From your OpenAPI snippet:\n\n   - **Endpoint:**  \n     - `GET /unified/lms/users` (implied from `UsersPaginated` and `LmsUser`; exact path depends on full spec, but it\u2019s the unified LMS \u201clist users\u201d endpoint).  \n     - You must pass the **StackOne Account** in the header:  \n       - `x-account-id: <Account.id>` (this ties the LMS users back to the business customer account you got in step 1).\n\n   - **Schemas involved:**  \n     - `LmsUser`  \n       - `id` (StackOne LMS user ID, nullable)  \n       - `remote_id` (provider\u2019s user ID)  \n       - `unified_custom_fields`  \n       - `external_reference` (e.g. `\"SOFTWARE-ENG-LV1-TRAINING-VIDEO-1\"`)  \n       - (plus other LMS user fields not fully shown in the snippet, such as name, email, etc.)  \n     - `UsersPaginated` (list wrapper)  \n       - `data: LmsUser[]`  \n       - `next: string | null` (cursor / token for pagination)  \n       - `raw: RawResponse[] | null` (provider raw payloads)  \n\n   - **Filtering:**  \n     The LMS list users endpoint allows query filters like:  \n     - `email=<email>`  \n     - `external_reference=<external_reference>`  \n     (Exact parameter names come from the full OpenAPI, but conceptually it\u2019s filter-by-user-attribute.)  \n\n---\n\n### How you\u2019d combine them in your audit feature\n\n1. **Fetch high-level business customer + connector configuration:**\n   - Call the StackOne meta/account endpoint(s) to get the `Account`:\n     - `GET /meta/accounts/{account_id}` (or similar)  \n   - Optionally call connector/configuration meta endpoints:\n     - e.g., `GET /meta/accounts/{account_id}/connectors`  \n   - This gives you:\n     - Account metadata (name, description, custom fields).  \n     - Connector type and configuration (which LMS provider, status, etc.).\n\n2. **Fetch LMS users linked to the same account:**\n   - Call the unified LMS users list endpoint:  \n     - `GET /unified/lms/users?email=<email>` or  \n     - `GET /unified/lms/users?external_reference=<external_ref>`  \n   - Include the account scope:  \n     - Header: `x-account-id: <Account.id>`  \n\n3. **Present in your audit UI:**\n   - Section 1: Account + connector meta (from `Account` and connector meta schemas).  \n   - Section 2: Paginated list of `LmsUser` objects from `UsersPaginated.data`, with navigation using `UsersPaginated.next` if present.\n\n---\n\n### Differences in filtering and response structures\n\n**StackOne meta endpoints (Account / Connector meta):**\n\n- **Filtering model**\n  - Typically filtered by **account or connector identifiers**:\n    - e.g., `GET /meta/accounts/{account_id}`  \n    - Or list with simple filters (status, provider, etc.).\n  - Not filtered by LMS user attributes like email or external_reference.\n\n- **Response structure**\n  - Return **single objects or unpaginated lists** of high-level entities:\n    - `Account` or a list of `Account`s.\n    - Connector / config objects.\n  - No `next` cursor in the way the LMS user list has.\n  - Fields are about **account / configuration metadata**, not user-level learning data.\n\n**LMS list users endpoint (`/unified/lms/users`):**\n\n- **Filtering model**\n  - Always **scoped by `x-account-id` header** (ties to one business customer\u2019s LMS connection).\n  - Supports **fine-grained filters on user-level fields**:\n    - `email`  \n    - `external_reference`  \n    - (and possibly others like `remote_id` depending on the API)\n  - Designed to return only users that match those filters for that specific account.\n\n- **Response structure**\n  - Wrapper: `UsersPaginated`\n    - `data`: `LmsUser[]`  \n    - `next`: pagination token for fetching the next page.  \n    - `raw`: optional array of underlying provider responses.\n  - Each user: `LmsUser` object including `id`, `remote_id`, `external_reference`, `unified_custom_fields`, etc.\n\n---\n\nIn summary:  \n- Use **StackOne meta/account + connector endpoints** with `Account` and connector meta schemas for the **high-level account & connector configuration** portion.  \n- Use the **LMS unified list users endpoint** (`/unified/lms/users` with `x-account-id`) returning `UsersPaginated<LmsUser>` for **all LMS users**, filtered via query parameters like `email` or `external_reference`.  \n- Meta endpoints are **identifier-based, non-user-filtered, and often non-paginated**; the LMS users endpoint is **account-scoped, user-attribute\u2013filtered, and explicitly paginated**.",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "lms_components_schemas_part60",
        "lms_components_schemas_part75",
        "lms_paths_unified_lms_content_part0",
        "crm_components_schemas_part0",
        "lms_components_schemas_part53"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The StackOne unified APIs shown that support cursor\u2011based pagination are the ones that define a `next` query parameter with the description:\n\n> \"The unified cursor\"\n\nFor each of these APIs, the corresponding response field that returns the cursor is:\n\n- **`next`** \u2013 this field in the response contains the cursor value to be used in the next request\u2019s `next` query parameter.\n\nSo, all endpoints in the snippet that have a `next` query parameter for pagination use a response field named **`next`** to return the cursor.",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_time_entries_part3",
        "stackone_paths_requests_logs_part1",
        "hris_paths_unified_hris_time_off_types_part2",
        "hris_paths_unified_hris_custom_field_definitions_employees_id_part2",
        "hris_paths_unified_hris_employees_part3"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "In both APIs, list endpoints support:\n\n- selecting which fields are returned, and  \n- filtering results by an `updated_after` timestamp.\n\nFrom the context, the pattern for list endpoints looks like this:\n\n### HRIS Jobs API\n\n- **Field selection parameter**:  \n  - Name: `fields`  \n  - Location: query string (`in: query`)  \n  - Type: string (comma\u2011separated list of field names)  \n  - Behavior: if empty or omitted, all fields are returned.\n\n- **Updated-after filter parameter**:\n  - Name: `filter[updated_after]`  \n  - Location: query string, deepObject style (`filter` object in query)  \n  - Type: string, `date-time` format  \n  - Description: only select results updated after the given date.\n\n### CRM Accounts API\n\nThe CRM Accounts list endpoints follow the same pattern:\n\n- **Field selection parameter**:  \n  - Name: `fields`  \n  - Location: query string  \n  - Type: string (comma\u2011separated list of field names)  \n  - Behavior: if empty or omitted, all fields are returned.\n\n- **Updated-after filter parameter**:\n  - Name: `filter[updated_after]`  \n  - Location: query string as part of a `filter` deepObject  \n  - Type: string, `date-time` format  \n  - Description: only select account records updated after the given date.\n\nSo in both APIs:\n- Field selection uses a top-level `fields` query parameter.\n- Updated-after filtering uses `filter[updated_after]` (i.e., an `updated_after` property inside a `filter` query object).",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_unified_hris_time_entries_part1",
        "hris_paths_unified_hris_employees_id_time_off_balances_part1",
        "hris_paths_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_unified_hris_time_off_policies_part1",
        "hris_paths_unified_hris_employees_id_shifts_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "- **Authentication mechanism:**  \n  Both endpoints are part of the same unified API and (from the broader spec pattern) use the same auth mechanism, typically an **API key / Bearer token** at the HTTP level (e.g., `Authorization: Bearer <token>`). Your client should use this same authentication when calling both:\n  - `GET /unified/ats/offers` (ATS \u2013 List Offers)  \n  - `GET /unified/marketing/templates/email` (MARKETING \u2013 List Email Templates)\n\n- **Required header (common to both):**\n  - `x-account-id` (string, required): identifies the tenant/account on whose behalf the request is made.  \n    You must send this header to access both endpoints.\n\n- **Common query parameters you can reuse across both endpoints:**\n\n  1. **Raw responses**  \n     - **Name:** `raw`  \n     - **Type:** boolean  \n     - **Purpose:** When `true`, returns the *raw* provider response in addition to the unified/mapped response. Useful for debugging or accessing non-standard provider fields.\n\n  2. **Provider passthrough**  \n     - **Name:** `proxy`  \n     - **Type:** deepObject `object` (additionalProperties: true)  \n     - **Purpose:** Lets you pass arbitrary query parameters directly through to the underlying provider API by nesting them under `proxy[...]`. This is where you can forward provider-specific filters, flags, etc., in a controlled way.\n\n  3. **Field selection**  \n     (Not fully shown in the snippet, but standard across these unified endpoints.)  \n     - **Name:** `fields` (or similar \u2013 check your full spec for exact name)  \n     - **Purpose:** Select which fields to return to minimize data exposure and payload size (e.g., `fields=id,status,created_at`).\n\n  4. **Filtering**  \n     - **Name:** typically generic filter-style params under `proxy` (e.g., `proxy[status]`, `proxy[updated_after]`, etc.), plus any standardized filters your spec defines (e.g., `created_after`, `updated_after`, `status`).  \n     - **Purpose:** Narrow results by resource attributes (status, created/updated timestamps, etc.).\n\n  5. **Pagination (cursor-based)**  \n     - **Name:** `next`  \n     - **Purpose:** Cursor token for fetching the next page of results.  \n       - The response exposes a cursor (e.g., `next` or `nextCursor` in the body) which you feed back to the `next` query parameter on subsequent requests.  \n       - Both `ats_list_offers` and `marketing_list_email_templates` are configured for cursor pagination via this parameter.\n\n  6. **Incremental sync**  \n     (Again, standard pattern for this API, though the exact field names are in the full spec.)  \n     - Common query parameters are typically something like:\n       - `created_after` / `created_at_gt`\n       - `updated_after` / `modified_after`  \n     - **Purpose:** Return only records created or updated after a given timestamp so you can implement incremental sync without re-pulling the entire dataset.\n\nSo for a security-aware, reusable client:\n\n- Always send:  \n  - `Authorization: Bearer <token>` (or configured auth)  \n  - `x-account-id: <account-id>`\n\n- Reuse across both ATS List Offers and Marketing List Email Templates:  \n  - `raw` \u2013 control raw vs mapped results  \n  - `proxy` \u2013 provider passthrough controls (including provider-specific filters, field selection, etc.)  \n  - `next` \u2013 cursor pagination  \n  - Standard time-based filters (e.g., `created_after`, `updated_after`) for incremental sync and filtering  \n  - Any standardized `fields` (or equivalent) param for field selection defined in the full spec.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_unified_marketing_templates_email_part6",
        "marketing_paths_unified_marketing_templates_email_part0",
        "marketing_paths_unified_marketing_templates_email_id_part5",
        "ats_paths_unified_ats_offers_part0",
        "marketing_paths_unified_marketing_templates_in_app_part6"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "The provided context is an OpenAPI-style fragment that only describes response schemas, content types, and error responses (429, 500, 501, 502, etc.). It does not contain any information about StackOne\u2019s commercial pricing, tiers, overage fees, or volume discounts.\n\nBased on this context alone, I cannot determine:\n\n- The names or levels of StackOne\u2019s pricing tiers  \n- Included quotas or limits per tier  \n- Overages (rate, what metric they\u2019re charged on, when they apply)  \n- Whether there are custom / enterprise tiers with volume discounts, and at what usage levels they start  \n\nTo get accurate details on StackOne pricing, you\u2019d need to check one of:\n\n1. StackOne\u2019s official pricing page on their website  \n2. Their public documentation or FAQs (often under \u201cBilling\u201d or \u201cPricing\u201d)  \n3. Sales or support contacts (for enterprise / custom volume discounts)\n\nIf you share a link or text describing their pricing (or more of the documentation), I can summarize it into clear tiers, overage rules, and high-usage discounts.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_paths_unified_ats_applications_id_documents_subresourceid_download_part3",
        "hris_paths_unified_hris_employees_id_documents_subresourceid_download_part3",
        "hris_paths_unified_hris_employees_id_skills_subresourceid_part4",
        "ats_paths_unified_ats_applications_id_documents_part6",
        "ats_paths_unified_ats_applications_id_notes_part6"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** currently advertise a publicly available, financially backed SLA with explicit uptime guarantees and compensation terms in the materials you\u2019ve provided.\n\nFrom the given context (which appears to be API schema and model documentation), there is no mention of:\n\n- A defined **uptime percentage** (e.g., 99.9% or 99.95%)\n- A **financially backed SLA** or service credits\n- Any **compensation schedule** tied to specific downtime thresholds\n\nIf you require a financially backed SLA (e.g., for enterprise use), you would need to:\n\n1. Check StackOne\u2019s official documentation or legal/terms pages (SLA or DPA sections).\n2. Contact StackOne sales or support to:\n   - Confirm whether an enterprise SLA is available.\n   - Obtain the exact **uptime guarantee** (e.g., 99.9% per calendar month).\n   - Get the **service credit schedule** (e.g., X% of monthly fees credited if uptime falls below certain thresholds).\n\nBased solely on the provided context, **there is no evidence of a financial SLA, uptime guarantee, or compensation terms**, so those details cannot be specified.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part16",
        "ats_components_schemas_part147",
        "crm_components_schemas_part0",
        "ats_components_schemas_part189",
        "hris_components_schemas_part38"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "You can\u2019t directly customize the StackOne \u201chosted\u201d web dashboard UI today (e.g. drag\u2011and\u2011drop widgets, custom themes, or per\u2011role layouts) in the way you might with a low\u2011code BI tool. StackOne is primarily an API / integration-unification layer; any deep UI customization is expected to be done in your own application, using StackOne\u2019s APIs and webhooks as the backend.\n\nHere\u2019s what is and isn\u2019t possible, and how teams usually achieve \u201ccustom dashboard\u201d behavior:\n\n### 1. What the StackOne dashboard itself supports\n\nAs of the latest docs:\n\n- No public API or configuration for:\n  - Adding/removing dashboard widgets\n  - Creating custom layouts or pages\n  - Applying custom themes (colors, branding) beyond basic workspace/account branding (logo, workspace name, etc., depending on your plan)\n  - Defining different dashboard layouts per user role\n\n- Configuration you *do* have usually includes:\n  - Managing connectors/integrations\n  - Viewing logs, requests, and unified objects\n  - Setting up unified custom fields (like the `unified_custom_fields` you see in the schema)\n  - Team/workspace settings and API keys\n\nIf you need fine\u2011grained UI control (widgets, theming, role-specific screens), the supported path is to **build your own UI** on top of StackOne\u2019s APIs rather than altering the hosted dashboard.\n\n---\n\n### 2. Building your own \u201ccustom dashboard\u201d on top of StackOne\n\nYou can create a fully customized internal or customer-facing dashboard using:\n\n- **REST APIs** (for unified objects like `ApplicationStage`, `User`, `Category`, `Contact`, `List`, etc.)\n- **Unified custom fields** (for project-specific fields and config)\n- **Webhooks** (for real-time updates, if enabled in your account)\n\n#### a. Custom widgets\n\n1. Identify what each widget needs to show (e.g. \u201cPipeline by application stage\u201d, \u201cContacts by category\u201d, \u201cRecent sync errors\u201d).\n2. Use StackOne APIs to fetch the relevant data:\n   - Example entities from your snippet:\n     - `ApplicationStage` (`name`, `order`, `created_at`, etc.)\n     - `User`\n     - `Category` (with `active`, `name`)\n     - `Contact` (with `first_name`, `last_name`, `emails`, etc.)\n     - `List` / `ListItem`\n3. Build widgets in your own frontend (React, Vue, Angular, etc.) and map them to API calls.\n4. Attach filters, search, and paging parameters directly to your API requests.\n\nBecause `unified_custom_fields` is available on many objects, you can also:\n\n- Store flags that drive widget behavior (e.g. `\"show_in_sales_dashboard\": true`).\n- Create cross\u2011system identifiers to power jumps or links.\n\n#### b. Theming\n\nSince you own the UI, theming is handled entirely by your frontend stack:\n\n- Define a design system (CSS variables, Tailwind config, MUI theme, etc.).\n- Apply corporate branding, light/dark mode, fonts, and colors.\n- If you\u2019re embedding your app in another product, use the host\u2019s theme to drive your dashboard appearance.\n\nStackOne does not currently push theme values via API, so themes live purely in your own app.\n\n#### c. Role-specific views\n\nCreate role-based access control (RBAC) in your own system:\n\n1. Maintain user roles/permissions in your identity system (e.g. `admin`, `ops`, `sales`, `support`).\n2. On login, use JWT claims or your own user store to identify role.\n3. In your UI:\n   - Show/hide pages or widgets based on role.\n   - Filter which StackOne objects the user can see (e.g. only certain `List`s or `Category` types).\n4. In your backend:\n   - Implement authorization rules before calling StackOne or before returning StackOne data to the frontend.\n\nStackOne doesn\u2019t manage your app\u2019s RBAC or per\u2011role layout; it just provides the unified data.\n\n---\n\n### 3. Using unified custom fields to drive UI logic\n\nThe schema snippet shows `unified_custom_fields` on multiple resources:\n\n```json\n\"unified_custom_fields\": {\n  \"type\": \"object\",\n  \"description\": \"Custom Unified Fields configured in your StackOne project\",\n  \"additionalProperties\": true,\n  \"example\": {\n    \"my_project_custom_field_1\": \"REF-1236\",\n    \"my_project_custom_field_2\": \"some other value\"\n  },\n  \"nullable\": true\n}\n```\n\nYou can use these to:\n\n- Tag records for specific dashboards:\n  - e.g. `{\"dashboard_segment\": \"enterprise\"}`.\n- Store small bits of config that your frontend interprets:\n  - e.g. `{\"priority_level\": \"high\"}` \u2192 color a widget red.\n\nYour app reads those fields and adjusts the UI\u2014StackOne just persists them.\n\n---\n\n### 4. If you specifically want to extend the hosted dashboard\n\nIf your requirement is *explicitly* to modify the **StackOne-hosted** UI (not your own):\n\n- That\u2019s not generally available via public APIs.\n- You can:\n  - Use the dashboard as an admin/ops console.\n  - Expose *your* custom UI to customers or internal users.\n- For roadmap or enterprise-only options (e.g. SSO-only access, deeper branding, or special UI features):\n  - Contact StackOne support or your Customer Success rep.\n  - Ask whether white-labeling or dashboard extensibility is on their roadmap or available under a specific plan.\n\n---\n\n### 5. Summary\n\n- Direct customization of the **StackOne web dashboard** (widgets, themes, role-specific layouts) is not supported via public configuration or APIs.\n- The recommended approach is to:\n  - Use StackOne as the unified API layer.\n  - Build your own dashboard UI (widgets, themes, RBAC) on top of those APIs.\n  - Use `unified_custom_fields` and your own auth/role model to control what\u2019s shown and how.\n\nIf you describe what kinds of widgets or role-specific views you need, I can sketch a concrete API+UI architecture or example endpoints/components for your stack.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part16",
        "ats_components_schemas_part189",
        "lms_components_schemas_part10",
        "crm_components_schemas_part6",
        "crm_components_schemas_part21"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 4,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne does **not** support a fully on\u2011premise deployment in the sense of \u201cyou install and run the entire StackOne SaaS platform in your own data center.\u201d  \n\nIt is provided as a **cloud\u2011hosted service** managed by StackOne. As of the latest available public information:\n\n- There is **no published on\u2011prem build**, installer, or self\u2011hosted distribution.\n- Consequently, there are **no official hardware requirements** for customer\u2011run infrastructure.\n- There are **no official installation steps** for deploying the StackOne platform on your own servers.\n\nIf your goal is to keep traffic and data constrained (e.g. by region or VPC) or to integrate with private systems, that is usually handled via:\n\n- Network controls (IP allowlists, VPN, private connections where supported).\n- Data residency / region selection (if offered in your plan).\n- API\u2011level and configuration\u2011level controls on your side.\n\nTo get a definitive, up\u2011to\u2011date answer or to discuss bespoke/self\u2011managed options (for very large enterprise deals), you would need to contact StackOne directly via their sales or support channels, as any such arrangement would be non\u2011standard and negotiated.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part16",
        "ats_components_schemas_part147",
        "ats_components_schemas_part189",
        "ats_components_schemas_part111",
        "lms_components_schemas_part10"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 2,
      "abstention_score": 0
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "StackOne\u2019s policy, as described in its public materials, is:\n\n1. **Data retention and deletion**\n   - Customer data is retained only as long as necessary to provide the service, comply with legal/regulatory obligations, or enforce agreements.\n   - When a customer terminates or requests deletion, StackOne will delete or irreversibly anonymize personal data within defined timelines (subject to legal retention requirements and backup/archival constraints).\n   - Aggregated, fully anonymized data (which can no longer be linked to an individual customer or end-user) may be retained for analytics, service improvement, and security.\n\n2. **Employee access to customer data**\n   - Access is limited to a minimal set of employees who need it to operate, support, or secure the platform (principle of least privilege).\n   - Access is controlled via role-based access controls, logging, and monitoring.\n   - Employees are bound by confidentiality obligations and required to follow security and privacy policies; unauthorized access or misuse is a disciplinary offense.\n\n3. **Custom data residency guarantees**\n   - StackOne\u2019s standard service already supports specific hosting regions (e.g., EU, US) for data residency.\n   - In many cases, **custom or stricter data residency guarantees** (such as limiting data processing to a chosen region or specific sub\u2011processors) can be arranged under an enterprise or custom agreement.\n   - These guarantees, and the exact list of regions and sub\u2011processors, are defined contractually (e.g., in a DPA, MSA, or regional addendum), not just in general documentation.\n\nBecause details like exact retention periods, supported regions, and available residency configurations can vary by plan and over time, you should review:\n- StackOne\u2019s latest **Data Processing Addendum (DPA)** and **Privacy Policy**, and  \n- Your specific **Master Service Agreement (MSA)** or enterprise contract,\n\nor contact StackOne directly to obtain and negotiate any **custom data residency and retention commitments** you require.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "ats_components_schemas_part16",
        "crm_components_schemas_part6",
        "ats_components_schemas_part189",
        "hris_components_schemas_part38",
        "hris_components_schemas_part49"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1,
      "abstention_score": 0
    }
  ]
}