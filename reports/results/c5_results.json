{
  "config": "c5",
  "timestamp": "2025-12-10T21:41:19.452700",
  "summary": {
    "total_questions": 84,
    "retrieval": {
      "hit_rate_at_k": 0.9873417721518988,
      "mrr": 0.9206751054852321,
      "k": 5
    },
    "answer_quality": {
      "accuracy_score": 3.5357142857142856,
      "abstention_accuracy": 1.0
    }
  },
  "results_by_category": {
    "cross_api": {
      "count": 9,
      "avg_accuracy": 2.2222222222222223,
      "retrieval_hit_rate": 0.8888888888888888
    },
    "auth": {
      "count": 7,
      "avg_accuracy": 4.714285714285714,
      "retrieval_hit_rate": 1.0
    },
    "endpoint": {
      "count": 21,
      "avg_accuracy": 4.095238095238095,
      "retrieval_hit_rate": 1.0
    },
    "factual": {
      "count": 21,
      "avg_accuracy": 2.9047619047619047,
      "retrieval_hit_rate": 1.0
    },
    "schema": {
      "count": 21,
      "avg_accuracy": 3.4285714285714284,
      "retrieval_hit_rate": 1.0
    },
    "out_of_scope": {
      "count": 5,
      "avg_accuracy": 5.0,
      "retrieval_hit_rate": 0.0
    }
  },
  "detailed_results": [
    {
      "question_id": "factual_stackone_s0_001",
      "question": "When creating a connect session via POST /connect_sessions, what is the default value of the expires_in field in the ConnectSessionCreate request body, and in what unit is this duration expressed?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that `expires_in` is \u201cHow long the session should be valid for in seconds,\u201d but it does not specify any default value if this field is omitted.",
      "ground_truth_answer": "In the ConnectSessionCreate schema used by POST /connect_sessions, the expires_in field defaults to 1800 and this duration is expressed in seconds.",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_paths_post_connect_sessions_part2",
        "stackone_components_connectsession"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_stackone_s1_001",
      "question": "When listing platform logs via GET /requests/platform-logs, which filter properties can be used to control the sort order of results, and what are the allowed values for each of these properties?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only specifies the query parameters `order_by` and `order_direction` (plus paging and `filter` as a generic object), but it does not list which specific fields are valid for `order_by`, nor the allowed values for `order_direction` or any sort-related properties inside `filter`.",
      "ground_truth_answer": "For GET /requests/platform-logs, the filter object in the query supports two properties that control sort order:\n\n1. filter.order_by\n   - Description: \"The field to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"provider\", \"service\", \"status\", \"eventDatetime\", \"duration\", or null.\n\n2. filter.order_direction\n   - Description: \"The direction to order the results by.\"\n   - Type: string, nullable\n   - Allowed enum values: \"asc\", \"desc\", or null.",
      "relevant_structural_ids": [
        "stackone.paths./requests/platform-logs.get"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_platform_logs",
        "stackone_components_platformlog",
        "stackone_components_unifiedlogs",
        "stackone_components_unifiedlogspartial",
        "stackone_components_unifiedlogresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_stackone_s2_001",
      "question": "When calling the StackOne MCP POST endpoint at `/mcp`, which HTTP header must be used to pass the target provider account identifier, and what is the alternative way to provide the same value if the header is omitted?",
      "category": "factual",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The target provider account identifier should be passed in the `x-account-id` HTTP header.  \n\nIf you omit this header, you can provide the same value as an `x-account-id` query parameter in the request URL.",
      "ground_truth_answer": "For the MCP POST endpoint (`POST /mcp`), the target provider account identifier is passed using the `x-account-id` HTTP header. As an alternative, the same `x-account-id` value can be provided as a query parameter named `x-account-id` if the header is omitted.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_post_connect_sessions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_stackone_s0_001",
      "question": "Which STACKONE endpoint should I call to retrieve a paginated list of unified request logs, and what query parameters can I use to filter by HTTP method and provider while also including step logs in the response?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should call the `GET /requests/logs` endpoint (operation ID: `stackone_list_logs`) to retrieve a paginated list of unified request logs.\n\nFrom the provided context, the available query parameters are:\n\n- `order_by` (string, optional): Field to order results by  \n- `order_direction` (string, optional): Direction to order results by  \n- `page_size` (number, optional): Number of results per page (default 25)  \n- `next` (string, optional): Unified cursor for pagination  \n- `include` (string, optional): Allows including additional data in the response  \n- `filter` (object, optional): Filter parameters for customizing the list response  \n\nHowever, the documentation excerpt does **not** specify:\n\n- Which exact fields can be used inside `filter` (e.g., whether you can filter specifically by `http_method` and `provider`), or  \n- The exact value(s) to pass to `include` to ensure step logs (matching the `StepLog` schema) are included.\n\nBecause those details are not present in the context, I don't have enough information to describe how to structure `filter` for HTTP method and provider, or how to set `include` to get step logs.\n\nI don't have enough information in the StackOne documentation to answer this question. The context only tells us that `GET /requests/logs` supports a generic `filter` object and an `include` parameter, but does not document what filter keys are allowed or what `include` values will return step logs.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint.\n\n**Endpoint**\n- `GET https://api.stackone.com/requests/logs`\n\n**Filtering by HTTP method and provider**\nYou use the `filter` query parameter (a deep object) to filter by HTTP methods and providers:\n- `filter[http_methods]`: comma-separated list of HTTP methods, e.g. `GET,POST`\n- `filter[providers]`: comma-separated list of provider keys, e.g. `ashby,greenhouse`\n\n**Including step logs**\nTo include step logs in the response, use the `include` query parameter:\n- `include=step_logs`\n\n**Other pagination-related query parameters**\n- `page_size` (number, optional, max 100): number of results per page (default 25)\n- `next` (string, optional): unified cursor for fetching the next page",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogsPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_components_unifiedlogs",
        "stackone_components_unifiedlogspartial",
        "stackone_components_unifiedlogspaginated",
        "stackone_components_steplog"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s1_001",
      "question": "Which StackOne endpoint should I call to retrieve a paginated list of request logs, and what query parameters are available to filter those logs by account IDs, HTTP methods, providers, and success status?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "Call the following endpoint:\n\n- **Endpoint:** `GET /requests/logs`  \n- **Operation ID:** `stackone_list_logs`  \n- **Returns:** A **paginated** list of logs using the `UnifiedLogsPaginated` schema (`next` cursor + `data` array).\n\n**Available query parameters** (as documented):\n\n- `order_by` (string, optional): Field to order results by  \n- `order_direction` (string, optional): Direction to order results  \n- `page_size` (number, optional): Results per page (default 25)  \n- `next` (string, optional): Unified cursor for pagination  \n- `include` (string, optional): Include additional data in the response  \n- `filter` (object, optional): \u201cFilter parameters that allow greater customisation of the list response\u201d\n\nThe documentation states only that `filter` is an object for customisation; it does **not** specify its internal fields or how to filter specifically by **account IDs, HTTP methods, providers, or success status**.  \n\nTherefore:\n\n> I don't have enough information in the StackOne documentation to answer this question. The context only indicates there is a generic `filter` object parameter for `GET /requests/logs`, but it does not document which fields (such as account IDs, HTTP methods, providers, or success) can be used inside that filter.",
      "ground_truth_answer": "Use the GET /requests/logs endpoint to retrieve a paginated list of request logs.\n\nEndpoint:\n- GET https://api.stackone.com/requests/logs\n\nKey query parameters for pagination and filtering include:\n- page_size (number, optional): The number of results per page (max 100).\n- next (string, optional): The unified cursor for pagination.\n- include (string, optional): Can be set to \"step_logs\" to include step logs in the response.\n\nFilter object (filter is a query parameter whose value is an object) supports:\n- filter[account_ids] (string, optional): Comma-separated list of account IDs.\n- filter[http_methods] (string, optional): Comma-separated list of HTTP methods (e.g., \"GET,POST\").\n- filter[providers] (string, optional): Comma-separated list of provider keys (e.g., \"ashby,greenhouse\").\n- filter[services] (string, optional): Comma-separated list of services (e.g., \"hris,ats\").\n- filter[resources] (string, optional): Comma-separated list of resources (e.g., \"employees,users\").\n- filter[child_resources] (string, optional): Comma-separated list of child resources.\n- filter[sub_resources] (string, optional): Comma-separated list of sub resources.\n- filter[actions] (string, optional): Comma-separated list of actions (e.g., \"download,upload\").\n- filter[status_codes] (string, optional): Comma-separated list of status codes (e.g., \"200,400\").\n- filter[success] (boolean, optional): Filter by success or failure.\n- filter[request_ids] (string, optional): Comma-separated list of request IDs.\n- filter[start_date] (string, date-time, optional): ISO8601 start date.\n- filter[end_date] (string, date-time, optional): ISO8601 end date.\n- filter[source_types] (string, optional): Comma-separated list of source types.\n- filter[source_values] (string, optional): Comma-separated list of source values.\n- filter[source_ids] (string, optional): Comma-separated list of source IDs.\n- filter[order_by] (string, optional): One of \"provider\",\"service\",\"status\",\"eventDatetime\",\"duration\", or null.\n- filter[order_direction] (string, optional): \"asc\",\"desc\", or null.\n\nThe response schema for this endpoint is UnifiedLogsPaginated (not fully shown here), which contains a paginated list of UnifiedLogs objects.",
      "relevant_structural_ids": [
        "stackone.paths./requests/logs.get",
        "stackone.components.UnifiedLogs"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_requests_logs",
        "stackone_components_unifiedlogs",
        "stackone_components_unifiedlogspaginated",
        "stackone_components_unifiedlogspartial",
        "stackone_components_steplog"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_stackone_s2_001",
      "question": "Which StackOne endpoint should I use to list all actions metadata, and what query parameters are available to filter and paginate the results?",
      "category": "endpoint",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "You should use the **`GET /actions`** endpoint (Operation ID: `stackone_list_actions_meta`) to list all actions metadata.\n\nThe following **query parameters** are available to filter and paginate the results:\n\n- `page_size` (string, optional): Number of results per page (default is 25).\n- `next` (string, optional): Unified cursor for fetching the next page (pagination).\n- `group_by` (string, optional): The relation to group the results by.\n- `filter` (object, optional): Actions Metadata filters.\n- `include` (array, optional): Additional data to include in the response.",
      "ground_truth_answer": "Use the **GET /actions** endpoint.\n\n**Endpoint**:\n- `GET https://api.stackone.com/actions`\n\n**Purpose**:\n- Retrieves a list of all actions metadata.\n\n**Available query parameters**:\n- `page_size` (query, string, optional): The number of results per page (default is 25).\n- `next` (query, string, optional): The unified cursor for cursor-based pagination.\n- `group_by` (query, string, optional, default `connector`): The relation to group the results by.\n- `filter` (query, deepObject, optional): \"Actions Metadata filters\" object with the following optional fields:\n  - `connectors` (string): Comma-separated list of connectors to filter by, e.g. `connector1,connector2`.\n  - `account_ids` (string): Comma-separated list of account IDs to filter by, e.g. `account1,account2`.\n  - `action_key` (string): Action key to filter by, e.g. `action1`.\n- `include` (query, array[string], optional): Additional data to include; allowed value is `action_details` (e.g. `include[]=action_details`).\n\n**Security**:\n- Uses HTTP basic auth (`basic`).\n\n**Response**:\n- On success, returns status `200` with body of type `ActionsMetaPaginated`.",
      "relevant_structural_ids": [
        "stackone.paths./actions.get",
        "stackone.components.ActionsMetaPaginated",
        "stackone.components.ActionsMeta",
        "stackone.components.ActionMetaItem"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_components_actionsmetapaginated",
        "stackone_components_actionsmeta",
        "stackone_components_actionmetaitem",
        "stackone_paths_get_requests_logs"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_stackone_s0_001",
      "question": "For the Stackone Proxy Request endpoint, what is the type, description, allowed values, and default value of the `method` field in the `ProxyRequestBody` schema, and is this field nullable?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that `method` in the `ProxyRequestBody` schema is of type `string` and is \"The method of the request.\" It does not specify allowed values (e.g., GET/POST/etc.), a default value, or whether the field is nullable.",
      "ground_truth_answer": "In the Proxy Request endpoint (`POST /unified/proxy`), the request body uses the `ProxyRequestBody` schema. In that schema, the `method` field has these characteristics:\n\n- **Type:** `string`\n- **Description:** `\"The method of the request\"`\n- **Allowed values (enum):** `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, `\"patch\"`, and `null`\n- **Default value:** `\"get\"`\n- **Nullable:** Yes, the field is nullable (`\"nullable\": true`).\n- It also has `\"x-speakeasy-unknown-values\": \"allow\"` set on it.\n\nSo the field is a nullable string, defaults to `\"get\"`, and is constrained to the HTTP verb values `get/post/put/delete/patch` (plus null) as its enum options.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyresponseapimodel",
        "stackone_components_advancedlogrequestdata",
        "stackone_components_jsonrpcmessagedto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_stackone_s1_001",
      "question": "For the StackOne Proxy Request endpoint, what are the allowed values for the `method` field in the `ProxyRequestBody` schema, and which of these is the default if `method` is omitted?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that `method` is \u201cThe method of the request\u201d and does not list allowed values (e.g., GET, POST, etc.) or specify any default behavior if `method` is omitted.",
      "ground_truth_answer": "In the `ProxyRequestBody` schema used by the Proxy Request endpoint, the `method` field is a string with the following allowed values: `\"get\"`, `\"post\"`, `\"put\"`, `\"delete\"`, and `\"patch\"` (it may also be `null`). If the `method` field is omitted, its default value is `\"get\"`.",
      "relevant_structural_ids": [
        "stackone.paths./unified/proxy.post",
        "stackone.components.ProxyRequestBody"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_advancedlogrequestdata",
        "stackone_components_jsonrpcmessagedto",
        "stackone_components_proxyresponseapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "schema_stackone_s2_001",
      "question": "In the StackOne API, when creating a connect session via POST /connect_sessions, which fields in the ConnectSessionCreate request body are required, and what are the allowed values for its type property?",
      "category": "schema",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "The required fields in the `ConnectSessionCreate` request body are:\n\n- `origin_owner_id` (string) \u2013 required  \n- `origin_owner_name` (string) \u2013 required  \n\nAll other listed properties are optional.\n\nRegarding the `type` property:  \nThe documentation only states:\n\n- `type` (string): *\u201cThe connect session account type\u201d*\n\nIt does not specify any allowed or enumerated values for `type`.\n\nTherefore:\n\n> I don't have enough information in the StackOne documentation to answer this question about the allowed values for the `type` property. The context only describes it as \u201cThe connect session account type\u201d without listing valid options.",
      "ground_truth_answer": "For POST /connect_sessions, the request body must conform to the ConnectSessionCreate schema. Within ConnectSessionCreate, the required fields are origin_owner_id and origin_owner_name. These two properties must always be provided.\n\nThe type property on ConnectSessionCreate is optional (nullable) and represents the connect session account type. Its allowed enum values are:\n- \"production\"\n- \"test\"\n- null\n\nIt also has a default value of \"production\" and is marked with x-speakeasy-unknown-values=\"allow\".",
      "relevant_structural_ids": [
        "stackone.paths./connect_sessions.post",
        "stackone.components.ConnectSessionCreate"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_paths_post_connect_sessions_part1",
        "stackone_components_connectsession",
        "stackone_paths_post_connect_sessions_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "auth_stackone_001",
      "question": "For the MCP endpoints under `/mcp`, what authentication schemes are supported, and which headers related to authentication and account context can or must be included when sending a JSON-RPC message or opening/closing an MCP session?",
      "category": "auth",
      "relevant_apis": [
        "stackone"
      ],
      "generated_answer": "For the MCP endpoints under `/mcp` (`POST /mcp`, `GET /mcp`, `DELETE /mcp`), the documentation states:\n\n**Supported authentication scheme**\n- **HTTP Basic** authentication is supported (and required) for all three MCP endpoints.\n\n**Headers related to authentication and account context**\n\n1. **Account context (`x-account-id`)**\n   - Can be provided either as:\n     - `x-account-id` **header** (optional), or  \n     - `x-account-id` **query parameter** (optional, alternative to the header).\n   - This applies to:\n     - `POST /mcp`\n     - `GET /mcp`\n     - `DELETE /mcp`\n\n2. **Session identification (`mcp-session-id`)**\n   - `POST /mcp`:\n     - `mcp-session-id` (header, optional)\n       - Omit for initialize.\n       - Include for subsequent calls.\n   - `GET /mcp`:\n     - `mcp-session-id` (header, **required**) \u2013 identifies the MCP session whose SSE stream is being opened.\n   - `DELETE /mcp`:\n     - `mcp-session-id` (header, **required**) \u2013 identifies the MCP session to close.\n\n3. **Content negotiation for SSE**\n   - `GET /mcp`:\n     - `Accept` (header, **required**, string): must be `text/event-stream`.\n\nNo other authentication schemes (e.g., Bearer tokens, API keys) are mentioned in the provided context.",
      "ground_truth_answer": "The MCP endpoints (`/mcp` for POST, GET, and DELETE) support two authentication schemes: HTTP Basic auth and an API key scheme named `ApiKey`.\n\nFor all three MCP operations (send JSON-RPC, open SSE stream, delete session), the following apply:\n- Security: each operation lists `security: [ { \"basic\": [] }, { \"ApiKey\": [] } ]`, meaning the client must authenticate using either HTTP Basic authentication or the ApiKey scheme.\n\nAccount- and session-related headers/parameters:\n- `x-account-id`:\n  - Optional header: `name: \"x-account-id\"`, `in: header`, description: \"Account secure id for the target provider account (optional if x-account-id query parameter is provided)\".\n  - Optional query parameter alternative: another `x-account-id` parameter with `in: query`, description: \"Account secure id (alternative to x-account-id header)\".\n  - This pattern (optional header or query param) appears on POST /mcp, GET /mcp, and DELETE /mcp.\n- `mcp-session-id`:\n  - For POST /mcp (send JSON-RPC message): optional header `mcp-session-id`, description: \"Session id; omit for initialize, include for subsequent calls\".\n  - For GET /mcp (open SSE stream): required header `mcp-session-id`, description: \"Session id\".\n  - For DELETE /mcp (close session): required header `mcp-session-id`, description: \"Session id\".\n- `Accept` header (GET /mcp only): a required header `Accept` with description \"Must be text/event-stream\" when opening the SSE stream.\n\nIn summary, clients must authenticate with either Basic or ApiKey on all MCP endpoints, can identify the target account using `x-account-id` either as a header or query parameter, and must use `mcp-session-id` (plus `Accept: text/event-stream` for the GET) to manage and use specific MCP sessions.",
      "relevant_structural_ids": [
        "stackone.paths./mcp.post",
        "stackone.paths./mcp.get",
        "stackone.paths./mcp.delete"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_delete_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_paths_post_connect_sessions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "factual_hris_s0_001",
      "question": "When listing HRIS time off policies using GET /unified/hris/time_off_policies, which filter field allows you to restrict results to a specific policy type such as \"vacation\" or \"sick\", and what enum schema defines its allowed values?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context shows that the `GET /unified/hris/time_off_policies` endpoint supports a generic `filter` object and defines a `TimeOffPolicyTypeEnum` schema for policy types, but it does not specify the exact filter field name (e.g., `filter[type]` or similar) used to restrict results by policy type such as \"vacation\" or \"sick\".",
      "ground_truth_answer": "In the GET /unified/hris/time_off_policies endpoint, the filter field \"type\" lets you restrict results to a specific policy type (e.g., \"vacation\", \"sick\"). Its allowed values are defined by the TimeOffPolicyTypeEnum schema, referenced in the TimeOffPolicies.type property.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.components.TimeOffPolicies",
        "hris.components.TimeOffPolicyTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_components_timeoffpolicytypeenum",
        "hris_components_timeoffpolicies",
        "hris_paths_get_unified_hris_time_off_policies_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_hris_s1_001",
      "question": "When listing employee time off policies using GET /unified/hris/employees/{id}/time_off_policies, which query parameter can you use to filter policies by their type, and name three valid values for that type filter?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context mentions a generic `filter` query parameter for HRIS Time-Off Policies but does not specify any filter keys (such as a type filter) or list valid values for such a filter.",
      "ground_truth_answer": "The type-based filter is provided via the `filter[type]` query parameter. Three valid values for this `type` filter (from the enum) include, for example, `sick`, `vacation`, and `holiday` (other allowed values include `long_term_disability`, `short_term_disability`, `annual_leave`, `paid`, `unpaid`, `bereavement`, `other`, etc.).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_time_off_policies_part1",
        "hris_paths_get_unified_hris_time_off_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_hris_s2_001",
      "question": "When updating an employee task via PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, what is the default status value applied if the `status` field is omitted in the `UpdateTaskRequestDto` payload?",
      "category": "factual",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context describes the `status` field as \"The status to apply to this Task\" but does not state what happens if it is omitted in the `UpdateTaskRequestDto` payload or what default value, if any, is applied.",
      "ground_truth_answer": "For PATCH /unified/hris/employees/{id}/tasks/{subResourceId}, the request body uses the UpdateTaskRequestDto schema, where the `status` property has a default value of `\"completed\"`. If `status` is omitted, it defaults to `completed`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/tasks/{subResourceId}.patch",
        "hris.components.UpdateTaskRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_taskstatusenum",
        "hris_paths_patch_unified_hris_employees_id_tasks_subresourceid",
        "hris_components_updatetaskrequestdto",
        "hris_components_task_part0",
        "hris_components_tasktypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_hris_s0_001",
      "question": "Which endpoint should I use to list all time off policies assigned to a specific employee, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "Use the **\u201cList Assigned Time Off Policies\u201d** endpoint:\n\n**Endpoint:**\n- `GET /unified/hris/employees/{id}/time_off_policies`  \n  (Operation ID: `hris_list_employee_time_off_policies`)\n\n**Required parameters:**\n1. **Path parameter**\n   - `id` (string): the identifier of the employee.\n\n2. **Header**\n   - `x-account-id` (string): the account identifier.",
      "ground_truth_answer": "To list all time off policies assigned to a specific employee, use the GET endpoint:\n\n- `GET /unified/hris/employees/{id}/time_off_policies`\n\nRequired parameters:\n1. Path parameter:\n   - `id` (string, required): the employee identifier.\n2. Header parameter:\n   - `x-account-id` (string, required): the account identifier.\n\nAll other query parameters on this endpoint are optional, including `raw`, `proxy`, `fields`, `filter`, `page`, `page_size`, `next`, and `updated_after`. This endpoint returns a `TimeOffPoliciesPaginated` response and supports cursor-based pagination via the `next` query parameter.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off_policies.get",
        "hris.components.TimeOffPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_policies_part2",
        "hris_paths_get_unified_hris_time_off_policies_part0",
        "hris_paths_get_unified_hris_time_off_policies_id_part1",
        "hris_paths_post_unified_hris_employees_id_time_off_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_hris_s1_001",
      "question": "Which endpoint should I use to list all employee time off requests, and what query parameter lets me filter the results by a specific time off policy ID?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context shows two relevant endpoints:\n\n- `GET /unified/hris/employees/{id}/time_off` (Operation ID: `hris_list_employee_time_off_requests`)  \n- `GET /unified/hris/time_off` (Operation ID: `hris_list_time_off_requests`)\n\nHowever, the snippet only says both accept a `filter` query parameter of type \u201cHRIS Time Off filters\u201d and does not detail the specific filter fields (such as a field for time off policy ID). So I can\u2019t state which exact filter key to use to filter by a specific time off policy ID.",
      "ground_truth_answer": "Use the **GET /unified/hris/time_off** endpoint (operationId `hris_list_time_off_requests`) to list all employee time off requests. To filter results by a specific time off policy ID, use the `filter[policy_ids]` query parameter, which accepts an array of policy ID strings.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_time_off_part1",
        "hris_paths_get_unified_hris_time_off_part0",
        "hris_components_timeoff_part1",
        "hris_components_timeoffresult_part1",
        "hris_paths_post_unified_hris_employees_id_time_off_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_hris_s2_001",
      "question": "Which endpoint should I use to create a new time off request for a specific employee, and which HTTP method and required parameters (including the header) are needed?",
      "category": "endpoint",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "You should use the **\u201cCreate Employee Time Off Request\u201d** endpoint:\n\n- **Endpoint (path):** `/time_off` (as given in the context; it is the create time\u2011off endpoint)\n- **Operation ID:** `hris_create_employee_time_off_request`\n- **HTTP method:** Not explicitly stated in the context, so I don't have enough information to confirm it (typically this would be POST, but that is not specified here).\n\n**Required parameters:**\n- **Header:**\n  - `x-account-id` (string, required): The account identifier\n- **Path:**\n  - `id` (string, required): Employee identifier (listed as required path parameter, though no further description is provided)\n- **Request body (JSON, required):**\n  - `approver_id` (string): The approver ID  \n  - `status` (unknown): The status of the time off request  \n  - `type` (unknown): The type of the time off request  \n  - `start_date` (string): Start date (ISO8601 date-time without timezone)  \n  - `end_date` (string): Inclusive end date (ISO8601 date-time without timezone)  \n  - `start_half_day` (unknown): True if the time off starts halfway through the day  \n  - `end_half_day` (unknown): True if the time off ends halfway through the day  \n  - `time_off_policy_id` (string): Associated time off policy ID  \n\nI don't have enough information in the StackOne documentation snippet to state the exact HTTP method or the full URL structure (e.g., whether it is `/employees/{id}/time_off` or similar); only the operation ID, the path fragment `}/time_off`, and the required parameters are shown.",
      "ground_truth_answer": "To create a new time off request for a specific employee, use the `POST /unified/hris/employees/{id}/time_off` endpoint.\n\nDetails:\n- HTTP method: `POST`\n- Path: `/unified/hris/employees/{id}/time_off`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`): the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`): the employee identifier\n- Required request body:\n  - JSON body with schema `HrisCreateTimeOffRequestDto` (`application/json`)\n\nOn success, the API returns a `201` response with a body of type `CreateResult`.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.post",
        "hris.components.HrisCreateTimeOffRequestDto",
        "hris.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_post_unified_hris_employees_id_time_off_part1",
        "hris_components_hriscreatetimeoffrequestdto_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part1",
        "hris_components_timeoffresult_part1",
        "hris_components_timeoff_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_hris_s0_001",
      "question": "In the HRIS API, what fields and nested structures can appear in a single `Employment` object within an employee\u2019s `employments` array, and which of those are marked as deprecated or use enum wrapper schemas (e.g., `EmploymentTypeEnum`, `EmploymentScheduleTypeEnum`)? Provide the full list of top-level properties of `Employment` and identify any properties that reference other schemas or are explicitly noted as deprecated.",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only shows a partial definition of the `Employment` schema (with some duplicated and truncated lines) and does not list all of its top-level properties, does not clearly mark any properties as deprecated, and does not explicitly state which fields (beyond `employment_type` and `employment_contract_type`) use enum wrapper schemas like `EmploymentTypeEnum` or `EmploymentScheduleTypeEnum`.",
      "ground_truth_answer": "The `Employment` schema is an object that represents a single employment record. Its top-level properties (all nullable unless otherwise noted) are:\n\n- `id` (string): Unique identifier, example `\"8187e5da-dc77-475e-9949-af0f1fa4e4e3\"`.\n- `remote_id` (string): Provider's unique identifier.\n- `unified_custom_fields` (object, additionalProperties: true): Custom Unified Fields configured for the StackOne project.\n- `job_title` (string): The job title of the employee.\n- `pay_rate` (string): The amount of compensation for the employee.\n- `pay_period` (enum wrapper): Uses `PayPeriodEnum` via `allOf`; describes the time period over which the pay rate is calculated (e.g., `\"monthly\"`).\n- `pay_frequency` (enum wrapper): Uses `PayFrequencyEnum` via `allOf`; describes how often the employee is paid (e.g., `\"hourly\"`).\n- `pay_currency` (string): The currency used for pay (e.g., `\"USD\"`).\n- `effective_date` (string, format date-time): The effective date of the employment contract.\n- `end_date` (string, format date-time): The end date of employment.\n- `grade` (object wrapper): Uses `EmploymentGradeApiModel` via `allOf`; represents the employee\u2019s position within the organizational hierarchy.\n- `employment_type` (enum wrapper, DEPRECATED): Uses `EmploymentTypeEnum` via `allOf`; description: the type of employment (e.g., contractor, permanent). Marked `deprecated: true`.\n- `employment_contract_type` (enum wrapper, DEPRECATED): Uses `EmploymentScheduleTypeEnum` via `allOf`; description: the employment work schedule type (e.g., full-time, part-time). Marked `deprecated: true`.\n- `type` (object wrapper): Uses `TypeApiModel` via `allOf`; description: the type of employment.\n- `contract_type` (object wrapper): Uses `ContractTypeApiModel` via `allOf`; description: the employment work schedule type.\n- `work_time` (object wrapper): Uses `WorkTimeApiModel` via `allOf`.\n- `payroll_code` (string): The payroll code of the employee (e.g., `\"PC1\"`).\n- `employee_id` (string): The employee ID associated with this employment.\n- `remote_employee_id` (string): Provider's unique identifier of the employee associated with this employment.\n- `fte` (number): The employee's working percentage relative to a full-time employee (example `\"1\"`).\n- `created_at` (string, format date-time): Created-at timestamp.\n- `updated_at` (string, format date-time): Updated-at timestamp.\n- `start_date` (string, format date-time, DEPRECATED): The start_date of employment. Marked `deprecated: true`.\n- `active` (boolean-or-string): Employment active status; `oneOf` boolean or string enum `\"true\"`/`\"false\"`.\n- `department` (object wrapper): Uses `HRISGroup` via `allOf`; the employee department.\n- `cost_center` (object wrapper, DEPRECATED): Uses `HRISGroup` via `allOf`; the employee cost_center. Marked `deprecated: true`.\n- `cost_centers` (array of objects): Array of `HRISCostCenter` entries; the employee cost_centers.\n- `division` (object wrapper): Uses `HRISGroup` via `allOf`; the employee division.\n- `job` (object wrapper): Uses `EmploymentJobApiModel` via `allOf`; the job of employee.\n- `manager` (array of objects): Array of `EmploymentManagerApiModel`; the employee managers.\n\nDeprecated properties are: `employment_type`, `employment_contract_type`, `start_date`, and `cost_center`. Properties that use enum wrapper schemas include `pay_period` (`PayPeriodEnum`), `pay_frequency` (`PayFrequencyEnum`), `employment_type` (`EmploymentTypeEnum`), and `employment_contract_type` (`EmploymentScheduleTypeEnum`). Several properties reference other schemas via `allOf`, including `grade`, `type`, `contract_type`, `work_time`, `department`, `cost_center`, `cost_centers` (items), `division`, `job`, and `manager` (items).",
      "relevant_structural_ids": [
        "hris.components.Employment",
        "hris.components.Employee"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employment_part0",
        "hris_paths_get_unified_hris_employments_id_part3",
        "hris_components_employmentresult_part0",
        "hris_components_employmenttypeenum",
        "hris_components_employmentscheduletypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_hris_s1_001",
      "question": "For the `EmployeesPaginated` response schema in the HRIS API, which fields are required and what are the types and purposes of the `next`, `next_page`, and `raw` properties?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "For the `EmployeesPaginated` response schema:\n\n- **Required fields**\n  - `data` is the only required field.\n    - Type: `array of object`\n\n- **Other properties**\n\n  - `next_page`\n    - Type: `string`\n    - Purpose: Not explicitly described in the provided context beyond being a string property on the paginated schema.\n\n  - `next`\n    - Type: `string`\n    - Purpose: Not explicitly described in the provided context beyond being a string property on the paginated schema.\n\n  - `raw`\n    - Type: `array of object`\n    - Purpose: Not explicitly described in the provided context beyond being an array of objects on the paginated schema.",
      "ground_truth_answer": "In the `EmployeesPaginated` schema, the only required field is `data`. It is an array of `Employee` objects (`type: array` with `items` referencing `#/components/schemas/Employee`).\n\nThe other pagination/metadata properties are optional and all nullable:\n- `next_page`: type `string`, deprecated, nullable. It represents the deprecated cursor or pointer to the next page of results.\n- `next`: type `string`, nullable. It is the current unified cursor value used to fetch the next page of results.\n- `raw`: type `array`, nullable. When present, it contains an array of `RawResponse` objects (`items` referencing `#/components/schemas/RawResponse`), representing raw provider responses alongside the unified `data`.",
      "relevant_structural_ids": [
        "hris.components.EmployeesPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_components_employeespaginated",
        "hris_components_hrisjobspaginated",
        "hris_components_employmentspaginated",
        "hris_components_hrisbenefitspaginated",
        "hris_components_hrisdepartmentspaginated"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "schema_hris_s2_001",
      "question": "When creating a new employee via the HRIS API, which fields in the `HrisCreateEmployeeRequestDto` payload are used to represent the employee\u2019s gender, preferred language, and ethnicity, and what enum schema types do each of these fields reference?",
      "category": "schema",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only lists basic string fields (name, emails, phone numbers, job info, etc.) for `HrisCreateEmployeeRequestDto` and does not show any fields related to gender, preferred language, or ethnicity, nor any references from this schema to `GenderEnum` or `PreferredLanguageEnum`.",
      "ground_truth_answer": "In the `HrisCreateEmployeeRequestDto` schema, the employee\u2019s gender, preferred language, and ethnicity are represented by three separate fields, each referencing a specific enum schema:\n\n- `gender`: uses `allOf` with a `$ref` to `#/components/schemas/GenderEnum` and is described as \"The employee gender\".\n- `preferred_language`: uses `allOf` with a `$ref` to `#/components/schemas/PreferredLanguageEnum` and is described as \"The employee preferred language\".\n- `ethnicity`: uses `allOf` with a `$ref` to `#/components/schemas/EthnicityEnum` and is described as \"The employee ethnicity\".\n\nAll three of these fields are nullable and appear as properties within `HrisCreateEmployeeRequestDto`. None of them are marked as required at the schema level, but they are the dedicated fields for capturing those attributes, and they each reference their respective enum schemas (`GenderEnum`, `PreferredLanguageEnum`, and `EthnicityEnum`).",
      "relevant_structural_ids": [
        "hris.components.HrisCreateEmployeeRequestDto"
      ],
      "retrieved_chunk_ids": [
        "hris_components_hriscreateemployeerequestdto_part0",
        "hris_components_genderenum",
        "hris_components_preferredlanguageenum",
        "hris_components_employee",
        "hris_components_hrisupdateemployeerequestdto_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "auth_hris_001",
      "question": "What authentication scheme and required header must be included when calling the `GET /unified/hris/employees/{id}/time_off` endpoint?",
      "category": "auth",
      "relevant_apis": [
        "hris"
      ],
      "generated_answer": "HTTP Basic authentication must be used, and the required header `x-account-id` must be included with the account identifier.",
      "ground_truth_answer": "The `GET /unified/hris/employees/{id}/time_off` endpoint uses HTTP Basic authentication and requires the `x-account-id` header.\n\nSpecifically:\n- Authentication scheme: `basic` (type `http`, scheme `basic`)\n- Required header: `x-account-id` (in `header`, described as \"The account identifier\", type `string`, required `true`).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/time_off.get",
        "hris.components.securitySchemes.basic"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_part1",
        "hris_paths_get_unified_hris_employees_id_time_off_part0",
        "hris_paths_get_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_patch_unified_hris_employees_id_time_off_subresourceid_part0",
        "hris_paths_get_unified_hris_time_off_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_ats_s0_001",
      "question": "For the GET `/unified/ats/job_postings` endpoint, which query parameter is used to filter job postings by their creation time, and what is the required format of its value?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context lists the parameters for `GET /unified/ats/job_postings` but only shows the name `updated_after` without a description or specified format, so the required value format is not documented here.",
      "ground_truth_answer": "The GET `/unified/ats/job_postings` endpoint uses the `filter[created_after]` query parameter (exposed via the `filter` deepObject with a `created_after` field) to filter job postings by their creation time. Its value must be a string in `date-time` format, for example `\"2020-01-01T00:00:00.000Z\"`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part0",
        "ats_paths_get_unified_ats_job_postings_id_part1",
        "ats_paths_get_unified_ats_job_postings_id_part0",
        "ats_paths_get_unified_ats_jobs_part0",
        "ats_paths_get_unified_ats_lists_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s1_001",
      "question": "For the ATS API endpoint that lists offers, what pagination type is specified in the `x-speakeasy-pagination` metadata, and which query parameter is used as the cursor input name?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context for the `/unified/ats/offers` endpoint does not include any `x-speakeasy-pagination` metadata, so the pagination type and cursor input name are not specified.",
      "ground_truth_answer": "For the `GET /unified/ats/offers` endpoint, the `x-speakeasy-pagination` metadata specifies a pagination type of `cursor`, and it uses the `next` query parameter as the cursor input name.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_offers_part0",
        "ats_components_offerspaginated",
        "ats_paths_get_unified_ats_interviews_part0",
        "ats_paths_get_unified_ats_candidates_part0",
        "ats_paths_get_unified_ats_job_postings_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_ats_s2_001",
      "question": "When listing ATS application changes via GET /unified/ats/applications/{id}/changes, which filter.change_type enum values are supported for the change_type filter parameter?",
      "category": "factual",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that the `filter` parameter \u201csupports \u2026 `change_type`\u201d and defines an `ApplicationChangeTypeEnum` schema with a `value` and `source_value`, but it does not list the specific allowed/enum values for `change_type`.",
      "ground_truth_answer": "The change_type filter for GET /unified/ats/applications/{id}/changes supports the following enum values: \"application_status\", \"interview_stage\", \"rejected_reasons\", and \"unmapped_value\".",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/changes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_changes_part2",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_components_applicationchangetypeenum",
        "ats_components_applicationchanges",
        "ats_paths_get_unified_ats_applications_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_ats_s0_001",
      "question": "How can I retrieve a paginated list of job postings, including only specific fields like `id`, `title`, and `status`, and optionally filter results to those created after a given date? Describe the HTTP method, the exact path, and the key query parameters you would use.",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context you provided only describes generic list endpoints (for job postings, applications, candidates, job custom field definitions, and application stages) in terms of available query parameters (`page`, `page_size`, `next`, `updated_after`, `sync_token`, `include`, etc.) and their responses. It does **not** specify:\n\n- The HTTP method (e.g., GET/POST) for the job postings list endpoint  \n- The exact path/URL for job postings (e.g., `/ats/job-postings` or similar)  \n- Whether filtering by *creation* date (as opposed to *updated_after*) is supported  \n\nTherefore, I cannot accurately state the exact path or confirm a `created_after`-style filter based on this excerpt.",
      "ground_truth_answer": "Use the `GET /unified/ats/job_postings` endpoint.\n\n- **HTTP method**: `GET`\n- **Path**: `/unified/ats/job_postings`\n\n**Required header**:\n- `x-account-id` (string, required) \u2013 The account identifier.\n\n**Key query parameters**:\n- `fields` (optional, string): Provide a comma-separated list of the specific fields you want returned. For example: `fields=id,title,status` (or any subset of the documented example `id,remote_id,title,locations,internal,status,job_id,remote_job_id,content,compensation,employment_type,employment_contract_type,external_url,external_apply_url,questionnaires,start_date,updated_at,created_at,unified_custom_fields`). If `fields` is empty, all fields are returned.\n- `filter[created_after]` (optional, date-time in ISO 8601): To return only job postings created after a specific timestamp, use the `filter` deepObject parameter. For example: `filter[created_after]=2020-01-01T00:00:00.000Z`.\n- `page_size` (optional, string): Controls how many results per page (default is 25).\n- `next` (optional, string): Cursor for fetching the next page, as described by the `x-speakeasy-pagination` cursor configuration.\n- `raw` (optional, boolean): If `true`, returns the raw provider response in addition to the mapped result.\n\nThis combination allows you to retrieve a paginated list of job postings, restrict the returned fields, and filter by creation date using the single `GET /unified/ats/job_postings` endpoint.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/job_postings.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_job_postings_part1",
        "ats_paths_get_unified_ats_applications_part1",
        "ats_paths_get_unified_ats_candidates_part1",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "ats_paths_get_unified_ats_jobs_id_application_stages_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s1_001",
      "question": "Which ATS API endpoint should I use to retrieve all notes attached to a specific application, and what path parameter do I need to include in the request URL?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS endpoint:\n\n`GET /unified/ats/applications/{id}/notes`\n\nYou must include the `id` path parameter in the request URL, where `id` is the identifier of the specific application whose notes you want to retrieve.",
      "ground_truth_answer": "Use the GET endpoint `GET /unified/ats/applications/{id}/notes`.\n\nYou must provide the application identifier as the `id` path parameter in the URL, for example:\n`GET https://api.stackone.com/unified/ats/applications/{id}/notes`.\n\nThis operation is described in the spec as \"List Application Notes\" and returns a `NotesPaginated` response containing the notes for that application.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/notes.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_notes_part1",
        "ats_paths_get_unified_ats_applications_id_notes_part0",
        "ats_paths_get_unified_ats_applications_id_notes_part2",
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part1",
        "ats_paths_get_unified_ats_applications_id_notes_subresourceid_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_ats_s2_001",
      "question": "Which ATS endpoint should I use to upload a base64-encoded resume file for an existing application, and what request body schema does it require?",
      "category": "endpoint",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "Use the ATS endpoint:\n\n`POST /applications/{id}/documents/upload`\n\n(identified in the docs as `ats_upload_application_document` under the Applications, Documents tags).\n\nIt requires a JSON request body using the `AtsDocumentsUploadRequestDto` schema, which has these fields:\n\n- `name` (string): The filename of the file to upload  \n- `file_format` (unknown): The file format of the file  \n- `content` (string): The base64 encoded content of the file to upload  \n- `category_id` (string): The categoryId of the documents  \n- `path` (string): The path for the file to be uploaded to  \n- `confidential` (unknown): The confidentiality level of the file to be uploaded  \n- `category` (unknown): The category to be associated with the file to be uploaded (id takes precedence over name)",
      "ground_truth_answer": "To upload a base64-encoded resume (or any document) for an existing application, use the POST endpoint:\n\n- **Endpoint:** `POST /unified/ats/applications/{id}/documents/upload`\n- **OperationId:** `ats_upload_application_document`\n- **Required header:** `x-account-id` (string)\n- **Path parameter:** `id` (string) \u2013 the application identifier\n- **Request body schema:** `AtsDocumentsUploadRequestDto`\n\nThe request body must be sent as `application/json` and must conform to the `AtsDocumentsUploadRequestDto` schema, which includes fields such as `name`, `file_format`, `content` (the base64-encoded file), `category_id`, `path`, `confidential`, and `category`.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/applications/{id}/documents/upload.post",
        "ats.components.AtsDocumentsUploadRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_post_unified_ats_applications_id_documents_upload_part1",
        "ats_components_atsdocumentsuploadrequestdto",
        "ats_components_applicationattachment",
        "ats_components_atsdocumentresult",
        "ats_components_atsdocumentapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s0_001",
      "question": "In the ATS API, what fields are included in the `BadRequestResponse` schema and which of them are required? Describe each field\u2019s purpose based on the documentation.",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "In the ATS API, the `BadRequestResponse` schema is an object with the following fields:\n\n**Required fields:**\n1. `statusCode` (number)  \n   - Purpose: The HTTP status code associated with the bad request error.\n\n2. `message` (string)  \n   - Purpose: A human-readable error message describing the bad request.\n\n3. `timestamp` (string)  \n   - Purpose: The time at which the error occurred.\n\n**Optional fields:**\n4. `data` (unknown)  \n   - Purpose: Additional error details. The structure is not specified (type is unknown).\n\n5. `provider_errors` (array of object)  \n   - Purpose: A list of provider-specific errors, allowing inclusion of error information returned by underlying providers.",
      "ground_truth_answer": "The `BadRequestResponse` schema is an object that includes the following fields:\n\n1. `statusCode` (required)\n- Type: number\n- Description: HTTP status code.\n- Example: 400\nThis indicates the HTTP status code returned for the bad request error.\n\n2. `message` (required)\n- Type: string\n- Description: Error message.\n- Example: \"Bad Request\"\nThis contains a human-readable description of the error that occurred.\n\n3. `timestamp` (required)\n- Type: string, format: date-time\n- Description: Timestamp when the error occurred.\n- Example: \"2023-05-30T00:00:00.000Z\"\nThis records when the bad request error happened.\n\n4. `data` (optional)\n- Type: object (nullable)\n- Description: Error details.\n- Schema: `UnifiedError` (via `$ref`)\nThis provides additional structured details about the error if available.\n\n5. `provider_errors` (optional)\n- Type: array of `ProviderError` (nullable)\n- Description: List of provider-specific errors.\nThis field holds any error information returned directly from the underlying provider.\n\nThe required fields for `BadRequestResponse` are exactly: `statusCode`, `message`, and `timestamp`. The `data` and `provider_errors` fields are optional and may be null or omitted.",
      "relevant_structural_ids": [
        "ats.components.BadRequestResponse"
      ],
      "retrieved_chunk_ids": [
        "ats_components_badrequestresponse",
        "ats_components_unauthorizedresponse",
        "ats_components_badgatewayresponse",
        "ats_components_forbiddenresponse",
        "ats_components_notfoundresponse"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_ats_s1_001",
      "question": "In the ATS API, what fields and types are included in the `AtsUpdateCandidateRequestDto` schema for updating a candidate, and which of these properties are marked as deprecated or nullable?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only lists some properties of the `AtsUpdateCandidateRequestDto` schema (e.g., `passthrough`, `unified_custom_fields`, `name`, `first_name`, `last_name`, `email`, `emails`, `social_links`, `phone`, `phone_numbers`, `company`, `title`, `application_ids`, `hired_at`, `country`) and their basic types, but it does not indicate which of these fields are deprecated or nullable.",
      "ground_truth_answer": "The `AtsUpdateCandidateRequestDto` schema is an object used when updating a candidate. It has the following properties:\n\n- `passthrough`: object, nullable, additionalProperties allowed, description: \"Value to pass through to the provider\". Example: `{ \"other_known_names\": \"John Doe\" }`.\n- `unified_custom_fields`: object, nullable, additionalProperties allowed, description: \"Custom Unified Fields configured in your StackOne project\". Example: `{ \"my_project_custom_field_1\": \"REF-1236\", \"my_project_custom_field_2\": \"some other value\" }`.\n- `name`: string, nullable, description: \"Candidate name\". Example: `\"Romain Sestier\"`.\n- `first_name`: string, nullable, description: \"Candidate first name\". Example: `\"Romain\"`.\n- `last_name`: string, nullable, description: \"Candidate last name\". Example: `\"Sestier\"`.\n- `email`: string, nullable, description: \"Candidate email\". Example: `\"sestier.romain123@gmail.com\"`.\n- `emails`: array of `CandidateEmail`, nullable, description: \"List of candidate emails\".\n- `social_links`: array of `SocialLink`, nullable, description: \"List of candidate social links\".\n- `phone`: string, nullable, description: \"Candidate phone number\". Example: `\"+16178294093\"`. This field is marked as **deprecated**.\n- `phone_numbers`: array of `PhoneNumber`, nullable, description: \"List of candidate phone numbers including the type of the number when available\".\n- `company`: string, nullable, description: \"Candidate company\". Example: `\"Company Inc.\"`.\n- `title`: string, nullable, description: \"Candidate title\". Example: `\"Software Engineer\"`.\n- `application_ids`: array of strings, nullable, description: \"List of candidate application IDs\". Example values: `\"123e4567-e89b-12d3-a456-426614174000\"`, `\"523e1234-e89b-fdd2-a456-762545121101\"`.\n- `hired_at`: string, format `date-time`, nullable, description: \"Candidate hired date\". Example: `\"2021-01-01T01:01:01.000Z\"`.\n- `country`: string, nullable, description: \"Candidate country\". Example: `\"United States\"`.\n- `custom_fields`: array of `CustomFields`, nullable, description: \"The candidate custom fields\".\n\nAll listed properties are nullable, `phone` is explicitly marked as deprecated, and there are no `required` fields declared on this schema in the provided spec snippet.",
      "relevant_structural_ids": [
        "ats.components.AtsUpdateCandidateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "ats_components_atsupdatecandidaterequestdto_part0",
        "ats_components_atscreatecandidaterequestdto",
        "ats_components_updateresultcandidateapimodel",
        "ats_components_atsupdateapplicationrequestdto",
        "ats_components_atscreateapplicationrequestdto"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_ats_s2_001",
      "question": "In the `AtsUpdateBackgroundCheckResultRequestDto` schema used by the `PATCH /unified/ats/background_checks/orders/{id}/result` endpoint, what are the possible enum values for the `AttachmentContentType.value` field, and which property exposes the provider\u2019s original content type value?",
      "category": "schema",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that `AttachmentContentType` has:\n\n- `value` (string): \u201cThe content type of the attachment.\u201d\n- `source_value` (unknown): \u201cThe source value of the content type.\u201d\n\nNo enum values for `AttachmentContentType.value` are listed, and there is no further detail on the specific possible values. Based on the description, `source_value` is the field that would expose the provider\u2019s original content type value, but its exact format or constraints are not documented here.",
      "ground_truth_answer": "The `AtsUpdateBackgroundCheckResultRequestDto` schema can include `attachments`, each of which uses the `AttachmentContentType` schema for its content type.\n\nIn `AttachmentContentType`, the `value` property is a string enum with the following possible values:\n- `\"text\"`\n- `\"pdf\"`\n- `\"video\"`\n- `\"other\"`\n- `\"unmapped_value\"`\n- `null`\n\nThe provider\u2019s original content type is exposed via the `source_value` property on `AttachmentContentType`. `source_value` can be a string, number, boolean, object, or array and contains the provider\u2019s raw content-type value.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders/{id}/result.patch",
        "ats.components.AtsUpdateBackgroundCheckResultRequestDto",
        "ats.components.AttachmentContentType"
      ],
      "retrieved_chunk_ids": [
        "ats_components_attachmentcontenttype",
        "ats_components_atsupdatebackgroundcheckresultrequestdto",
        "ats_components_attachment",
        "ats_components_applicationattachment",
        "ats_components_atsdocumentresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_ats_001",
      "question": "When calling any of the ATS unified endpoints such as POST /unified/ats/background_checks/orders or GET /unified/ats/applications/{id}, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "ats"
      ],
      "generated_answer": "You must:\n\n- Use **HTTP Basic** authentication.\n- Include the required header **`x-account-id`** with the account identifier in every request.",
      "ground_truth_answer": "The ATS unified endpoints use HTTP Basic authentication. Each request must include valid Basic auth credentials (per the `basic` security scheme) and the required `x-account-id` header set to the appropriate account identifier. Without both Basic auth and the `x-account-id` header, the call will fail with an authorization-related error (for example 401 Unauthorized or 403 Forbidden).",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/background_checks/orders.post",
        "ats.paths./unified/ats/applications/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_post_unified_ats_background_checks_orders",
        "ats_paths_post_unified_ats_applications_part0",
        "ats_paths_get_unified_ats_background_checks_packages_part0",
        "ats_components_atscreateapplicationrequestdto",
        "ats_paths_post_unified_ats_applications_id_documents_upload_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s0_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which request body field is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only mandatory request body field is `learning_object_external_reference`. It represents the external reference (main identifier) of the learning object that the assignment links the user to.",
      "ground_truth_answer": "The only mandatory request body field is learning_object_external_reference, which represents the external reference (main identifier) of the learning object associated with the assignment and is the primary identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_paths_get_unified_lms_assignments_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s1_001",
      "question": "When creating a user assignment via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is mandatory, and what does it represent?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The mandatory field is `learning_object_external_reference`. It represents the external reference (main identifier) of the learning object associated with the assignment and is used as the primary identifier when creating assignments.",
      "ground_truth_answer": "The only mandatory field is learning_object_external_reference. It represents the external reference of the learning object associated with the assignment and is the main identifier used for creating assignments.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_lms_s2_001",
      "question": "When creating a new assignment for a user via POST /unified/lms/users/{id}/assignments, which field in the LmsCreateAssignmentRequestDto is required and described as the main identifier for creating assignments?",
      "category": "factual",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field is `learning_object_external_reference`, described as \u201cthe main identifier for creating assignments.\u201d",
      "ground_truth_answer": "In LmsCreateAssignmentRequestDto, the only required field is `learning_object_external_reference`, which is described as \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_lms_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of assignment-type learning records for a specific user, and what query parameters can I use to filter those assignments by `status` and by `updated_after`?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You should call this endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`  \n- **Operation ID:** `lms_list_user_assignments`  \n- **Purpose:** \u201cRetrieve a list of assignment type learning records for a user.\u201d\n\nTo retrieve a **paginated** list and **filter** it:\n\n1. **Pagination query parameters:**\n   - `page` (query, optional, string): The page number of the results to fetch  \n   - `page_size` (query, optional, string): The number of results per page (default 25)  \n   - `next` (query, optional, string): The unified cursor  \n\n2. **Filtering by `updated_after`:**\n   - `updated_after` (query, optional, string): Use a string with a date to only select results updated after that given date  \n\n3. **Filtering by `status`:**\n   - The context mentions a `filter` parameter:  \n     - `filter` (query, optional, object): LMS Assignment Filter  \n   - However, the documentation snippet does **not** explicitly state which fields (such as `status`) are supported inside this `filter` object, or how to structure it.\n\nBecause the documentation provided does not specify the structure or allowed keys of `LMS Assignment Filter`, I **cannot confirm** from this context that `status` is a valid filter field or how to pass it.\n\nTherefore, the precise, documentation-backed answer is:\n\n- Use `GET /unified/lms/users/{id}/assignments` for a paginated list of assignment-type learning records for a specific user.\n- You can use `page`, `page_size`, `next`, and `updated_after` directly as query parameters.\n- There is a `filter` object for assignment filtering, but this context does **not** provide enough information to say how to filter by `status` in particular.\n\nI don't have enough information in the StackOne documentation to answer this question. The context specifies the correct endpoint and the `updated_after` parameter, and mentions a generic `filter` object, but it does not document how to filter by `status` or what fields the LMS Assignment Filter supports.",
      "ground_truth_answer": "Use the GET endpoint:\n\n- **Endpoint:** `GET /unified/lms/users/{id}/assignments`\n\nPath parameter:\n- `id` (required, in path): the user identifier whose assignments you want to list.\n\nKey query parameters for filtering:\n- `filter[status]` (in `filter` deepObject): filter assignments by their unified status. Allowed values are `pending`, `in_progress`, `completed`, `unmapped_value`, or `null`.\n- `filter[updated_after]` (in `filter` deepObject): a date-time string (e.g. `2020-01-01T00:00:00.000Z`) to only return assignments updated after that timestamp.\n\nAdditional pagination-related query parameters on this endpoint include `page` (deprecated), `page_size`, and `next` for cursor-based pagination.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.AssignmentStatusEnum"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "endpoint_lms_s1_001",
      "question": "Which endpoint should I use to retrieve a paginated list of assignment learning records for a specific user, and which query parameter lets me filter those assignments by their status (e.g. `completed`)?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the endpoint:\n\n- **`GET /unified/lms/users/{id}/assignments`** (Operation ID: `lms_list_user_assignments`) to retrieve a **paginated list of assignment learning records for a specific user**.\n\nThe context mentions a **`filter`** query parameter of type **\u201cLMS Assignment Filter\u201d**, but it does **not** specify any fields within that filter object (such as a `status` field or allowed values like `completed`).  \n\nTherefore:\n\n- I don't have enough information in the StackOne documentation to identify **which specific query parameter or filter field** should be used to filter assignments by status (e.g. `completed`). The docs only state `filter (query, optional, object): LMS Assignment Filter` without detailing its structure or supported keys.",
      "ground_truth_answer": "Use the GET `/unified/lms/assignments` endpoint to retrieve a paginated list of assignment learning records. To filter the returned assignments by their status (such as `pending`, `in_progress`, or `completed`), use the `filter[status]` query parameter defined in the `filter` deepObject parameter on this endpoint.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/assignments.get",
        "lms.components.AssignmentsPaginated",
        "lms.components.Assignment"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_assignments_part2",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part1",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_components_assignment_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 3,
      "accuracy_score": 2
    },
    {
      "question_id": "endpoint_lms_s2_001",
      "question": "Which endpoint should I use to retrieve all completed learning records for a specific user, and what required parameters must I include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "Use the **user-specific completions** endpoint:\n\n**Endpoint:**  \n`GET /unified/lms/users/{id}/completions`  \n(Operation ID: `lms_list_user_completions`)\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier  \n2. `id` (path, string) \u2013 The user\u2019s identifier",
      "ground_truth_answer": "Use the GET /unified/lms/users/{id}/completions endpoint.\n\nRequired parameters:\n- Path parameter:\n  - id: the user identifier whose completed learning records you want to retrieve (in the URL path).\n- Header:\n  - x-account-id: the account identifier (string, required).\n\nOptional query parameters you may also use include raw, proxy, fields, filter[updated_after], page, page_size, next, and updated_after, but only id and x-account-id are mandatory.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/completions.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_users_id_completions_part1",
        "lms_paths_get_unified_lms_users_id_completions_subresourceid_part1",
        "lms_paths_get_unified_lms_users_id_assignments_part1",
        "lms_paths_get_unified_lms_users_id_assignments_subresourceid_part1",
        "lms_paths_get_unified_lms_completions_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s0_001",
      "question": "When creating a new completion using the LmsCreateCompletionRequestDto schema, which field is required and what does it represent? Also, list two optional fields you can include to capture completion details.",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The required field in `LmsCreateCompletionRequestDto` is:\n\n- **`learning_object_external_reference` (string)** \u2013 This represents the external reference of the learning object associated with the completion and is the **main identifier for creating completions**.\n\nTwo optional fields you can include to capture completion details are, for example:\n\n- **`completed_at` (string)** \u2013 The date the content was completed.  \n- **`time_spent` (string)** \u2013 ISO 8601 duration representing the time spent completing the learning object.",
      "ground_truth_answer": "In the LmsCreateCompletionRequestDto schema, the only required field is `learning_object_external_reference`. It represents the external reference of the learning object associated with this completion and is the main identifier used when creating completions.\n\nTwo examples of optional fields that capture completion details are:\n- `completed_at`: a string in date-time format representing the date the content was completed (e.g. \"2021-07-21T14:00:00.000Z\").\n- `result`: a ResultStatusEnum object indicating the result of the completion.\n\nOther optional detail fields include `time_spent` (ISO 8601 duration), `score` (ScoreModel), `learning_object_id`, `content_external_reference` (deprecated), and `content_id` (deprecated).",
      "relevant_structural_ids": [
        "lms.components.LmsCreateCompletionRequestDto",
        "lms.components.ResultStatusEnum",
        "lms.components.ScoreModel"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_paths_post_unified_lms_users_id_completions_part2",
        "lms_paths_post_unified_lms_users_id_completions_part1",
        "lms_components_lmscreatecompletionrequestdto_part1",
        "lms_components_completion_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s1_001",
      "question": "When creating a new assignment for a user via the LMS API, which fields are required in the `LmsCreateAssignmentRequestDto` request body, and what is the purpose of the required field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only required field in the `LmsCreateAssignmentRequestDto` request body is:\n\n- `learning_object_external_reference` (string) \u2013 **required**\n\n**Purpose:**  \n`learning_object_external_reference` is the external reference of the learning object associated with the assignment, and it is the **main identifier used for creating assignments** (i.e., it identifies which learning object the user is being assigned).",
      "ground_truth_answer": "In the LMS API, assignments for a user are created with the `LmsCreateAssignmentRequestDto` schema (used by POST `/unified/lms/users/{id}/assignments`). According to the schema, the only required field is:\n\n- `learning_object_external_reference` (string)\n\nThis field is described as: \u201cThe external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\u201d\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` [deprecated], `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`, `learning_object_external_reference`) are optional except for `learning_object_external_reference`, which must be provided for the request to be valid.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_components_assignmentresult_part0",
        "lms_paths_get_unified_lms_assignments_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_lms_s2_001",
      "question": "When creating a user assignment via POST `/unified/lms/users/{id}/assignments`, which fields in the `LmsCreateAssignmentRequestDto` are required, and what is the purpose of the `learning_object_external_reference` field?",
      "category": "schema",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "The only field explicitly marked as required in `LmsCreateAssignmentRequestDto` is:\n\n- `learning_object_external_reference` (string, required)\n\nAll other listed fields (`passthrough`, `external_reference`, `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are **not** indicated as required in the provided context.\n\n**Purpose of `learning_object_external_reference`:**  \nIt is the external reference of the learning object associated with the assignment, and it is described as *\u201cthe main identifier for creating assignments.\u201d* In other words, this field is the primary identifier used to link the new assignment to a specific learning object when creating a user assignment.",
      "ground_truth_answer": "For POST `/unified/lms/users/{id}/assignments`, the request body must conform to the `LmsCreateAssignmentRequestDto` schema. In that schema, the only required field is `learning_object_external_reference`.\n\nAccording to `LmsCreateAssignmentRequestDto`, the `learning_object_external_reference` field is:\n- Type: `string`\n- Description: \"The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments.\"\n- Example: `\"learning-content-123\"`\n\nAll other properties in `LmsCreateAssignmentRequestDto` (`passthrough`, `external_reference` (deprecated), `learning_object_id`, `progress`, `assigned_at`, `due_date`, `status`) are nullable and not marked as required. Therefore, to successfully create an assignment, the client must at minimum provide `learning_object_external_reference`, which serves as the primary external identifier of the learning object to be assigned.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/users/{id}/assignments.post",
        "lms.components.LmsCreateAssignmentRequestDto"
      ],
      "retrieved_chunk_ids": [
        "lms_components_lmscreateassignmentrequestdto",
        "lms_paths_post_unified_lms_users_id_assignments_part2",
        "lms_paths_post_unified_lms_users_id_assignments_part1",
        "lms_components_assignment_part0",
        "lms_paths_get_unified_lms_assignments_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_lms_001",
      "question": "When calling any of the LMS endpoints such as GET /unified/lms/courses or POST /unified/lms/users/{id}/completions, what authentication and required header must you include in the request, and where are they specified in the OpenAPI description?",
      "category": "auth",
      "relevant_apis": [
        "lms"
      ],
      "generated_answer": "You must:\n\n1. Use **HTTP Basic authentication** for the request.\n2. Include the required header **`x-account-id`** (string) with the account identifier.\n\nThese are specified in the OpenAPI description under each LMS endpoint, for example:\n\n- Under **Authentication**: `Authentication: HTTP Basic`\n- Under **Parameters**:  \n  `- x-account-id (header, required, string): The account identifier`",
      "ground_truth_answer": "All LMS endpoints in the provided spec require HTTP Basic authentication and the x-account-id header.\n\nAuthentication:\n- Each operation includes a security requirement object: \"security\": [{ \"basic\": [] }], which refers to the HTTP Basic auth security scheme defined under SECURITY SCHEMES as:\n  - \"basic\": { \"type\": \"http\", \"scheme\": \"basic\" }\nThis means the client must send valid HTTP Basic credentials (e.g., via the Authorization: Basic <credentials> header).\n\nRequired header:\n- Every sampled LMS operation, including GET /unified/lms/courses and POST /unified/lms/users/{id}/completions, declares a required header parameter:\n  - name: x-account-id\n  - in: header\n  - description: \"The account identifier\"\n  - required: true\n  - schema: { \"type\": \"string\" }\n\nTherefore, to successfully call these endpoints you must:\n1) Authenticate using HTTP Basic auth (security scheme \"basic\").\n2) Provide the x-account-id header with a string value identifying the account.",
      "relevant_structural_ids": [
        "lms.paths./unified/lms/courses.get",
        "lms.paths./unified/lms/users/{id}/completions.post",
        "lms.paths./unified/lms/content.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "lms_paths_get_unified_lms_courses_part0",
        "lms_paths_post_unified_lms_users_id_completions_part0",
        "lms_components_lmscreatecompletionrequestdto_part0",
        "lms_paths_get_unified_lms_assignments_part0",
        "lms_paths_get_unified_lms_content_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s0_001",
      "question": "When listing IAM policies via GET /unified/iam/policies, which query parameter is marked as deprecated for pagination, and what newer cursor-based parameter should be used instead?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context lists the `page`, `page_size`, and `next` query parameters for pagination, but it does not indicate that any of them are deprecated or identify which one is the newer cursor-based parameter.",
      "ground_truth_answer": "For GET /unified/iam/policies, the \"page\" query parameter is deprecated for pagination. The newer cursor-based parameter that should be used instead is \"next\".",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_policies_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "factual_iam_s1_001",
      "question": "When listing IAM users via GET /unified/iam/users, which query parameter would you use to request that the response also include related roles and groups objects instead of just their identifiers, and how should its value be formatted?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the `expand` query parameter. Its value should be a comma\u2011separated list of the related fields you want expanded (i.e., related roles and groups objects) instead of just their identifiers.",
      "ground_truth_answer": "You should use the expand query parameter. It takes a comma\u2011separated string of field names to expand. For users, you would set expand=roles,groups to have the roles and groups fields expanded in the response.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_id_part1",
        "iam_paths_get_unified_iam_roles_part1",
        "iam_paths_get_unified_iam_roles_id_part1",
        "iam_paths_get_unified_iam_groups_id_part1",
        "iam_paths_get_unified_iam_users_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_iam_s2_001",
      "question": "When calling the IAM List Users endpoint, which query parameter should you use to request that the response include both the mapped result and the raw provider result, and what is its default value?",
      "category": "factual",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the `raw` query parameter, and its default value is `false`.",
      "ground_truth_answer": "For the IAM List Users endpoint (GET /unified/iam/users), you should use the `raw` query parameter. It is a boolean flag that \"indicates that the raw request result should be returned in addition to the mapped result\" and its default value is `false`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_users_part1",
        "iam_components_iamuserspaginated",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_roles_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s0_001",
      "question": "Which IAM endpoint should you call to retrieve a paginated list of groups, and which required header must you include in the request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the IAM endpoint:\n\n- `GET /unified/iam/groups`\n\nThe required header you must include is:\n\n- `x-account-id` (string) \u2013 the account identifier.",
      "ground_truth_answer": "Use the GET /unified/iam/groups endpoint (operationId: iam_list_groups) to retrieve a paginated list of groups. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/groups.get"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_groups_part0",
        "iam_components_iamgroupspaginated",
        "iam_paths_get_unified_iam_groups_id_part1",
        "iam_paths_get_unified_iam_groups_id_part0",
        "iam_paths_get_unified_iam_users_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s1_001",
      "question": "Which IAM endpoint should you use to update a user\u2019s primary email address, and what mandatory parameters and body schema are required for this request?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should use the **IAM endpoint**:\n\n**Endpoint:** `PATCH /unified/iam/users/{id}`  \n**Operation ID:** `iam_update_user`\n\n**Mandatory parameters:**\n- `x-account-id` (header, string, required): The account identifier  \n- `id` (path, string, required): The user\u2019s ID\n\n**Request body schema (IamUpdateUserRequestDto):** JSON object with the following fields (all optional, but include `primary_email_address` to update it):\n\n- `primary_email_address` (string): Primary email address of the user (generally a work email address).  \n- `first_name` (string)  \n- `last_name` (string)  \n- `name` (string): User's name (full name or display name)  \n- `username` (string)  \n- `is_bot_user` (unknown): Indicates if the user is a bot or service user  \n- `status` (unknown)  \n- `passthrough` (object): Value to pass through to the provider",
      "ground_truth_answer": "To update a user\u2019s primary email address you must call the **PATCH** endpoint:\n\n- **Endpoint:** `PATCH /unified/iam/users/{id}`\n- **OperationId:** `iam_update_user`\n\n**Required parameters:**\n1. `x-account-id` (header, string) \u2013 The account identifier (required)\n2. `id` (path, string) \u2013 The user identifier whose record you want to update (required)\n\n**Request body:**\n- Content type: `application/json`\n- Schema: `IamUpdateUserRequestDto`\n- Within this schema, you can set the `primary_email_address` field (along with other optional fields like `first_name`, `last_name`, `name`, `username`, `is_bot_user`, `status`, and `passthrough`).",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.patch",
        "iam.components.IamUpdateUserRequestDto"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamupdateuserrequestdto",
        "iam_components_iamuser",
        "iam_components_iamuserresult_part0",
        "iam_components_updateresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_iam_s2_001",
      "question": "Which IAM endpoint should I call to retrieve a paginated list of policies, and which query parameters can I use to control pagination and filtering of the results?",
      "category": "endpoint",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "You should call the **IAM \u201cList Policies\u201d endpoint**:\n\n- **Endpoint:** `GET /unified/iam/policies`  \n- **Operation ID:** `iam_list_policies`\n\nTo control **pagination**, you can use these query parameters:\n\n- `page` (optional, string): The page number of the results to fetch  \n- `page_size` (optional, string): The number of results per page (default is 25)  \n- `next` (optional, string): The unified cursor (used to fetch the next set of results)\n\nTo control **filtering and output**, you can use:\n\n- `filter` (optional, object): Filter parameters that allow greater customization of the list response  \n- `fields` (optional, string): Comma\u2011separated list of fields that will be returned (if empty, all fields are returned)  \n- `raw` (optional, boolean): If `true`, returns the raw provider result in addition to the mapped result  \n- `proxy` (optional, object): Parameters to pass through to the underlying provider request (wrapped under the `proxy` key)",
      "ground_truth_answer": "Use the GET `/unified/iam/policies` endpoint (operationId `iam_list_policies`) to retrieve a paginated list of policies.\n\nThis endpoint supports the following query parameters for pagination and filtering:\n- `page` (deprecated): The page number of the results to fetch.\n- `page_size`: The number of results per page (default is 25).\n- `next`: The unified cursor used for cursor-based pagination.\n- `filter[updated_after]`: A date-time string to only select results updated after the given date.\n\nAdditional optional query parameters include:\n- `fields`: Comma-separated list of fields to return (if empty, all fields are returned).\n- `expand`: Comma-separated list of fields to expand in the response (e.g. `permissions`).\n- `raw`: Boolean flag indicating whether to include the raw provider responses.\n- `proxy`: Deep object used to pass through parameters to the underlying provider request.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamPoliciesPaginated",
        "iam.components.IamPolicy"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_part1",
        "iam_paths_get_unified_iam_policies_part0",
        "iam_components_iampoliciespaginated",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_users_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_iam_s0_001",
      "question": "In the IAM API, when you delete a user via DELETE /unified/iam/users/{id} and the response body is present, which fields does the DeleteResult schema contain and which of them are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "In the IAM API, when you delete a user with `DELETE /unified/iam/users/{id}` and a response body is returned, it follows the `DeleteResult` schema, which contains:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required",
      "ground_truth_answer": "The DeleteResult response body for a successful user deletion contains three fields:\n- statusCode (number) \u2013 example 204\n- message (string) \u2013 example \"Record deleted successfully.\"\n- timestamp (string, date-time) \u2013 example \"2021-01-01T01:01:01.000Z\"\n\nAll three fields \u2014 statusCode, message, and timestamp \u2014 are required in the DeleteResult schema.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id",
        "iam_components_updateresult",
        "iam_paths_patch_unified_iam_users_id",
        "iam_components_iamuserresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s1_001",
      "question": "In the IAM API, what properties are returned in the `DeleteResult` object when a user is successfully deleted via the `DELETE /unified/iam/users/{id}` endpoint, and which of these fields are required?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The `DeleteResult` object returned by `DELETE /unified/iam/users/{id}` includes the following properties, all of which are required:\n\n- `statusCode` (number) \u2013 required  \n- `message` (string) \u2013 required  \n- `timestamp` (string) \u2013 required",
      "ground_truth_answer": "The `DeleteResult` object returned on a successful delete contains three properties:\n- `statusCode` (number): HTTP status code, example `204`.\n- `message` (string): a message describing the outcome, example `\"Record deleted successfully.\"`.\n- `timestamp` (string, date-time): when the operation occurred, example `\"2021-01-01T01:01:01.000Z\"`.\n\nAll three properties \u2014 `statusCode`, `message`, and `timestamp` \u2014 are required fields in `DeleteResult`.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users/{id}.delete",
        "iam.components.DeleteResult"
      ],
      "retrieved_chunk_ids": [
        "iam_components_deleteresult",
        "iam_paths_delete_unified_iam_users_id",
        "iam_paths_patch_unified_iam_users_id",
        "iam_paths_get_unified_iam_users_id_part1",
        "iam_paths_get_unified_iam_users_id_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_iam_s2_001",
      "question": "In the IAM API, what are the possible `value` options for the `IamPermissionTypeEnum` permission type, and how is the underlying raw provider value represented in the `source_value` field?",
      "category": "schema",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that `IamPermissionTypeEnum.value` is \u201cthe type of the permission, e.g. read, read_write, delete, etc.\u201d but does not list the complete set of allowed values, and `source_value` is typed as `unknown` with no further description of how the raw provider value is represented.",
      "ground_truth_answer": "The `IamPermissionTypeEnum` schema defines a `value` property whose possible options are:\n- `read`\n- `read_write`\n- `approve`\n- `delete`\n- `use`\n- `export`\n- `unmapped_value`\n- `null`\n\nThe raw value from the underlying provider is exposed via the `source_value` field, which is nullable and can be any of the following JSON types:\n- string\n- number\n- boolean\n- object\n- array (with unconstrained item type)\n\nThis allows StackOne to normalize the permission type into the `value` enum while still preserving the original provider-specific representation in `source_value`.",
      "relevant_structural_ids": [
        "iam.components.IamPermissionTypeEnum"
      ],
      "retrieved_chunk_ids": [
        "iam_components_iampermissiontypeenum",
        "iam_components_iampermission",
        "iam_components_iampolicyresult",
        "iam_components_iammfatypeenum",
        "iam_components_iamresourcetypeenum"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_iam_001",
      "question": "When calling the IAM endpoints such as GET /unified/iam/users or GET /unified/iam/roles, what authentication scheme is used and which required header must you include for the request to be authorized?",
      "category": "auth",
      "relevant_apis": [
        "iam"
      ],
      "generated_answer": "The IAM endpoints use **HTTP Basic** authentication, and you must include the required header:\n\n- `x-account-id` (string): the account identifier.",
      "ground_truth_answer": "The IAM endpoints use HTTP Basic authentication as defined by the `basic` security scheme. In addition, each request must include the required `x-account-id` header in order to be authorized.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.paths./unified/iam/roles.get",
        "iam.components.basic"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_paths_get_unified_iam_roles_part0",
        "iam_paths_get_unified_iam_groups_part0",
        "iam_paths_get_unified_iam_policies_part0",
        "iam_paths_patch_unified_iam_users_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_crm_s0_001",
      "question": "For the GET /unified/crm/contacts endpoint, which HTTP status codes are explicitly configured to trigger the x-speakeasy-retries backoff strategy?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context describes the endpoint parameters and error schemas (TooManyRequestsResponse, RequestTimedOutResponse, ProviderError), but it does not mention `x-speakeasy-retries` or specify which HTTP status codes are configured to trigger that backoff strategy.",
      "ground_truth_answer": "For the GET /unified/crm/contacts endpoint, the x-speakeasy-retries backoff strategy is configured to trigger on HTTP status codes 429 and 408.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_toomanyrequestsresponse",
        "crm_components_requesttimedoutresponse",
        "crm_components_providererror",
        "crm_paths_get_unified_crm_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_crm_s1_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its data format?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context mentions an `updated_after` query parameter (\u201cUse a string with a date to only select results updated after that given date\u201d), but it does not indicate that this parameter is deprecated, nor does it specify a particular date format.",
      "ground_truth_answer": "In the `GET /unified/crm/contacts` endpoint, the deprecated query parameter for selecting results updated after a given date is `updated_after`, and its data format is a `string` with `date-time` format (example: `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part2",
        "crm_paths_get_unified_crm_lists_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_crm_s2_001",
      "question": "For the `GET /unified/crm/contacts` endpoint, which HTTP status codes are explicitly configured to be retried using the `backoff` strategy in `x-speakeasy-retries`?",
      "category": "factual",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context does not include any `x-speakeasy-retries` configuration or details about which HTTP status codes are retried with a `backoff` strategy for the `GET /unified/crm/contacts` endpoint.",
      "ground_truth_answer": "For the `GET /unified/crm/contacts` endpoint, the `x-speakeasy-retries` configuration specifies a `backoff` strategy for status codes **429** and **408**.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_components_toomanyrequestsresponse",
        "crm_paths_get_unified_crm_contacts_id_part1",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_crm_s0_001",
      "question": "Which endpoint should I call to retrieve a paginated list of CRM contacts updated after a specific timestamp, and which query parameters control the update filter and cursor-based pagination?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You should call this endpoint:\n\n- **Endpoint:** `GET /unified/crm/contacts`\n\nThe relevant query parameters are:\n\n- **Update filter:**\n  - `updated_after` (query, optional, string): use a date-time string to only select contacts updated after that timestamp.\n\n- **Cursor-based pagination:**\n  - `next` (query, optional, string): the unified cursor used to retrieve the next page of results.",
      "ground_truth_answer": "Use the GET /unified/crm/contacts endpoint.\n\nTo filter by last update time, you can use either:\n- The deprecated top-level query parameter `updated_after`, or\n- The recommended `filter[updated_after]` deepObject parameter (specified under the `filter` object in the query string).\n\nCursor-based pagination is controlled by:\n- The `next` query parameter in the request (the unified cursor), and\n- The `next` field in the `ContactsPaginated` response body, which provides the cursor value for the following page.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_crm_s1_001",
      "question": "Which endpoint should I use to retrieve a single contact by its StackOne contact ID, and what header must I include with the account identifier?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the `GET /unified/crm/contacts/{id}` endpoint (operation ID: `crm_get_contact`) to retrieve a single contact by its StackOne contact ID.  \n\nYou must include the `x-account-id` header with the account identifier.",
      "ground_truth_answer": "Use the GET /unified/crm/contacts/{id} endpoint (operationId: crm_get_contact). You must include the x-account-id header containing the account identifier in the request.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_id_part1",
        "crm_paths_get_unified_crm_contacts_id_part2",
        "crm_paths_get_unified_crm_contacts_id_part3",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_crm_s2_001",
      "question": "Which CRM endpoint should I use to retrieve all custom field definitions specifically for contacts, and what query parameter enables cursor-based pagination over the results?",
      "category": "endpoint",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "Use the CRM endpoint:\n\n- **Endpoint:** `GET /unified/crm/custom_field_definitions/contacts`  \n- **Purpose:** List Contact Custom Field Definitions (i.e., all custom field definitions specifically for contacts).\n\nThe query parameter that enables cursor-based pagination is:\n\n- **`next` (query, optional, string):** The unified cursor used to paginate over results.",
      "ground_truth_answer": "Use the GET /unified/crm/custom_field_definitions/contacts endpoint (operationId: crm_list_contact_custom_field_definitions). Cursor-based pagination is controlled via the next query parameter, which is also referenced in x-speakeasy-pagination as the cursor input.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/custom_field_definitions/contacts.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part1",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_components_customfielddefinitionspaginated",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part2",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s0_001",
      "question": "When calling the `Create Contact` endpoint, which fields can be included in the `CrmCreateContactRequestDto` request body, and what is the purpose of the `passthrough` object?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "When calling the `Create Contact` endpoint (`POST /unified/crm/contacts`), the `CrmCreateContactRequestDto` request body can include the following fields:\n\n- `first_name` (string): The contact first name  \n- `last_name` (string): The contact last name  \n- `company_name` (string): The contact company name  \n- `emails` (array of string): List of contact email addresses  \n- `phone_numbers` (array of string): List of contact phone numbers  \n- `deal_ids` (array of string): List of associated deal IDs  \n- `account_ids` (array of string): List of associated account IDs  \n- `custom_fields` (array of object): Contact custom fields  \n- `passthrough` (object): Value to pass through to the provider  \n\nPurpose of `passthrough`:\n- The `passthrough` object is used to include data that should be forwarded directly to the underlying CRM provider. It allows you to send provider-specific values that are not part of the unified StackOne schema.",
      "ground_truth_answer": "The `Create Contact` endpoint (`POST /unified/crm/contacts`) expects a JSON request body with the schema `CrmCreateContactRequestDto`.\n\nThe following fields can be included in the `CrmCreateContactRequestDto` object (all are nullable/optional):\n- `first_name` (string): The contact first name.\n- `last_name` (string): The contact last name.\n- `company_name` (string): The contact company name.\n- `emails` (array of string): List of contact email addresses.\n- `phone_numbers` (array of string): List of contact phone numbers.\n- `deal_ids` (array of string): List of associated deal IDs.\n- `account_ids` (array of string): List of associated account IDs.\n- `custom_fields` (array of `CustomFields`): Contact custom fields.\n- `passthrough` (object with additionalProperties allowed): A free-form object whose value is passed through to the underlying provider. It is intended for provider-specific data, for example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo properties are marked as required on `CrmCreateContactRequestDto` in the provided schema.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.post",
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part1",
        "crm_paths_patch_unified_crm_contacts_id_part2",
        "crm_paths_post_unified_crm_contacts_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_crm_s1_001",
      "question": "In the CRM API, when you call GET `/unified/crm/contacts` and receive a successful `200` response, what fields and structure does the `ContactsPaginated` response contain, including how pagination and raw provider data are represented?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "In the CRM API, a successful `200` response from `GET /unified/crm/contacts` returns a `ContactsPaginated` object with the following structure:\n\n- **`next_page` (string)**  \n  - A string field used for pagination.  \n  - Represents the value you can use to request the next page of results.\n\n- **`next` (string)**  \n  - Another pagination-related string field (also described elsewhere as \u201cthe unified cursor\u201d).  \n  - Can be used as a cursor for fetching subsequent results.\n\n- **`data` (array of object, required)**  \n  - An array of contact objects.  \n  - Each element is a mapped contact record (i.e., conforms to the unified contact schema such as `Contact`/`ContactResult.data`, with fields like `id`, `remote_id`, `first_name`, `last_name`, `company_name`, `emails`, `phone_numbers`, etc., as defined in the Contact schemas).\n\n- **`raw` (array of object)**  \n  - Optional array containing raw provider data.  \n  - Returned when the `raw` query parameter is set to `true`.  \n  - Each element represents the provider\u2019s unmodified contact payload(s), in parallel to the unified records in `data`.\n\nThis `ContactsPaginated` structure is the full body of the `200` response for `GET /unified/crm/contacts`.",
      "ground_truth_answer": "A successful `200` response from GET `/unified/crm/contacts` returns a JSON body matching the `ContactsPaginated` schema.\n\n`ContactsPaginated` is an object with these properties:\n- `next_page` (string, nullable, deprecated): an optional cursor string for the next page. It may be `null` and is marked as deprecated.\n- `next` (string, nullable): the unified cursor used for cursor-based pagination. This is the current pagination token to request the next page.\n- `data` (array of `Contact` objects): the list of contacts returned by the request. This field is **required**.\n- `raw` (array of `RawResponse` objects, nullable): optional array containing raw provider responses alongside the unified `data`.\n\nThe only required property of `ContactsPaginated` is `data`; the other properties are optional/nullable, with `next_page` specifically marked as deprecated and `next` being the primary cursor for pagination. Pagination is therefore represented by the `next` (and legacy `next_page`) properties, while provider-specific payloads are represented by the `raw` array.",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "crm_components_contactspaginated",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_components_contact_part0",
        "crm_components_contactresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_crm_s2_001",
      "question": "For the CRM API, when creating or updating a contact using the CrmCreateContactRequestDto schema, what is the structure and allowed data types of the custom_fields and passthrough properties in the request body?",
      "category": "schema",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that, in `CrmCreateContactRequestDto`, `custom_fields` is an \"array of object\" and `passthrough` is an \"object\", without defining the internal structure of those objects or the allowed data types beyond that. The related `CustomFields` and `CustomFieldOption` schemas are described separately, but the documentation does not explicitly state that these are the exact structures to be used inside `custom_fields`, nor does it define the shape of `passthrough` for this endpoint.",
      "ground_truth_answer": "In the CRM API, the CrmCreateContactRequestDto schema defines the custom_fields and passthrough properties as follows:\n\n- custom_fields:\n  - Type: array\n  - Nullable: true\n  - Description: \"Contact custom fields\"\n  - Items: each element is a CustomFields object (referenced as $ref: \"#/components/schemas/CustomFields\").\n\n- passthrough:\n  - Type: object\n  - Nullable: true\n  - Description: \"Value to pass through to the provider\"\n  - additionalProperties: true (it can contain arbitrary key-value pairs)\n  - Example given in the schema: { \"other_known_names\": \"John Doe\" }.\n\nThere are no required fields on CrmCreateContactRequestDto specified in the sampled schema; first_name, last_name, company_name, emails, phone_numbers, deal_ids, account_ids, custom_fields, and passthrough are all defined as nullable properties, with custom_fields as an array of CustomFields objects and passthrough as a free-form JSON object with arbitrary properties.",
      "relevant_structural_ids": [
        "crm.components.CrmCreateContactRequestDto"
      ],
      "retrieved_chunk_ids": [
        "crm_components_crmcreatecontactrequestdto",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_patch_unified_crm_contacts_id_part1",
        "crm_components_customfields",
        "crm_components_customfieldoption"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "auth_crm_001",
      "question": "When calling any of the CRM endpoints such as GET /unified/crm/contacts, what authentication scheme and required header must you include to successfully authorize the request?",
      "category": "auth",
      "relevant_apis": [
        "crm"
      ],
      "generated_answer": "You must use **HTTP Basic authentication** and include the required header:\n\n- `x-account-id` (string): the account identifier.",
      "ground_truth_answer": "All CRM endpoints in the provided spec use HTTP Basic authentication under the \"basic\" security scheme, and they also require the \"x-account-id\" header to be set. For example, GET /unified/crm/contacts declares a security requirement of `{ \"basic\": [] }` and a required `x-account-id` header parameter described as \"The account identifier\" with type string. This same basic auth scheme and required x-account-id header appear consistently on the other CRM endpoints (contacts, accounts, lists, and custom field definitions).",
      "relevant_structural_ids": [
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/contacts.post",
        "crm.paths./unified/crm/contacts/{id}.get",
        "crm.paths./unified/crm/contacts/{id}.patch",
        "crm.paths./unified/crm/accounts.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/lists/{id}.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get"
      ],
      "retrieved_chunk_ids": [
        "crm_paths_get_unified_crm_contacts_part0",
        "crm_paths_post_unified_crm_contacts_part0",
        "crm_paths_get_unified_crm_custom_field_definitions_contacts_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "crm_paths_get_unified_crm_contacts_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s0_001",
      "question": "For the Marketing API, what is the name and location (header, path, or query) of the required parameter that must be included on every request to list campaigns via GET /unified/marketing/campaigns, and what is its described purpose?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The required parameter is:\n\n- **Name:** `x-account-id`  \n- **Location:** `header`  \n- **Described purpose:** \u201cThe account identifier\u201d (it identifies the account and must be included on every request).",
      "ground_truth_answer": "For GET /unified/marketing/campaigns, the required parameter is named \"x-account-id\". It is sent in the HTTP header (in: header), and its described purpose is \"The account identifier\".",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_content_blocks_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "factual_marketing_s1_001",
      "question": "When listing SMS templates via the Marketing API, which cursor-based pagination field in the `SmsTemplatesPaginated` response does the `x-speakeasy-pagination` configuration treat as the `nextCursor` value?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context lists the `next_page` and `next` fields in the `SmsTemplatesPaginated` schema, but it does not specify which one the `x-speakeasy-pagination` configuration uses as the `nextCursor` value.",
      "ground_truth_answer": "For SMS templates, the cursor-based pagination uses the `next` field in the `SmsTemplatesPaginated` response as the `nextCursor`. The `x-speakeasy-pagination` config for `GET /unified/marketing/templates/sms` specifies `\"nextCursor\": \"$.next\"`, so clients should read the `next` property to obtain the cursor for the subsequent page.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.components.SmsTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "factual_marketing_s2_001",
      "question": "When listing campaigns via GET /unified/marketing/campaigns, which query parameter is marked as deprecated for selecting results updated after a given date, and what is its specified format?",
      "category": "factual",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only states that there is an `updated_after` query parameter (\u201cUse a string with a date to only select results updated after that given date\u201d), but it does not indicate that this parameter is deprecated nor specify any particular date format.",
      "ground_truth_answer": "The deprecated query parameter is `updated_after`, and its value must be a string in `date-time` format (for example, `2020-01-01T00:00:00.000Z`).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part1",
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part0",
        "marketing_paths_get_unified_marketing_templates_email_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 1
    },
    {
      "question_id": "endpoint_marketing_s0_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what required parameters and request body schema does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **PATCH** endpoint:\n\n**Endpoint to use:**\n- `PATCH /unified/marketing/templates/push/{id}`  \n  - Operation ID: `marketing_update_push_template`\n\n**Required parameters:**\n- `x-account-id` (header, string, required): The account identifier  \n- `id` (path, string, required): The identifier of the push template to update\n\n**Required request body (JSON):**  \nUses the same schema as `MarketingCreatePushTemplateRequestDto`:\n\n- `name` (string)\n- `tags` (array of string)\n- `messages` (array of object)\n- `passthrough` (object): Value to pass through to the provider",
      "ground_truth_answer": "Use the PATCH /unified/marketing/templates/push/{id} endpoint.\n\nDetails:\n- HTTP method & path: PATCH /unified/marketing/templates/push/{id}\n- Required header parameter:\n  - x-account-id (string) \u2013 the account identifier\n- Required path parameter:\n  - id (string) \u2013 identifier of the push template you want to update\n- Request body:\n  - Content-Type: application/json\n  - Schema: MarketingCreatePushTemplateRequestDto\n- Authentication:\n  - HTTP basic auth (security scheme: basic)\n- On success it returns a 200 response with a body matching the CreateResult schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto",
        "marketing.components.CreateResult"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_components_marketingcreatepushtemplaterequestdto",
        "marketing_paths_post_unified_marketing_templates_push",
        "marketing_components_pushmessagecontents",
        "marketing_components_pushmessages"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "endpoint_marketing_s1_001",
      "question": "Which endpoint should I call to update an existing push notification template, and what HTTP method and required header and path parameters does it use?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You should call the **`PATCH /unified/marketing/templates/push/{id}`** endpoint.\n\n- **HTTP method:** `PATCH`  \n- **Required header parameter:**  \n  - `x-account-id` (string) \u2013 The account identifier  \n- **Required path parameter:**  \n  - `id` (string) \u2013 The identifier of the push template to update",
      "ground_truth_answer": "To update an existing push notification template you should use the Update Push Template endpoint:\n\n- HTTP method: PATCH\n- Path: `/unified/marketing/templates/push/{id}`\n- Required header parameter:\n  - `x-account-id` (in `header`, type `string`) \u2013 the account identifier\n- Required path parameter:\n  - `id` (in `path`, type `string`) \u2013 the identifier of the push template you want to update\n\nThis operation is defined under `marketing_update_push_template` and requires a JSON request body matching the `MarketingCreatePushTemplateRequestDto` schema.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push/{id}.patch",
        "marketing.components.MarketingCreatePushTemplateRequestDto"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_patch_unified_marketing_templates_push_id",
        "marketing_paths_patch_unified_marketing_templates_sms_id",
        "marketing_paths_patch_unified_marketing_templates_email_id",
        "marketing_paths_patch_unified_marketing_templates_in_app_id",
        "marketing_paths_patch_unified_marketing_templates_omni_channel_id"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "endpoint_marketing_s2_001",
      "question": "Which endpoint should I use to retrieve a paginated list of SMS templates, and what header is required to identify the account?",
      "category": "endpoint",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "Use the endpoint:\n\n- `GET /unified/marketing/templates/sms`\n\nThe required header to identify the account is:\n\n- `x-account-id` (string): The account identifier.",
      "ground_truth_answer": "Use the GET /unified/marketing/templates/sms endpoint (operationId: marketing_list_sms_templates) to retrieve a paginated list of SMS templates. You must include the x-account-id header in the request, which is a required string identifying the account.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_templates_sms_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part1",
        "marketing_components_smstemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_sms_id_part1",
        "marketing_paths_get_unified_marketing_templates_sms_id_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "schema_marketing_s0_001",
      "question": "When creating a new content block using the MarketingCreateContentBlocksRequestDto schema, which fields can you include in the request body and what is the purpose of the `type` and `passthrough` fields?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "You can include the following fields in the request body when creating a new content block with `MarketingCreateContentBlocksRequestDto`:\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (unknown / enum)\n- `passthrough` (object)\n\nPurpose of specific fields:\n\n- `type`: A StackOne enum identifying the type of content block.  \n- `passthrough`: An object whose value is passed through directly to the provider.",
      "ground_truth_answer": "The request body for creating a content block with MarketingCreateContentBlocksRequestDto is a JSON object that can include the following fields (all are nullable/optional):\n\n- `name` (string, nullable): The name of the content block.\n- `tags` (array of strings, nullable): A list of tags associated with the content block.\n- `content` (string, nullable): The actual content of the block.\n- `type` (ContentBlockTypeEnumApiModel, nullable): A Stackone enum identifying the type of content block. `type` is an object with:\n  - `value` (string enum: `\"text\"`, `\"html\"`, `\"image\"`, `\"code-snippet\"`, `\"unmapped_value\"`, or null): describes the type of the content block.\n  - `source_value` (string | number | boolean | object | array, nullable): the original source value of the type from the provider.\n- `passthrough` (object, nullable, additionalProperties allowed): Arbitrary key\u2013value data to pass through directly to the underlying provider; the spec describes it as \"Value to pass through to the provider\" and shows an example `{ \"other_known_names\": \"John Doe\" }`.\n\nNo fields are marked as required in this schema, so all of the above are optional in the request body.",
      "relevant_structural_ids": [
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_paths_patch_unified_marketing_content_blocks_id",
        "marketing_components_contentblock",
        "marketing_components_contentblockresult"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 4
    },
    {
      "question_id": "schema_marketing_s1_001",
      "question": "For the Marketing API, when you create a new content block using POST /unified/marketing/content_blocks, which fields can you include in the JSON request body and what is the allowed value set for the ContentBlock `type` field?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "From the provided StackOne documentation:\n\nWhen creating a new content block with  \n**POST `/unified/marketing/content_blocks`**, the JSON request body can include these fields (all are optional unless your own usage requires them):\n\n- `name` (string)\n- `tags` (array of string)\n- `content` (string)\n- `type` (unknown) \u2013 described as a *Stackone enum identifying the type of content block*\n- `passthrough` (object) \u2013 value to pass through to the provider\n\nRegarding the allowed value set for the **`type`** field:\n\n- The documentation only says that `type` is a *Stackone enum identifying the type of content block* and references `ContentBlockTypeEnumApiModel`, which has:\n  - `value` (string): the type of the content blocks\n  - `source_value` (unknown): the source value of the type\n\nHowever, **no specific list of allowed enum values for `type` is provided** in the given context.\n\nTherefore:\n\n> I don't have enough information in the StackOne documentation to answer this question. The context specifies that `type` is a Stackone enum and points to `ContentBlockTypeEnumApiModel`, but it does not list the actual allowed values for this enum.",
      "ground_truth_answer": "Creating a content block uses the MarketingCreateContentBlocksRequestDto schema.\n\nRequest body fields you can include:\n- `name`: string, nullable\n- `tags`: array of strings, nullable\n- `content`: string, nullable\n- `type`: object, nullable, using ContentBlockTypeEnumApiModel\n- `passthrough`: object, nullable, additionalProperties allowed (arbitrary key/values passed through to the provider)\n\nThe `type` field is a ContentBlockTypeEnumApiModel object with:\n- `value`: string enum (nullable) with allowed values:\n  - `text`\n  - `html`\n  - `image`\n  - `code-snippet`\n  - `unmapped_value`\n  - `null` (explicitly allowed)\n- `source_value`: the raw provider value, which may be string, number, boolean, object, or array (nullable).",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/content_blocks.post",
        "marketing.components.MarketingCreateContentBlocksRequestDto",
        "marketing.components.ContentBlockTypeEnumApiModel"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_post_unified_marketing_content_blocks",
        "marketing_components_marketingcreatecontentblocksrequestdto",
        "marketing_components_contentblock",
        "marketing_components_contentblockresult",
        "marketing_components_contentblocktypeenumapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "schema_marketing_s2_001",
      "question": "For the `PushTemplatesPaginated` response returned by `GET /unified/marketing/templates/push`, which field is required and what is its structure, including the type of its items and their schema reference?",
      "category": "schema",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "For the `PushTemplatesPaginated` response:\n\n- **Required field:** `data`\n- **Structure:**\n  - Type: `array`\n  - Items: `object`\n  - Schema reference: each item is a push template object matching the **`PushTemplate`** schema (i.e., objects with fields such as `id`, `remote_id`, `name`, `tags`, `created_at`, `updated_at`, `messages`).",
      "ground_truth_answer": "In the `PushTemplatesPaginated` schema, the only required field is `data`.\n\nStructure of `data`:\n- `data` is an array (`type: array`).\n- Each element of the `data` array is a `PushTemplate` object, referenced as:\n  - `items: { \"$ref\": \"#/components/schemas/PushTemplate\" }`.\n\nSo, `data` is a required array of `PushTemplate` objects in the `PushTemplatesPaginated` response body of `GET /unified/marketing/templates/push`.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/templates/push.get",
        "marketing.components.PushTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "marketing_components_pushtemplatespaginated",
        "marketing_paths_get_unified_marketing_templates_push_part0",
        "marketing_components_pushtemplateresult",
        "marketing_components_pushtemplate",
        "marketing_paths_get_unified_marketing_templates_push_id_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "auth_marketing_001",
      "question": "When calling any of the MARKETING API endpoints (for example, GET /unified/marketing/campaigns), what authentication scheme must be used, and which required header must you include for the account context?",
      "category": "auth",
      "relevant_apis": [
        "marketing"
      ],
      "generated_answer": "The MARKETING API endpoints require **HTTP Basic** authentication.\n\nYou must also include the required header:\n\n- `x-account-id`: this header must contain the **account identifier** to provide the account context for the request.",
      "ground_truth_answer": "The MARKETING API uses HTTP Basic authentication via the `basic` security scheme. In addition to providing valid Basic auth credentials, every endpoint requires the `x-account-id` header in the request, which must be set to the account identifier to specify the account context.",
      "relevant_structural_ids": [
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/sms.get"
      ],
      "retrieved_chunk_ids": [
        "marketing_paths_get_unified_marketing_campaigns_part0",
        "marketing_paths_get_unified_marketing_campaigns_id_part1",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "marketing_paths_get_unified_marketing_templates_in_app_part0",
        "marketing_paths_get_unified_marketing_templates_sms_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 5
    },
    {
      "question_id": "cross_api_s0_001",
      "question": "Which APIs sampled here support listing resources with a `filter.updated_after` parameter, and what is the parameter\u2019s type and format in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following sampled list APIs all support listing resources with a `filter.updated_after` query parameter:\n\n1. **List of applications\u2019 scheduled interviews**\n2. **List of application custom field definitions**\n3. **List of application document categories**\n4. **List of background check packages**\n5. **List of omni-channel templates**\n\nFor each of these APIs, the `filter.updated_after` parameter has:\n\n- **Type:** string (query parameter)\n- **Format:** a string containing a date, described as:  \n  \u201cUse a string with a date to only select results updated after that given date\u201d\n\nNo additional date format (e.g., ISO 8601) is specified in the provided context.",
      "ground_truth_answer": "The following sampled APIs support listing resources with a `filter.updated_after` parameter:\n\n1. **HRIS**\n   - Endpoints:\n     - `GET /unified/hris/time_off_policies`\n     - `GET /unified/hris/jobs`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject query parameter schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: \"Use a string with a date to only select results updated after that given date\".\n\n2. **ATS**\n   - Endpoints:\n     - `GET /unified/ats/lists`\n     - `GET /unified/ats/job_postings`\n   - For both endpoints, `filter.updated_after` is defined inside the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Description: same wording as HRIS (select results updated after that date).\n\n3. **LMS**\n   - Endpoints:\n     - `GET /unified/lms/completions`\n     - `GET /unified/lms/users/{id}/assignments`\n   - For both, `filter.updated_after` is inside the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description about selecting results updated after the given date.\n\n4. **IAM**\n   - Endpoint:\n     - `GET /unified/iam/users`\n   - `filter.updated_after` is defined in the `filter` deepObject schema as:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\n5. **CRM**\n   - Endpoints:\n     - `GET /unified/crm/contacts`\n     - `GET /unified/crm/lists`\n     - `GET /unified/crm/custom_field_definitions/contacts/{id}`\n     - `GET /unified/crm/accounts`\n   - In each of these, `filter.updated_after` appears in the `filter` deepObject schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same description text.\n\n6. **MARKETING**\n   - Endpoints:\n     - `GET /unified/marketing/campaigns`\n     - `GET /unified/marketing/templates/sms`\n     - `GET /unified/marketing/templates/omni_channel` (deprecated)\n   - For each, `filter.updated_after` is in the `filter` object schema with:\n     - `type: string`\n     - `format: date-time`\n     - Same \"updated after\" description.\n\nAcross all these APIs and sampled list endpoints, `filter.updated_after` is consistently a string with `format: date-time` used to restrict results to those updated after the specified timestamp.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/time_off_policies.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/job_postings.get",
        "lms.paths./unified/lms/completions.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "iam.paths./unified/iam/users.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/custom_field_definitions/contacts/{id}.get",
        "crm.paths./unified/crm/accounts.get",
        "marketing.paths./unified/marketing/campaigns.get",
        "marketing.paths./unified/marketing/templates/sms.get",
        "marketing.paths./unified/marketing/templates/omni_channel.get"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_applications_id_scheduled_interviews_part2",
        "ats_paths_get_unified_ats_custom_field_definitions_applications_part1",
        "ats_paths_get_unified_ats_documents_application_categories_part1",
        "ats_paths_get_unified_ats_background_checks_packages_part1",
        "marketing_paths_get_unified_marketing_templates_omni_channel_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 5,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s0_002",
      "question": "Compare how request pagination is implemented for listing users in the IAM API and listing contacts in the CRM API. Which query parameters control pagination in each, and how is cursor-based pagination represented in their response schemas?",
      "category": "cross_api",
      "relevant_apis": [
        "IAM",
        "CRM"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only provides one set of pagination query parameters (`page`, `page_size`, `next`) and one paginated response schema pattern (`next_page`, `next`, `data`, `raw`) that is described first under the IAM API (`IamUsersPaginated`) and then repeated under the CRM API (`ContactsPaginated`). There is no separate, explicit description of distinct pagination query parameters for CRM contacts vs. IAM users, nor any detailed explanation of how cursor-based pagination differs between the two beyond the shared `next` and `next_page` fields.",
      "ground_truth_answer": "**IAM \u2013 list users**\n- Endpoint: `GET /unified/iam/users`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number of results to fetch.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `IamUsersPaginated` (referenced as `#/components/schemas/IamUsersPaginated`).\n  - From the pattern used across StackOne paginated schemas (and explicitly visible in others), the cursor is represented by a `next` field in the paginated object, alongside a deprecated `next_page`. For IAM, the `x-speakeasy-pagination` block on the endpoint confirms that the output cursor is taken from `$.next`.\n  - The OpenAPI `x-speakeasy-pagination` extension for this endpoint:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"` (meaning the response body has a `next` property used as the cursor for the next request).\n\n**CRM \u2013 list contacts**\n- Endpoint: `GET /unified/crm/contacts`\n- Pagination request parameters:\n  - `page` (query, deprecated): page number.\n  - `page_size` (query): number of results per page (default 25).\n  - `next` (query): \"The unified cursor\".\n- Pagination response representation:\n  - Response schema: `ContactsPaginated`.\n  - `ContactsPaginated` has the following pagination-related properties:\n    - `next_page` (string, deprecated, nullable): legacy page-based cursor.\n    - `next` (string, nullable): current cursor used for the next page.\n  - The endpoint also has an `x-speakeasy-pagination` block mirroring IAM\u2019s:\n    - `type: cursor`\n    - `inputs`: one cursor input named `next` in parameters.\n    - `outputs`: `nextCursor: \"$.next\"`, indicating the `next` field of `ContactsPaginated` is the cursor value to send back in the `next` query parameter.\n\n**Comparison**\n- Both IAM and CRM list endpoints use the same pattern:\n  - Request-side pagination uses `page` (deprecated), `page_size`, and a cursor `next` query parameter.\n  - Response-side pagination exposes a `next` field that holds the cursor for subsequent calls, with a deprecated `next_page` for older page-based flows.\n  - Both are annotated with `x-speakeasy-pagination` declaring `type: cursor` and mapping the output cursor from `$.next`.\n- The main difference is only in the concrete paginated schema names (`IamUsersPaginated` vs `ContactsPaginated`); the structure and cursor handling are aligned.",
      "relevant_structural_ids": [
        "iam.paths./unified/iam/users.get",
        "iam.components.IamUsersPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactsPaginated"
      ],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_users_part0",
        "iam_components_iamuserspaginated",
        "crm_paths_get_unified_crm_contacts_part1",
        "crm_components_contactspaginated",
        "iam_components_iamuserresult_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s0_003",
      "question": "You need to design a monitoring tool that inspects both HRIS employee document downloads and IAM file metadata for audit purposes. Based only on the sampled specs, what response media types and response schema are used when downloading an HRIS employee document, and which IAM schema provides file metadata fields like `remote_url` and `file_format` that could be correlated with those downloads? Describe how these two APIs\u2019 responses could be combined for auditing.",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "IAM"
      ],
      "generated_answer": "The HRIS employee document download and IAM file metadata pieces line up as follows:\n\n1. **HRIS employee document download response**\n\n- **Endpoint:** `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`\n- **Response schema:** `DownloadApiModel`\n- **DownloadApiModel fields:**\n  - `headers` (unknown, required): Headers related to the download  \n  - `data` (string, required): The file data in **binary format**\n\nThe context does **not** explicitly state the HTTP `Content-Type` (media type) for this response. It only tells us that the logical response schema is `DownloadApiModel` and that `data` contains the binary file. So we cannot state a specific media type like `application/pdf` or `application/octet-stream` from this excerpt.\n\n2. **IAM file metadata schema**\n\nFor IAM, the schema that exposes file metadata (including `remote_url` and `file_format`) is:\n\n- **Schema name:** `File`\n- **Type:** `object`\n- **Fields (relevant to correlation):**\n  - `id` (string): Unique identifier\n  - `remote_id` (string): Provider's unique identifier\n  - `name` (string): The name of the file\n  - `remote_url` (string): URL where the file content is located\n  - `file_format` (unknown): The file format of the file  \n  - Plus other metadata fields such as `category`, `category_id`, `created_at`, `updated_at`, `contents` (deprecated), etc.\n\n3. **How these responses could be combined for auditing**\n\nBased on these specs alone, an audit/monitoring flow could work like this:\n\n- Use the HRIS **download** endpoint to record:\n  - Which employee (`id`) and which document (`subResourceId`) was downloaded.\n  - The `headers` and the fact that a binary `data` payload was returned (indicating an actual download event).\n\n- Use the IAM **File** schema to look up metadata for the same logical document:\n  - Match on a common identifier such as `remote_id` or possibly `name` (the excerpt doesn\u2019t define the exact join key, only that both HRIS documents and IAM File objects expose `remote_id`, `name`, `remote_url`, and `file_format`-style fields).\n  - From IAM\u2019s `File`, pull `remote_url`, `file_format`, `category`, `created_at`, `updated_at`, etc.\n\n- In your audit log, for each HRIS document download event, you can then store:\n  - Employee identifier and document identifier from the HRIS download call.\n  - Download-specific info (e.g., timestamp, HRIS download `headers`).\n  - IAM file metadata (`remote_url`, `file_format`, `name`, `category_id`, etc.) from the `File` schema, to show what was actually downloaded and where it is stored remotely.\n\nThis creates a combined audit record where:\n- **HRIS** gives you the *download event* (binary file access).\n- **IAM** gives you the *file\u2019s descriptive metadata* (`remote_url`, `file_format`, and related fields) that can be correlated with that event.",
      "ground_truth_answer": "**HRIS \u2013 employee document download**\n- Endpoint: `GET /unified/hris/employees/{id}/documents/{subResourceId}/download`.\n- Response (status 200) supports many media types, all mapped to the same schema:\n  - Media types listed include (non\u2011exhaustive subset, all present in the spec):\n    - `application/pdf`\n    - `application/msword`\n    - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n    - `application/vnd.ms-excel`\n    - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n    - `application/vnd.ms-powerpoint`\n    - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n    - `application/rtf`, `text/plain`, `text/csv`, `text/html`, `text/rtf`\n    - `image/jpeg`, `image/png`, `image/gif`, `image/tiff`, `image/bmp`, `image/heic`, `image/webp`\n    - `application/zip`, `application/gzip`, `application/x-rar-compressed`, `application/x-7z-compressed`\n    - `audio/mpeg`, `audio/wav`, `audio/mp4`\n    - `video/mp4`, `video/webm`, `video/avi`, `video/quicktime`\n    - `application/json`, `application/xml`, `application/vnd.oasis.opendocument.text`, `application/vnd.oasis.opendocument.spreadsheet`, `application/vnd.oasis.opendocument.presentation`, `message/rfc822`, `application/vnd.ms-outlook`, `application/octet-stream`\n  - For **all** these content types, the response schema is:\n    - `#/components/schemas/DownloadApiModel`.\n  - This means the monitoring tool can always parse the download response as a `DownloadApiModel` instance, regardless of the concrete media type.\n\n**IAM \u2013 file metadata**\n- Schema: `File` (`#/components/schemas/File`).\n- This schema provides file metadata fields that your monitoring tool can use for correlation and auditing, for example:\n  - `id`: Unique identifier.\n  - `remote_id`: Provider\u2019s unique identifier.\n  - `name`: Human-readable file name.\n  - `category` / `category_id`: Categorical grouping of the file.\n  - `created_at`, `updated_at`: Timestamps for file lifecycle.\n  - **`remote_url`**: \"URL where the file content is located\" \u2013 this is especially useful to relate to where content is actually stored or served from.\n  - **`file_format`**: An enum (`FileFormatEnum`) describing the file format, which can be mapped against the HRIS document media types.\n\n**How the responses could be combined for auditing**\n- When a document is downloaded via the HRIS endpoint, the monitoring tool:\n  1. Records the `DownloadApiModel` payload (from one of the various media types).\n  2. Extracts any identifiers or metadata in `DownloadApiModel` that identify the document or its storage representation (the full `DownloadApiModel` structure is not shown here, but the tool can at least log that the content was retrieved under a specific MIME type for a given employee and document ID pair).\n- In parallel or afterwards, the tool queries IAM for file metadata using the `File` schema (through IAM file-related endpoints in the full spec) and logs:\n  - `File.id` / `remote_id` to track the object across systems.\n  - `File.remote_url` to see the actual storage or provider URL used for serving content.\n  - `File.file_format` to categorize the document format in a normalized way.\n- By joining:\n  - The HRIS download event (employee ID, document ID, media type, `DownloadApiModel` details, timestamp), with\n  - The IAM `File` metadata (file identifiers, `remote_url`, `file_format`, created/updated timestamps),\n  the monitoring tool can produce an audit trail that shows **who downloaded which HRIS employee document, in what format (media type + `file_format`), and from which underlying file URL (`remote_url`)**, even though the raw binary document comes from HRIS and the metadata lives in IAM.\n\nThus, HRIS provides the multi\u2011media `DownloadApiModel` responses for actual document downloads, and IAM\u2019s `File` schema supplies the file metadata (`remote_url`, `file_format`, etc.) that can be correlated with those downloads for comprehensive auditing.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/{subResourceId}/download.get",
        "hris.components.DownloadApiModel",
        "iam.components.File"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_id_documents_subresourceid_download",
        "hris_components_downloadapimodel",
        "iam_components_file",
        "hris_components_hrisdocumentresult",
        "hris_components_hrisdocumentapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "cross_api_s1_001",
      "question": "Which unified APIs shown (HRIS, ATS, LMS, IAM, CRM, MARKETING) require the same x-account-id header for authenticated requests, and which StackOne endpoints instead use basic auth without this header?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING",
        "STACKONE"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only shows HRIS endpoints (Employees, Jobs, Employments) that use HTTP Basic authentication and require an `x-account-id` header. There is no information in the provided text about ATS, LMS, IAM, CRM, or MARKETING APIs, nor about any StackOne endpoints that use basic auth without the `x-account-id` header.",
      "ground_truth_answer": "All of the unified product APIs shown\u2014HRIS, ATS, LMS, IAM, CRM, and MARKETING\u2014require an x-account-id header on their endpoints as the account identifier. For example, HRIS (/unified/hris/employees/{id}/documents/upload, /unified/hris/groups/{id}, etc.), ATS (/unified/ats/lists, /unified/ats/applications/{id}/notes/{subResourceId}, etc.), LMS (/unified/lms/content/batch, /unified/lms/users, /unified/lms/courses/{id}, etc.), IAM (/unified/iam/roles, /unified/iam/users/{id}, /unified/iam/policies, etc.), CRM (/unified/crm/accounts/{id}, /unified/crm/contacts, /unified/crm/lists, etc.), and MARKETING (/unified/marketing/templates/omni_channel/{id}, /unified/marketing/content_blocks/{id}, /unified/marketing/campaigns/{id}, /unified/marketing/templates/sms/{id}, etc.) all define a required header parameter named x-account-id.\n\nThe core StackOne platform endpoints instead use basic auth only and do not define an x-account-id header parameter. For example, /requests/logs/steps, /requests/platform-logs, /connectors/meta, /connect_sessions (POST), and /accounts/{id}/meta are all secured with basic auth (security: basic) and have no x-account-id header parameter at all.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/employees/{id}/documents/upload.post",
        "hris.paths./unified/hris/groups/{id}.get",
        "hris.paths./unified/hris/jobs.get",
        "ats.paths./unified/ats/lists.get",
        "ats.paths./unified/ats/applications/{id}/notes/{subResourceId}.get",
        "ats.paths./unified/ats/applications/{id}/offers.get",
        "lms.paths./unified/lms/content/batch.post",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/courses/{id}.get",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/users/{id}.get",
        "crm.paths./unified/crm/accounts/{id}.get",
        "crm.paths./unified/crm/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "marketing.paths./unified/marketing/templates/omni_channel/{id}.get",
        "marketing.paths./unified/marketing/content_blocks/{id}.get",
        "marketing.paths./unified/marketing/templates/push/{id}.get",
        "marketing.paths./unified/marketing/campaigns/{id}.get",
        "marketing.paths./unified/marketing/templates/sms/{id}.get",
        "stackone.paths./requests/logs/steps.get",
        "stackone.paths./requests/platform-logs.get",
        "stackone.paths./connectors/meta.get",
        "stackone.paths./connect_sessions.post",
        "stackone.paths./accounts/{id}/meta.get"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_employees_part0",
        "hris_paths_get_unified_hris_jobs_part0",
        "hris_paths_post_unified_hris_employees_id_employments_part1",
        "hris_paths_patch_unified_hris_employees_id_employments_subresourceid_part1",
        "lms_paths_put_unified_lms_content_part1"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_002",
      "question": "Compare how cursor-based pagination is implemented in the HRIS list jobs endpoint, the ATS list lists endpoint, and the CRM list contacts endpoint. What shared query parameters and response fields are used, and what differences (if any) exist in their pagination-related parameters?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "CRM"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. \n\nFrom the provided context, I can see that:\n\n- HRIS `GET /unified/hris/jobs` lists Jobs and has pagination-related query parameters:\n  - `page` (query, optional, string): page number\n  - `page_size` (query, optional, string): number of results per page (default 25)\n  - `next` (query, optional, string): described only as \"The unified\" (the description is cut off)\n\n- CRM `GET /unified/crm/contacts` lists Contacts and has the same pagination-related query parameters:\n  - `page`\n  - `page_size`\n  - `next` (again, description is cut off as \"The\")\n\n- ATS `GET /unified/ats/lists` lists Lists and also has:\n  - `page`\n  - `page_size`\n  - `next` (description cut off as \"The unified\")\n  - `updated_after` (query, optional, string): filter by updated-after date\n\nHowever, the context only partially shows the corresponding response schemas, and they are mixed with unrelated text (e.g., references to \u201cjob custom field definitions\u201d or \u201ctasks for the employee\u201d), and the descriptions of `next` as a query parameter are truncated. It\u2019s not clearly or consistently stated for each of the three endpoints:\n\n- Whether `next` is definitively a cursor token for cursor-based pagination in all three, or how exactly it is used.\n- What exact response fields (e.g., `next`, `next_page`, `cursor`, etc.) are returned per endpoint for pagination, and whether those differ between HRIS, ATS, and CRM.\n\nBecause of these truncations and cross\u2011mixed snippets, I cannot reliably compare:\n\n- How cursor-based pagination is implemented across the three endpoints, nor\n- Any precise differences in pagination-related response fields between HRIS, ATS, and CRM.\n\nAll I can see is that all three share `page`, `page_size`, and a `next` query parameter, and ATS additionally exposes `updated_after`. Beyond that, the documentation excerpt doesn\u2019t provide complete or consistent pagination-response details for each endpoint, so I can\u2019t give an accurate comparison.",
      "ground_truth_answer": "All three endpoints\u2014HRIS list jobs (GET /unified/hris/jobs), ATS list lists (GET /unified/ats/lists), and CRM list contacts (GET /unified/crm/contacts)\u2014implement cursor-based pagination in a very similar way.\n\nShared patterns:\n- All three accept an optional next query parameter described as \"The unified cursor\" and typed as a nullable string.\n- All three accept a page_size query parameter described as \"The number of results per page (default value is 25)\".\n- All three have an older page query parameter that is marked deprecated.\n- All three support an updated_after filter value in a nested filter object, and they also expose an updated_after top-level query parameter which is marked deprecated.\n- In their responses, all three return a next field in the paginated schema (HrisJobsPaginated, ListsPaginated, ContactsPaginated) that holds the next cursor.\n- Each paginated schema also supports a deprecated next_page field.\n\nSpecifics:\n- HRIS: GET /unified/hris/jobs uses HrisJobsPaginated, which has properties next_page (deprecated), next (string, nullable), data (array of HrisJob), and raw.\n- ATS: GET /unified/ats/lists uses ListsPaginated, which similarly contains next_page (deprecated), next, data, and raw.\n- CRM: GET /unified/crm/contacts uses ContactsPaginated, again with next_page (deprecated), next, data, and raw.\n\nDifferences:\n- Semantically the resources differ (jobs vs ATS lists vs CRM contacts), but pagination-related parameter names (page, page_size, next, updated_after) and their meanings are effectively aligned across the three APIs.\n- The filter object names and descriptions are nearly identical, but the specific resource types within data differ according to the respective schemas (HrisJob, List, Contact).",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/lists.get",
        "ats.components.ApplicationChangesPaginated",
        "crm.paths./unified/crm/contacts.get",
        "crm.components.ContactResult"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "crm_paths_get_unified_crm_contacts_part0",
        "ats_paths_get_unified_ats_lists_part0",
        "ats_paths_get_unified_ats_custom_field_definitions_jobs_part1",
        "hris_paths_get_unified_hris_employees_id_tasks_part2"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s1_003",
      "question": "You need to build an audit feature that shows, for a single business customer, both: (1) high-level metadata about their linked account and connector configuration, and (2) all LMS users linked to that same account filtered by email or external_reference. Which StackOne and LMS endpoints and schemas would you combine, and how do the filtering and response structures differ between the StackOne meta endpoints and the LMS list users endpoint?",
      "category": "cross_api",
      "relevant_apis": [
        "STACKONE",
        "LMS"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context you provided only includes schema snippets for:\n\n- `LinkedAccountMeta`\n- `ConnectSession`\n- `ConnectSessionTokenAuthLink`\n- `ConnectSessionCreate`\n- `ConnectorsMetaResourcesImagesApiModel`\n\nThere is no information here about:\n\n- Specific StackOne \u201cmeta\u201d endpoints (URLs, request/response examples, or how to query them)\n- Any LMS-related endpoints (such as a \u201clist users\u201d endpoint)\n- How filtering by `email` or `external_reference` works for LMS users\n- The detailed response structures for LMS user objects\n\nWithout explicit documentation of the LMS endpoints and their schemas, and without the concrete StackOne meta endpoints you\u2019d call, I can\u2019t reliably describe which endpoints to combine or how their filtering and response structures differ.",
      "ground_truth_answer": "To implement this cross-cutting audit feature you would combine StackOne core metadata endpoints with the LMS users listing endpoint:\n\n1) Account-level and connector-level metadata (StackOne API):\n- GET /accounts/{id}/meta (operationId: stackone_get_account_meta_info)\n  - Returns a LinkedAccountMeta object (via the LinkedAccountMeta schema) containing meta information for a specific linked account ID.\n- GET /connectors/meta (operationId: stackone_list_connectors_meta)\n  - Returns an array of ConnectorsMeta objects describing connectors\u2019 meta information across providers.\n\nThese StackOne endpoints:\n- Use basic auth and do not require x-account-id.\n- Do not support cursor-based pagination (the /accounts/{id}/meta is a single-object lookup; /connectors/meta returns an array without next/next_page fields).\n- Do not have rich filter objects; /connectors/meta only supports a simple include query parameter to control what additional data is included (e.g., field_path, unmapped_fields, resources, inactive, webhooks, static_fields). /accounts/{id}/meta has only the path id parameter.\n- Their response bodies are direct object(s) (LinkedAccountMeta or array of ConnectorsMeta), not a paginated wrapper with next/raw.\n\n2) Per-account LMS users overview, filterable by identity (LMS API):\n- GET /unified/lms/users (operationId: lms_list_users)\n  - Requires an x-account-id header to specify which customer account to query.\n  - Supports detailed filtering via a filter query parameter object with properties:\n    - updated_after (date-time)\n    - email (string)\n    - external_reference (string)\n  - Supports cursor pagination via:\n    - page_size (results per page, default 25)\n    - next (unified cursor)\n    - page (deprecated)\n    - updated_after (top-level, deprecated duplicate of the filter field)\n  - The response is a UsersPaginated object with:\n    - next (string, nullable) \u2013 next cursor\n    - data \u2013 array of LmsUser records\n    - raw \u2013 optional array of RawResponse\n\nKey differences in filtering and response structure:\n- Authentication & scoping:\n  - StackOne meta endpoints are scoped by account id in the path (/accounts/{id}/meta) or globally (/connectors/meta) and rely on basic auth; they do not use x-account-id.\n  - The LMS users endpoint is always scoped by x-account-id and is part of the unified LMS surface.\n\n- Filtering capabilities:\n  - StackOne /accounts/{id}/meta has no filter object\u2014only the path id.\n  - StackOne /connectors/meta has only a simple include string to control additional included data; it has no pagination or complex filters.\n  - LMS /unified/lms/users has a structured filter object allowing you to select users by updated_after, email, or external_reference.\n\n- Pagination and wrappers:\n  - StackOne meta endpoints return raw objects or arrays (LinkedAccountMeta, array of ConnectorsMeta) with no next/next_page or data/raw wrapper.\n  - LMS /unified/lms/users returns a UsersPaginated wrapper that separates next (cursor), data (array of LmsUser), and optional raw provider responses.\n\nTo build the feature:\n- Call GET /accounts/{id}/meta to retrieve LinkedAccountMeta for the specific StackOne account.\n- Optionally call GET /connectors/meta with include to enrich connector configuration details.\n- Then call GET /unified/lms/users for that same customer, passing their x-account-id and using filter.email and/or filter.external_reference plus pagination (page_size, next) as needed to list all relevant LMS users.\n- Combine these responses in your UI: StackOne meta for top-level account/connector context, and UsersPaginated.data for the actual LMS users related to that account.",
      "relevant_structural_ids": [
        "stackone.paths./accounts/{id}/meta.get",
        "stackone.paths./connectors/meta.get",
        "stackone.components.ConnectSession",
        "lms.paths./unified/lms/users.get",
        "lms.components.UsersPaginated",
        "lms.components.Assignment",
        "lms.components.ProviderError"
      ],
      "retrieved_chunk_ids": [
        "stackone_components_linkedaccountmeta",
        "stackone_components_connectsession",
        "stackone_components_connectsessiontokenauthlink",
        "stackone_components_connectsessioncreate_part0",
        "stackone_components_connectorsmetaresourcesimagesapimodel"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 2,
      "accuracy_score": 4
    },
    {
      "question_id": "cross_api_s2_001",
      "question": "Which StackOne unified APIs shown support cursor-based pagination using a `next` query parameter, and what is the response field that returns the cursor in each of those APIs?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "ATS",
        "LMS",
        "IAM",
        "CRM",
        "MARKETING"
      ],
      "generated_answer": "The following StackOne unified APIs in the provided context support cursor-based pagination using a `next` query parameter, and they return the cursor in the response as follows:\n\n1. **GET /actions**  \n   - **Query parameter for cursor:** `next`  \n   - **Response field containing the cursor:** `next`\n\n2. **GET /requests/logs**  \n   - **Query parameter for cursor:** `next`  \n   - **Response field containing the cursor:** `next`\n\n3. **GET /requests/logs/steps**  \n   - **Query parameter for cursor:** `next`  \n   - **Response field containing the cursor:** `next`\n\n4. **ActionsRpcResponse schema** (used for action RPC calls)  \n   - **Query parameter for cursor:** `next` (described in the shared pagination snippet)  \n   - **Response field containing the cursor:** `next`",
      "ground_truth_answer": "Several unified APIs support cursor-based pagination using a `next` query parameter and return the cursor in a `next` field in the response:\n\n- HRIS Jobs:\n  - Request: `GET /unified/hris/jobs` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `HrisJobsPaginated` (referenced in the 200 response) contains a `next` property which is used as the cursor (the x-speakeasy pagination config maps `outputs.nextCursor` to `$.next`).\n\n- ATS Offers:\n  - Request: `GET /unified/ats/offers` accepts a `next` query parameter described as \"The unified cursor\".\n  - Response: schema `OffersPaginated` (referenced in the 200 response) also exposes a `next` property as the cursor.\n\n- LMS Users, Assignments, Skills, Courses:\n  - Requests:\n    - `GET /unified/lms/users`\n    - `GET /unified/lms/users/{id}/assignments`\n    - `GET /unified/lms/skills`\n    - `GET /unified/lms/courses`\n    each accepts a `next` query parameter described as \"The unified cursor\".\n  - Responses: each returns a `*Paginated` schema (`UsersPaginated`, `AssignmentsPaginated`, `SkillsPaginated`, `CoursePaginated`) that contains a `next` field used as the cursor.\n\n- IAM Roles and Policies:\n  - Requests:\n    - `GET /unified/iam/roles`\n    - `GET /unified/iam/policies`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: both return a paginated result (`IamRolesPaginated`, `IamPoliciesPaginated`) that include a `next` field.\n\n- CRM Contact Custom Field Definitions, Lists, Accounts:\n  - Requests:\n    - `GET /unified/crm/custom_field_definitions/contacts`\n    - `GET /unified/crm/lists`\n    - `GET /unified/crm/accounts`\n    accept a `next` query parameter as \"The unified cursor\".\n  - Responses: paginated schemas (`CustomFieldDefinitionsPaginated`, `ListsPaginated`, `AccountsPaginated`) contain a `next` field.\n\n- MARKETING Templates (Omni-Channel, Email, In-App):\n  - Requests:\n    - `GET /unified/marketing/templates/omni_channel`\n    - `GET /unified/marketing/templates/email`\n    - `GET /unified/marketing/templates/in_app`\n    accept a `next` query parameter described as \"The unified cursor\".\n  - Responses: paginated schemas (`TemplatesPaginated`, `EmailTemplatesPaginated`, `InAppTemplatesPaginated`) expose a `next` field.\n\nAcross these APIs, the pattern is consistent: the `next` query parameter is used to send the cursor, and the response body returns the next cursor in a top-level `next` field within the corresponding paginated schema.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJobsPaginated",
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "lms.paths./unified/lms/users.get",
        "lms.paths./unified/lms/users/{id}/assignments.get",
        "lms.paths./unified/lms/skills.get",
        "lms.paths./unified/lms/courses.get",
        "lms.components.UsersPaginated",
        "lms.components.AssignmentsPaginated",
        "lms.components.SkillsPaginated",
        "lms.components.CoursePaginated",
        "iam.paths./unified/iam/roles.get",
        "iam.paths./unified/iam/policies.get",
        "iam.components.IamRolesPaginated",
        "iam.components.IamPoliciesPaginated",
        "crm.paths./unified/crm/custom_field_definitions/contacts.get",
        "crm.paths./unified/crm/lists.get",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.CustomFieldDefinitionsPaginated",
        "crm.components.ListsPaginated",
        "crm.components.AccountsPaginated",
        "marketing.paths./unified/marketing/templates/omni_channel.get",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.paths./unified/marketing/templates/in_app.get",
        "marketing.components.TemplatesPaginated",
        "marketing.components.EmailTemplatesPaginated",
        "marketing.components.InAppTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "stackone_paths_get_actions",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_steps",
        "stackone_components_actionsrpcresponse",
        "hris_paths_get_unified_hris_employees_part1"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 1
    },
    {
      "question_id": "cross_api_s2_002",
      "question": "Compare how list endpoints in the HRIS Jobs API and CRM Accounts API allow clients to restrict returned fields and filter by `updated_after`. What are the request parameters used for field selection and for updated-after filtering in each API?",
      "category": "cross_api",
      "relevant_apis": [
        "HRIS",
        "CRM"
      ],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The context only specifies generic `fields` and `filter` parameters for the HRIS Jobs and CRM Accounts list endpoints, without detailing any specific filter keys such as `updated_after` or showing concrete examples of how to use them.",
      "ground_truth_answer": "Both the HRIS Jobs and CRM Accounts list endpoints support restricting returned fields via a `fields` parameter, and filtering by `updated_after`, but they expose the filters slightly differently.\n\nHRIS Jobs (`GET /unified/hris/jobs`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,code,title,description,status,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject; allows nested keys.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n       - Description: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description and example date-time format.\n\nCRM Accounts (`GET /unified/crm/accounts`):\n- Field selection:\n  - Query parameter: `fields`\n  - Description: \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n  - Type: string (example includes `id,remote_id,owner_id,remote_owner_id,name,description,industries,annual_revenue,website,addresses,phone_numbers,created_at,updated_at,unified_custom_fields`).\n- Updated-after filtering:\n  1. A structured `filter` object:\n     - Query parameter: `filter`\n     - Style: deepObject.\n     - Schema includes property `updated_after`:\n       - Type: string, format `date-time`, nullable, example `2020-01-01T00:00:00.000Z`.\n       - Same description as HRIS: \"Use a string with a date to only select results updated after that given date\".\n  2. A deprecated top-level `updated_after` parameter:\n     - Query parameter: `updated_after` (deprecated: true)\n     - Same description, type, and example.\n\nIn summary, both APIs:\n- Use a `fields` query parameter to choose which fields are returned.\n- Offer two ways to filter by `updated_after`: a preferred nested `filter[updated_after]` deepObject parameter, and a deprecated top-level `updated_after` parameter with the same semantics and date-time format.",
      "relevant_structural_ids": [
        "hris.paths./unified/hris/jobs.get",
        "hris.components.HrisJob",
        "crm.paths./unified/crm/accounts.get",
        "crm.components.AccountsPaginated"
      ],
      "retrieved_chunk_ids": [
        "hris_paths_get_unified_hris_jobs_part0",
        "crm_paths_get_unified_crm_accounts_part0",
        "hris_paths_get_unified_hris_employments_part0",
        "hris_paths_get_unified_hris_positions_part0",
        "hris_paths_get_unified_hris_companies_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 2
    },
    {
      "question_id": "cross_api_s2_003",
      "question": "You need to build a security-aware client that calls both the ATS `List Offers` endpoint and the MARKETING `List Email Templates` endpoint. Based on the sampled specs, which authentication mechanism and required header must your client send to access both endpoints successfully, and which common query parameters (by name and purpose) can it reuse across these two APIs for controlling raw responses, provider passthrough, field selection, filtering, pagination, and incremental sync?",
      "category": "cross_api",
      "relevant_apis": [
        "ATS",
        "MARKETING"
      ],
      "generated_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use:\n\n**Authentication mechanism:**\n- **HTTP Basic** authentication (as specified for both endpoints).\n\n**Required header:**\n- **`x-account-id` (header, string, required)** \u2013 The account identifier that must be sent on each request.\n\n**Common reusable query parameters across both endpoints:**\n\n1. **`raw` (boolean)**  \n   - **Purpose:** If `true`, the response includes the raw provider result in addition to the mapped (unified) result. Default is `false`.\n\n2. **`proxy` (object)**  \n   - **Purpose:** Allows passthrough of query parameters directly to the underlying provider by wrapping them in a `proxy` object.\n\n3. **`fields` (string)**  \n   - **Purpose:** A comma-separated list of fields to return. If omitted/empty, all fields are returned.\n\n4. **`filter` (object)**  \n   - **Purpose:** Filter parameters to customize the list response (e.g., narrowing the results set).\n\n5. **`page` (string)**  \n   - **Purpose:** The page number of results to fetch (page-based pagination).\n\n6. **`page_size` (string)**  \n   - **Purpose:** The number of results per page; defaults to 25 if not specified.\n\nThese shared parameters let your client consistently control raw vs. mapped responses, provider passthrough, field selection, filtering, and page-based pagination across both ATS and MARKETING. The snippet does not show an `updated_after` or similar incremental-sync parameter for these two specific endpoints, so incremental sync must rely on the general `filter` object where supported.",
      "ground_truth_answer": "For both ATS `List Offers` and MARKETING `List Email Templates`, the client must use HTTP Basic authentication and send the same required account-identification header. They also share a common set of query parameters for raw responses, passthrough, fields, filters, pagination, and incremental sync.\n\nAuthentication and required header (common to both):\n- Security:\n  - Both endpoints declare `security: [ { \"basic\": [] } ]`, meaning Basic Auth is required.\n- Required account header:\n  - Header name: `x-account-id`\n  - Location: header\n  - Description (both): \"The account identifier\".\n  - Type: string and `required: true` in both paths.\n\nEndpoints:\n- ATS Offers: `GET /unified/ats/offers`\n- Marketing Email Templates: `GET /unified/marketing/templates/email`\n\nCommon or analogous query parameters and their purposes:\n\n1. Control inclusion of raw provider responses:\n- Parameter: `raw` (boolean, optional) in both endpoints.\n- Description (both): \"Indicates that the raw request result should be returned in addition to the mapped result (default value is false)\".\n- Purpose: toggle returning the underlying provider raw data alongside the unified/mapped response.\n\n2. Provider passthrough of custom query params:\n- Parameter: `proxy` (object, style `deepObject`, optional) in both endpoints.\n- Description (both): \"Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key\".\n- Purpose: let the client forward provider-specific query parameters without the unified API needing to model them explicitly.\n\n3. Field selection:\n- Parameter: `fields` (string, optional) in both endpoints.\n- Description pattern (both): \"The comma separated list of fields that will be returned in the response (if empty, all fields are returned)\".\n- Example values differ by domain (offers vs templates), but semantics are identical: restrict which fields appear in the response.\n\n4. Generic filter object including `updated_after`:\n- Parameter: `filter` (object, style `deepObject`, optional) in both endpoints.\n- Each filter schema has a property `updated_after`:\n  - Type: string, format `date-time`, nullable, with example `2020-01-01T00:00:00.000Z`.\n  - Description (both): \"Use a string with a date to only select results updated after that given date\".\n- Purpose: incremental or time-based filtering using a unified `filter[updated_after]` parameter.\n\n5. Cursor-based pagination controls:\n- Parameter: `page` (string, optional, deprecated) in both endpoints.\n  - Description: \"The page number of the results to fetch\"; `deprecated: true`.\n- Parameter: `page_size` (string, optional) in both endpoints.\n  - Description: \"The number of results per page (default value is 25)\".\n- Parameter: `next` (string, optional) in both endpoints.\n  - Description: \"The unified cursor\".\n- Purpose: `page`/`page_size` for legacy page-number pagination; `next` for the preferred cursor-based pagination. Both ATS Offers and Marketing Email Templates also declare x-speakeasy cursor pagination that maps the response\u2019s `next` field as the cursor.\n\n6. Deprecated top-level `updated_after` incremental filter:\n- Parameter: `updated_after` (string, format `date-time`, optional, `deprecated: true`) in both endpoints.\n  - Description: the same as the filter property: \"Use a string with a date to only select results updated after that given date\".\n- Purpose: a legacy shortcut to filter by update time without using the `filter` object.\n\n7. ATS-only incremental sync token (not shared with Marketing but relevant for ATS security-aware clients):\n- Parameter on ATS Offers only: `sync_token` (string, deprecated) to \"select the only updated results\".\n\nSummary for the client:\n- Use Basic Auth and always include `x-account-id` in the request headers for both ATS Offers and Marketing Email Templates.\n- Reuse these query parameters (same names and semantics across both):\n  - `raw` (include raw provider responses)\n  - `proxy` (provider passthrough)\n  - `fields` (field projection)\n  - `filter[updated_after]` via the `filter` deepObject\n  - `page`, `page_size`, and `next` for pagination\n  - Deprecated top-level `updated_after` for incremental filtering if needed.\n- Additionally, ATS Offers alone offers a `sync_token` parameter for incremental sync at the ATS layer.",
      "relevant_structural_ids": [
        "ats.paths./unified/ats/offers.get",
        "ats.components.OffersPaginated",
        "marketing.paths./unified/marketing/templates/email.get",
        "marketing.components.EmailTemplatesPaginated"
      ],
      "retrieved_chunk_ids": [
        "ats_paths_get_unified_ats_offers_part0",
        "marketing_paths_get_unified_marketing_templates_email_part0",
        "ats_paths_get_unified_ats_interviews_part0",
        "ats_paths_get_unified_ats_applications_id_changes_part1",
        "ats_paths_get_unified_ats_lists_part0"
      ],
      "retrieval_hit": true,
      "first_relevant_rank": 1,
      "accuracy_score": 3
    },
    {
      "question_id": "out_of_scope_001",
      "question": "What are the pricing tiers for StackOne, including any overage fees and volume discounts for high API usage?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only covers schemas and endpoints related to connect sessions and account meta information; it does not mention any pricing tiers, overage fees, or volume discounts.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the pricing or billing details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectsession",
        "stackone_paths_post_connect_sessions_authenticate_part0",
        "stackone_components_connectsessiontokenauthlink",
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_get_accounts_id_meta"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_002",
      "question": "Does StackOne provide a financially backed SLA, and what are the uptime guarantees and compensation terms if the SLA is breached?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only defines several error response schemas (e.g., `BadRequestResponse`, `InternalServerErrorResponse`, `RequestTimedOutResponse`, `ProviderError`) and does not mention any service-level agreement, uptime guarantees, or financial compensation terms.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the SLA or uptime guarantee details.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_requesttimedoutresponse",
        "stackone_components_providererror",
        "stackone_components_internalservererrorresponse",
        "stackone_components_preconditionfailedresponse",
        "stackone_components_badrequestresponse"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_003",
      "question": "How can I customize the StackOne web dashboard UI, such as adding custom widgets, themes, or role-specific views?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only covers APIs for creating connect sessions (`POST /connect_sessions`) and listing/retrieving connector metadata (`GET /connectors/meta` and `GET /connectors/meta/{provider}`), and does not mention any capabilities for customizing the StackOne web dashboard UI (such as custom widgets, themes, or role-specific views).",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know how to configure the dashboard or UI from the docs.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_components_connectsessioncreate_part0",
        "stackone_paths_post_connect_sessions_part0",
        "stackone_components_connectorsmeta",
        "stackone_paths_get_connectors_meta",
        "stackone_paths_get_connectors_meta_provider"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_004",
      "question": "Does StackOne support a fully on\u2011premise deployment, and if so, what are the hardware requirements and installation steps?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only describes several HTTP API endpoints (`/mcp`, `/unified/proxy`, `/actions/rpc`), their parameters, and responses. It does not mention deployment models (cloud vs. on\u2011prem), hardware requirements, or installation steps.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know whether on\u2011premise deployment is supported or how to install it.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "stackone_paths_post_mcp",
        "stackone_paths_get_mcp",
        "stackone_paths_post_unified_proxy_part0",
        "stackone_components_proxyrequestbody",
        "stackone_paths_post_actions_rpc"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    },
    {
      "question_id": "out_of_scope_005",
      "question": "What is StackOne\u2019s policy on data retention and employee access to customer data, and can customers request custom data residency guarantees?",
      "category": "out_of_scope",
      "relevant_apis": [],
      "generated_answer": "I don't have enough information in the StackOne documentation to answer this question. The provided context only describes specific API endpoints (like `iam_get_policy` and `stackone_list_logs`) and their request/response structures, but it does not mention StackOne\u2019s data retention policies, employee access to customer data, or any options for custom data residency guarantees.",
      "ground_truth_answer": "This information is not available in the StackOne API documentation; the system should respond that it does not know the company\u2019s data retention or internal access policies.",
      "relevant_structural_ids": [],
      "retrieved_chunk_ids": [
        "iam_paths_get_unified_iam_policies_id_part1",
        "iam_paths_get_unified_iam_users_id_part2",
        "stackone_paths_get_requests_logs",
        "stackone_paths_get_requests_logs_id_part0",
        "stackone_components_unifiedlogs"
      ],
      "retrieval_hit": false,
      "first_relevant_rank": null,
      "accuracy_score": 5,
      "abstention_score": 1
    }
  ]
}